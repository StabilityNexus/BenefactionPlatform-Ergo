{"file_contents":{"tests/contracts/withdraw_unsold_tokens.test.ts":{"content":"import { describe, it, expect, beforeEach } from \"vitest\";\nimport { Box, OutputBuilder, TransactionBuilder, RECOMMENDED_MIN_FEE_VALUE, ErgoTree } from \"@fleet-sdk/core\";\nimport { SByte, SColl, SInt, SLong } from \"@fleet-sdk/serializer\";\nimport { stringToBytes } from \"@scure/base\";\nimport {\n  setupBeneTestContext,\n  ERG_BASE_TOKEN,\n  ERG_BASE_TOKEN_NAME,\n  type BeneTestContext,\n  USD_BASE_TOKEN,\n  USD_BASE_TOKEN_NAME,\n  createR4\n} from \"./bene_contract_helpers\";\nimport { compile } from \"@fleet-sdk/compiler\";\n\n// EXECUTION FLOW:\n// Owner can withdraw unsold PFT tokens at any time\n\nconst baseModes = [\n  { name: \"USD Token Mode\", token: USD_BASE_TOKEN, tokenName: USD_BASE_TOKEN_NAME },\n  { name: \"ERG Mode\", token: ERG_BASE_TOKEN, tokenName: ERG_BASE_TOKEN_NAME },\n];\n\ndescribe.each(baseModes)(\"Bene Contract v1.2 - Withdraw Unsold Tokens (%s)\", (mode) => {\n\n  describe(\"Withdraw Unsold Tokens with any APT sold exchanged for PFTs\", () => {\n    let ctx: BeneTestContext;\n    let projectBox: Box; // Contract box\n    let soldTokens: bigint;\n    let collectedFunds: bigint;\n\n    beforeEach(() => {\n      ctx = setupBeneTestContext(mode.token, mode.tokenName);\n\n      // STEP 1: Create project box with partial token sales\n      soldTokens = ctx.totalPFTokens / 2n; // Half of the total PFTs has been sold.\n      collectedFunds = soldTokens * ctx.exchangeRate;\n\n      let assets = [\n        { tokenId: ctx.projectNftId, amount: 1n + ctx.totalPFTokens - soldTokens },\n        { tokenId: ctx.pftTokenId, amount: ctx.totalPFTokens }, // 100k PFT total\n      ];\n\n      let value = RECOMMENDED_MIN_FEE_VALUE;\n\n      // Handle collected funds based on mode\n      if (!ctx.isErgMode) {\n        // USD Mode: Add funds as a token\n        assets.push({ tokenId: ctx.baseTokenId, amount: collectedFunds });\n      } else {\n        // ERG Mode: Add funds to the box value\n        value += collectedFunds;\n      }\n\n      ctx.beneContract.addUTxOs({\n        value: value,\n        ergoTree: ctx.beneErgoTree.toHex(),\n        assets: assets,\n        creationHeight: ctx.mockChain.height - 100,\n        additionalRegisters: {\n          R4: createR4(ctx),\n          R5: SLong(ctx.minimumTokensSold).toHex(),\n          R6: SColl(SLong, [soldTokens, 0n, 0n]).toHex(),\n          R7: SLong(ctx.exchangeRate).toHex(),\n          R8: ctx.constants.toHex(),\n          R9: SColl(SByte, stringToBytes(\"utf8\", \"{}\")).toHex(),\n        },\n      });\n\n      // STEP 2: Get reference to project box\n      projectBox = ctx.beneContract.utxos.toArray()[0];\n    });\n\n    it(\"should allow withdrawing unsold PFT tokens\", () => {\n      // ARRANGE: Owner wants to withdraw 50k unsold PFT tokens\n      const tokensToWithdraw = 50_000n; // Withdraw 50k\n      const remainingPFT = ctx.totalPFTokens - tokensToWithdraw; // 50k will remain in contract\n\n      console.log(\"\\nðŸ¦ WITHDRAW UNSOLD TOKENS:\");\n      console.log(`   Tokens Sold:       10,000 (from beforeEach)`);\n      console.log(`   Tokens Available:  90,000 (100k - 10k sold)`);\n      console.log(`   Tokens to Withdraw: ${tokensToWithdraw.toLocaleString()} PFT`);\n      console.log(`   PFT Remaining:     ${remainingPFT.toLocaleString()}`);\n\n      // Fund project owner for transaction (contract validates INPUTS(1) is owner)\n      ctx.projectOwner.addBalance({ nanoergs: 10_000_000_000n }); // 10 ERG for fees\n\n      const assets = [\n        { tokenId: ctx.projectNftId, amount: 1n + ctx.totalPFTokens - soldTokens },\n        { tokenId: ctx.pftTokenId, amount: remainingPFT }, // Add updated PFT amount\n      ];\n      if (!ctx.isErgMode) {\n        assets.push({ tokenId: ctx.baseTokenId, amount: collectedFunds })\n      }\n\n      // ACT: Build token withdrawal transaction\n      const transaction = new TransactionBuilder(ctx.mockChain.height)\n        // INPUTS: Contract box + owner box (contract checks INPUTS(1) for authorization)\n        .from([projectBox, ...ctx.projectOwner.utxos.toArray()]) // INPUTS(0)=contract, INPUTS(1)=owner\n        // OUTPUTS:\n        .to([\n          // Output 0: Updated contract (fewer PFT tokens)\n          // Value and collected funds (ERG or USD token) are unchanged\n          new OutputBuilder(projectBox.value, ctx.beneErgoTree)\n            .addTokens(assets)\n            .setAdditionalRegisters({\n              R4: projectBox.additionalRegisters.R4,\n              R5: SLong(ctx.minimumTokensSold).toHex(),\n              R6: SColl(SLong, [soldTokens, 0n, 0n]).toHex(), // Counters unchanged\n              R7: SLong(ctx.exchangeRate).toHex(),\n              R8: projectBox.additionalRegisters.R8,\n              R9: projectBox.additionalRegisters.R9,\n            }),\n          // Output 1: Owner receives unsold PFT (contract checks OUTPUTS(1))\n          new OutputBuilder(RECOMMENDED_MIN_FEE_VALUE, ctx.projectOwner.address).addTokens([\n            { tokenId: ctx.pftTokenId, amount: tokensToWithdraw }, // Owner gets 50k PFT\n          ]),\n        ])\n        .sendChangeTo(ctx.projectOwner.address)\n        .payFee(RECOMMENDED_MIN_FEE_VALUE)\n        .build();\n\n      // Execute transaction (contract validates owner authorization)\n      const result = ctx.mockChain.execute(transaction, { signers: [ctx.projectOwner] });\n\n\n      expect(result).toBe(true); // Transaction valid\n      expect(ctx.beneContract.utxos.length).toEqual(1); // Contract still has 1 box\n\n      const updatedBox = ctx.beneContract.utxos.toArray()[0];\n      const updatedPft = updatedBox.assets.find((t) => t.tokenId === ctx.pftTokenId);\n      expect(updatedPft?.amount).toEqual(remainingPFT); // Contract has 50k PFT remaining\n    });\n\n    it(\"should fail fully withdrawing unsold PFT tokens, because there are contributors with their APTs sold that will want to exchange them for PFTs\", () => {\n\n      // ARRANGE: Owner wants to withdraw 50k unsold PFT tokens\n      const tokensToWithdraw = ctx.totalPFTokens - soldTokens;\n\n      // Fund project owner for transaction (contract validates INPUTS(1) is owner)\n      ctx.projectOwner.addBalance({ nanoergs: 10_000_000_000n }); // 10 ERG for fees\n\n      // ACT: Build token withdrawal transaction\n      const transaction = new TransactionBuilder(ctx.mockChain.height)\n        // INPUTS: Contract box + owner box (contract checks INPUTS(1) for authorization)\n        .from([projectBox, ...ctx.projectOwner.utxos.toArray()]) // INPUTS(0)=contract, INPUTS(1)=owner\n        // OUTPUTS:\n        .to([\n          // Output 0: Owner receives unsold PFT (contract checks OUTPUTS(1))\n          new OutputBuilder(RECOMMENDED_MIN_FEE_VALUE, ctx.projectOwner.address).addTokens([\n            { tokenId: ctx.pftTokenId, amount: tokensToWithdraw },\n          ]),\n        ])\n        .sendChangeTo(ctx.projectOwner.address)\n        .payFee(RECOMMENDED_MIN_FEE_VALUE)\n        .build();\n\n      // Execute transaction (contract validates owner authorization)\n      const result = ctx.mockChain.execute(transaction, { signers: [ctx.projectOwner], throw: false });\n\n\n      expect(result).toBe(false);\n    });\n\n    it(\"should fail trying to avoid APTs\", () => {\n      // ARRANGE: Owner wants to withdraw 50k unsold PFT tokens\n      const tokensToWithdraw = 50_000n; // Withdraw 50k\n      const remainingPFT = ctx.totalPFTokens - tokensToWithdraw; // 50k will remain in contract\n\n      console.log(\"\\nðŸ¦ WITHDRAW UNSOLD TOKENS:\");\n      console.log(`   Tokens Sold:       10,000 (from beforeEach)`);\n      console.log(`   Tokens Available:  90,000 (100k - 10k sold)`);\n      console.log(`   Tokens to Withdraw: ${tokensToWithdraw.toLocaleString()} PFT`);\n      console.log(`   PFT Remaining:     ${remainingPFT.toLocaleString()}`);\n\n      // Fund project owner for transaction (contract validates INPUTS(1) is owner)\n      ctx.projectOwner.addBalance({ nanoergs: 10_000_000_000n }); // 10 ERG for fees\n\n      const assets = [\n        //  { tokenId: ctx.projectNftId, amount: 1n + ctx.totalPFTokens - soldTokens },\n        { tokenId: ctx.pftTokenId, amount: remainingPFT }, // Add updated PFT amount\n      ];\n      if (!ctx.isErgMode) {\n        assets.push({ tokenId: ctx.baseTokenId, amount: collectedFunds })\n      }\n\n      // ACT: Build token withdrawal transaction\n      const transaction = new TransactionBuilder(ctx.mockChain.height)\n        // INPUTS: Contract box + owner box (contract checks INPUTS(1) for authorization)\n        .from([projectBox, ...ctx.projectOwner.utxos.toArray()]) // INPUTS(0)=contract, INPUTS(1)=owner\n        // OUTPUTS:\n        .to([\n          // Output 0: Updated contract (fewer PFT tokens)\n          // Value and collected funds (ERG or USD token) are unchanged\n          new OutputBuilder(projectBox.value, ctx.beneErgoTree)\n            .addTokens(assets)\n            .setAdditionalRegisters({\n              R4: projectBox.additionalRegisters.R4,\n              R5: SLong(ctx.minimumTokensSold).toHex(),\n              R6: SColl(SLong, [10_000n, 0n, 0n]).toHex(), // Counters unchanged\n              R7: SLong(ctx.exchangeRate).toHex(),\n              R8: projectBox.additionalRegisters.R8,\n              R9: projectBox.additionalRegisters.R9,\n            }),\n          // Output 1: Owner receives unsold PFT (contract checks OUTPUTS(1))\n          new OutputBuilder(RECOMMENDED_MIN_FEE_VALUE, ctx.projectOwner.address).addTokens([\n            { tokenId: ctx.pftTokenId, amount: tokensToWithdraw }, // Owner gets 50k PFT\n          ]),\n        ])\n        .sendChangeTo(ctx.projectOwner.address)\n        .payFee(RECOMMENDED_MIN_FEE_VALUE)\n        .build();\n\n      // Execute transaction (contract validates owner authorization)\n      const result = ctx.mockChain.execute(transaction, { signers: [ctx.projectOwner], throw: false });\n\n      // ASSERT: Verify withdrawal failed\n      expect(result).toBe(false); // Transaction fails\n    });\n\n    it(\"should fail due to failed owner authentication\", () => {\n      // ARRANGE: Owner wants to withdraw 50k unsold PFT tokens\n      const tokensToWithdraw = 50_000n; // Withdraw 50k\n      const remainingPFT = ctx.totalPFTokens - tokensToWithdraw; // 50k will remain in contract\n\n      console.log(\"\\nðŸ¦ WITHDRAW UNSOLD TOKENS:\");\n      console.log(`   Tokens Sold:       10,000 (from beforeEach)`);\n      console.log(`   Tokens Available:  90,000 (100k - 10k sold)`);\n      console.log(`   Tokens to Withdraw: ${tokensToWithdraw.toLocaleString()} PFT`);\n      console.log(`   PFT Remaining:     ${remainingPFT.toLocaleString()}`);\n\n      // Fund project owner for transaction (contract validates INPUTS(1) is owner)\n      ctx.projectOwner.addBalance({ nanoergs: 10_000_000_000n }); // 10 ERG for fees\n\n      const assets = [\n        { tokenId: ctx.projectNftId, amount: 1n + ctx.totalPFTokens - soldTokens },\n        { tokenId: ctx.pftTokenId, amount: remainingPFT }, // Add updated PFT amount\n      ];\n      if (!ctx.isErgMode) {\n        assets.push({ tokenId: ctx.baseTokenId, amount: collectedFunds })\n      }\n\n      // ACT: Build token withdrawal transaction\n      const transaction = new TransactionBuilder(ctx.mockChain.height)\n        // INPUTS: Contract box + owner box (contract checks INPUTS(1) for authorization)\n        .from([projectBox, ...ctx.projectOwner.utxos.toArray()]) // INPUTS(0)=contract, INPUTS(1)=owner\n        // OUTPUTS:\n        .to([\n          // Output 0: Updated contract (fewer PFT tokens)\n          // Value and collected funds (ERG or USD token) are unchanged\n          new OutputBuilder(projectBox.value, ctx.beneErgoTree)\n            .addTokens(assets)\n            .setAdditionalRegisters({\n              R4: projectBox.additionalRegisters.R4,\n              R5: SLong(ctx.minimumTokensSold).toHex(),\n              R6: SColl(SLong, [10_000n, 0n, 0n]).toHex(), // Counters unchanged\n              R7: SLong(ctx.exchangeRate).toHex(),\n              R8: projectBox.additionalRegisters.R8,\n              R9: projectBox.additionalRegisters.R9,\n            }),\n          // Output 1: Owner receives unsold PFT (contract checks OUTPUTS(1))\n          new OutputBuilder(RECOMMENDED_MIN_FEE_VALUE, ctx.projectOwner.address).addTokens([\n            { tokenId: ctx.pftTokenId, amount: tokensToWithdraw }, // Owner gets 50k PFT\n          ]),\n        ])\n        .sendChangeTo(ctx.projectOwner.address)\n        .payFee(RECOMMENDED_MIN_FEE_VALUE)\n        .build();\n\n      // Execute transaction (contract validates owner authorization)\n      const result = ctx.mockChain.execute(transaction, { signers: [ctx.buyer], throw: false });  // Tries to sign another key\n\n\n      expect(result).toBe(false);\n    });\n  });\n\n  describe(\"Withdraw unsold tokens with all sold APT changed per PFTs \", () => {\n    let ctx: BeneTestContext;\n    let projectBox: Box; // Contract box\n    let soldTokens: bigint\n\n    beforeEach(() => {\n      ctx = setupBeneTestContext(mode.token, mode.tokenName);\n\n      // STEP 1: Create project box with partial token sales\n      soldTokens = ctx.totalPFTokens / 2n; // Half of the total PFTs has been sold.\n      const collectedFunds = soldTokens * ctx.exchangeRate;\n\n      let assets = [\n        { tokenId: ctx.projectNftId, amount: 1n + ctx.totalPFTokens - soldTokens },\n        { tokenId: ctx.pftTokenId, amount: ctx.totalPFTokens }, // 100k PFT total\n      ];\n\n      let value = RECOMMENDED_MIN_FEE_VALUE;\n\n      // Handle collected funds based on mode\n      if (!ctx.isErgMode) {\n        // USD Mode: Add funds as a token\n        assets.push({ tokenId: ctx.baseTokenId, amount: collectedFunds });\n      } else {\n        // ERG Mode: Add funds to the box value\n        value += collectedFunds;\n      }\n\n      ctx.beneContract.addUTxOs({\n        value: value,\n        ergoTree: ctx.beneErgoTree.toHex(),\n        assets: assets,\n        creationHeight: ctx.mockChain.height - 100,\n        additionalRegisters: {\n          R4: createR4(ctx),\n          R5: SLong(ctx.minimumTokensSold).toHex(),\n          R6: SColl(SLong, [soldTokens, 0n, soldTokens]).toHex(),\n          R7: SLong(ctx.exchangeRate).toHex(),\n          R8: ctx.constants.toHex(),\n          R9: SColl(SByte, stringToBytes(\"utf8\", \"{}\")).toHex(),\n        },\n      });\n\n      // STEP 2: Get reference to project box\n      projectBox = ctx.beneContract.utxos.toArray()[0];\n    });\n\n    it(\"should allow fully withdrawing unsold PFT tokens\", () => {\n\n      // ARRANGE: Owner wants to withdraw all the unsold PFT tokens\n      const tokensToWithdraw = ctx.totalPFTokens - soldTokens;\n\n      // Fund project owner for transaction (contract validates INPUTS(1) is owner)\n      ctx.projectOwner.addBalance({ nanoergs: 10_000_000_000n }); // 10 ERG for fees\n\n      // ACT: Build token withdrawal transaction\n      const transaction = new TransactionBuilder(ctx.mockChain.height)\n        // INPUTS: Contract box + owner box (contract checks INPUTS(1) for authorization)\n        .from([projectBox, ...ctx.projectOwner.utxos.toArray()]) // INPUTS(0)=contract, INPUTS(1)=owner\n        // OUTPUTS:\n        .to([\n          // Output 0: Owner receives unsold PFT (contract checks OUTPUTS(1))\n          new OutputBuilder(RECOMMENDED_MIN_FEE_VALUE, ctx.projectOwner.address).addTokens([\n            { tokenId: ctx.pftTokenId, amount: tokensToWithdraw },\n          ]),\n        ])\n        .sendChangeTo(ctx.projectOwner.address)\n        .payFee(RECOMMENDED_MIN_FEE_VALUE)\n        .build();\n\n      // Execute transaction (contract validates owner authorization)\n      const result = ctx.mockChain.execute(transaction, { signers: [ctx.projectOwner] });\n\n\n      expect(result).toBe(true); // Transaction valid\n      expect(ctx.beneContract.utxos.length).toEqual(0);\n    });\n  });\n\n  describe(\"Withdraw unsold tokens with all sold APT changed per PFTs after minimum raised and some APT refunded before minimum raised\", () => {\n    let ctx: BeneTestContext;\n    let projectBox: Box; // Contract box\n    let soldTokens: bigint\n\n    beforeEach(() => {\n      ctx = setupBeneTestContext(mode.token, mode.tokenName);\n\n      // STEP 1: Create project box with partial token sales\n      soldTokens = ctx.totalPFTokens / 2n; // Half of the total PFTs has been sold. (Adquired APTs)\n      const refundedTokens = soldTokens / 2n; // Half of the APTs where refunded from their funds. \n      const exchangedTokens = soldTokens - refundedTokens; // The rest of the APTs where exchanged per PFTs\n      const collectedFunds = exchangedTokens * ctx.exchangeRate;  // Exchanged funds can be retired, but not the refunded funds.\n\n      let assets = [\n        { tokenId: ctx.projectNftId, amount: 1n + ctx.totalPFTokens - soldTokens },\n        { tokenId: ctx.pftTokenId, amount: ctx.totalPFTokens }, // 100k PFT total\n      ];\n\n      let value = RECOMMENDED_MIN_FEE_VALUE;\n\n      // Handle collected funds based on mode\n      if (!ctx.isErgMode) {\n        // USD Mode: Add funds as a token\n        assets.push({ tokenId: ctx.baseTokenId, amount: collectedFunds });\n      } else {\n        // ERG Mode: Add funds to the box value\n        value += collectedFunds;\n      }\n\n      ctx.beneContract.addUTxOs({\n        value: value,\n        ergoTree: ctx.beneErgoTree.toHex(),\n        assets: assets,\n        creationHeight: ctx.mockChain.height - 100,\n        additionalRegisters: {\n          R4: createR4(ctx),\n          R5: SLong(ctx.minimumTokensSold).toHex(),\n          R6: SColl(SLong, [soldTokens, refundedTokens, exchangedTokens]).toHex(),\n          R7: SLong(ctx.exchangeRate).toHex(),\n          R8: ctx.constants.toHex(),\n          R9: SColl(SByte, stringToBytes(\"utf8\", \"{}\")).toHex(),\n        },\n      });\n\n      // STEP 2: Get reference to project box\n      projectBox = ctx.beneContract.utxos.toArray()[0];\n    });\n\n    it(\"should allow fully withdrawing unsold PFT tokens\", () => {\n\n      // ARRANGE: Owner wants to withdraw all the unsold PFT tokens\n      const tokensToWithdraw = ctx.totalPFTokens - soldTokens;\n\n      // Fund project owner for transaction (contract validates INPUTS(1) is owner)\n      ctx.projectOwner.addBalance({ nanoergs: 10_000_000_000n }); // 10 ERG for fees\n\n      // ACT: Build token withdrawal transaction\n      const transaction = new TransactionBuilder(ctx.mockChain.height)\n        // INPUTS: Contract box + owner box (contract checks INPUTS(1) for authorization)\n        .from([projectBox, ...ctx.projectOwner.utxos.toArray()]) // INPUTS(0)=contract, INPUTS(1)=owner\n        // OUTPUTS:\n        .to([\n          // Output 0: Owner receives unsold PFT (contract checks OUTPUTS(1))\n          new OutputBuilder(RECOMMENDED_MIN_FEE_VALUE, ctx.projectOwner.address).addTokens([\n            { tokenId: ctx.pftTokenId, amount: tokensToWithdraw },\n          ]),\n        ])\n        .sendChangeTo(ctx.projectOwner.address)\n        .payFee(RECOMMENDED_MIN_FEE_VALUE)\n        .build();\n\n      // Execute transaction (contract validates owner authorization)\n      const result = ctx.mockChain.execute(transaction, { signers: [ctx.projectOwner] });\n\n\n      expect(result).toBe(true); // Transaction valid\n      expect(ctx.beneContract.utxos.length).toEqual(0);\n    });\n  });\n\n  describe(\"Withdraw unsold tokens with complex owner script authorization\", () => {\n    let ctx: BeneTestContext;\n    let projectBox: Box; // Contract box\n    let soldTokens: bigint\n    let ownerContract: ErgoTree;\n\n    beforeEach(() => {\n      ownerContract = compile(`{ sigmaProp(HEIGHT > 1) }`);\n\n      ctx = setupBeneTestContext(mode.token, mode.tokenName, ownerContract.toAddress());\n\n      // STEP 1: Create project box with partial token sales\n      soldTokens = ctx.totalPFTokens / 2n; // Half of the total PFTs has been sold.\n      const collectedFunds = soldTokens * ctx.exchangeRate;\n\n      let assets = [\n        { tokenId: ctx.projectNftId, amount: 1n + ctx.totalPFTokens - soldTokens },\n        { tokenId: ctx.pftTokenId, amount: ctx.totalPFTokens }, // 100k PFT total\n      ];\n\n      let value = RECOMMENDED_MIN_FEE_VALUE;\n\n      // Handle collected funds based on mode\n      if (!ctx.isErgMode) {\n        // USD Mode: Add funds as a token\n        assets.push({ tokenId: ctx.baseTokenId, amount: collectedFunds });\n      } else {\n        // ERG Mode: Add funds to the box value\n        value += collectedFunds;\n      }\n\n      ctx.beneContract.addUTxOs({\n        value: value,\n        ergoTree: ctx.beneErgoTree.toHex(),\n        assets: assets,\n        creationHeight: ctx.mockChain.height - 100,\n        additionalRegisters: {\n          R4: createR4(ctx),\n          R5: SLong(ctx.minimumTokensSold).toHex(),\n          R6: SColl(SLong, [soldTokens, 0n, soldTokens]).toHex(),\n          R7: SLong(ctx.exchangeRate).toHex(),\n          R8: ctx.constants.toHex(),\n          R9: SColl(SByte, stringToBytes(\"utf8\", \"{}\")).toHex(),\n        },\n      });\n\n      // STEP 2: Get reference to project box\n      projectBox = ctx.beneContract.utxos.toArray()[0];\n    });\n\n    it(\"should allow fully withdrawing unsold PFT tokens\", () => {\n\n      const customOwnerContract = ctx.mockChain.addParty(ownerContract.toAddress().ergoTree, `Custom owner contract`);\n      customOwnerContract.addUTxOs({\n        value: RECOMMENDED_MIN_FEE_VALUE,\n        ergoTree: ownerContract.toAddress().ergoTree,\n        creationHeight: ctx.mockChain.height - 100,\n        assets: [],\n        additionalRegisters: {}\n      })\n      const ownerScriptBox = customOwnerContract.utxos.toArray()[0]; // TODO CHECK - This box is omitted by the transaction in ERG case.\n\n      // ARRANGE: Owner wants to withdraw all the unsold PFT tokens\n      const tokensToWithdraw = ctx.totalPFTokens - soldTokens;\n\n      // Fund project owner for transaction (contract validates INPUTS(1) is owner)\n      ctx.projectOwner.addBalance({ nanoergs: 10_000_000_000n }); // 10 ERG for fees\n\n      // ACT: Build token withdrawal transaction\n      const transaction = new TransactionBuilder(ctx.mockChain.height)\n        // INPUTS: Contract box + owner box (contract checks INPUTS(1) for authorization)\n        .from([projectBox, ownerScriptBox, ...ctx.projectOwner.utxos.toArray()]) // INPUTS(0)=contract, INPUTS(1)=owner\n        // OUTPUTS:\n        .to([\n          // Output 0: Owner receives unsold PFT (contract checks OUTPUTS(1))\n          new OutputBuilder(RECOMMENDED_MIN_FEE_VALUE, ctx.projectOwner.address).addTokens([\n            { tokenId: ctx.pftTokenId, amount: tokensToWithdraw },\n          ]),\n        ])\n        .sendChangeTo(ctx.projectOwner.address)\n        .payFee(RECOMMENDED_MIN_FEE_VALUE)\n        .build();\n\n      // Execute transaction (contract validates owner authorization)\n      const result = ctx.mockChain.execute(transaction, { signers: [ctx.projectOwner] });\n\n\n      expect(result).toBe(true); // Transaction valid\n      expect(ctx.beneContract.utxos.length).toEqual(0);\n    });\n\n    it(\"should fail due to failed owner authentication\", () => {\n\n      // ARRANGE: Owner wants to withdraw all the unsold PFT tokens\n      const tokensToWithdraw = ctx.totalPFTokens - soldTokens;\n\n      // Fund project owner for transaction (contract validates INPUTS(1) is owner)\n      ctx.projectOwner.addBalance({ nanoergs: 10_000_000_000n }); // 10 ERG for fees\n\n      // ACT: Build token withdrawal transaction\n      const transaction = new TransactionBuilder(ctx.mockChain.height)\n        // INPUTS: Contract box + owner box (contract checks INPUTS(1) for authorization)\n        .from([projectBox, ...ctx.projectOwner.utxos.toArray()]) // INPUTS(0)=contract, INPUTS(1)=owner\n        // OUTPUTS:\n        .to([\n          // Output 0: Owner receives unsold PFT (contract checks OUTPUTS(1))\n          new OutputBuilder(RECOMMENDED_MIN_FEE_VALUE, ctx.projectOwner.address).addTokens([\n            { tokenId: ctx.pftTokenId, amount: tokensToWithdraw },\n          ]),\n        ])\n        .sendChangeTo(ctx.projectOwner.address)\n        .payFee(RECOMMENDED_MIN_FEE_VALUE)\n        .build();\n\n      // Execute transaction (contract validates owner authorization)\n      const result = ctx.mockChain.execute(transaction, { signers: [ctx.projectOwner], throw: false });\n\n\n      expect(result).toBe(false);\n    });\n  });\n\n});","path":null,"size_bytes":23867,"size_tokens":null},"src/lib/components/ui/card/index.ts":{"content":"import Root from \"./card.svelte\";\nimport Content from \"./card-content.svelte\";\nimport Description from \"./card-description.svelte\";\nimport Footer from \"./card-footer.svelte\";\nimport Header from \"./card-header.svelte\";\nimport Title from \"./card-title.svelte\";\n\nexport {\n\tRoot,\n\tContent,\n\tDescription,\n\tFooter,\n\tHeader,\n\tTitle,\n\t//\n\tRoot as Card,\n\tContent as CardContent,\n\tDescription as CardDescription,\n\tFooter as CardFooter,\n\tHeader as CardHeader,\n\tTitle as CardTitle,\n};\n\nexport type HeadingLevel = \"h1\" | \"h2\" | \"h3\" | \"h4\" | \"h5\" | \"h6\";\n","path":null,"size_bytes":542,"size_tokens":null},"src/lib/ergo/platform.ts":{"content":"// src/ergo/platform.ts\nimport type { Platform } from '../common/platform';\nimport type { Project } from '../common/project';\nimport { submit_project } from './actions/submit';\nimport { withdraw } from './actions/withdraw';\nimport { buy_refund } from './actions/buy_refund';\nimport { rebalance } from './actions/rebalance';\nimport { balance, explorer_uri } from \"../common/store\";\nimport { walletManager, walletConnected, walletAddress } from \"../wallet/wallet-manager\";\nimport { get } from \"svelte/store\";\nimport { temp_exchange } from './actions/temp_exchange';\nimport { type contract_version } from './contract';\n\nexport class ErgoPlatform implements Platform {\n\n    id = \"ergo\";\n    main_token = \"ERG\";\n    icon = \"\";\n    time_per_block = 2 * 60 * 1000;  // every 2 minutes\n    last_version: contract_version = \"v2\";\n\n    async connect(): Promise<void> {\n        // This method is now deprecated - wallet connection is handled by WalletManager\n        // Check if already connected via new wallet system\n        const isConnected = get(walletConnected);\n        if (isConnected) {\n            console.log('Already connected via new wallet system');\n            return;\n        }\n\n        console.warn('ErgoPlatform.connect() is deprecated. Use WalletManager instead.');\n        // For backward compatibility, try to connect to Nautilus if available\n        try {\n            await walletManager.connectWallet('nautilus');\n        } catch (error) {\n            console.error('Failed to connect via WalletManager:', error);\n        }\n    }\n\n    async get_current_height(): Promise<number> {\n        try {\n            // Check if wallet manager is available and connected\n            if (walletManager && walletManager.isConnected()) {\n                // Use wallet adapter's getCurrentHeight method which handles SafeW correctly\n                const adapter = walletManager.getConnectedWallet();\n                if (adapter && adapter.getCurrentHeight) {\n                    return await adapter.getCurrentHeight();\n                }\n            }\n\n            // Try direct window.ergo if available (for legacy compatibility with Nautilus)\n            if (typeof window !== 'undefined' && window.ergo && window.ergo.get_current_height) {\n                return await window.ergo.get_current_height();\n            }\n        } catch (error) {\n            console.warn('Failed to get height from wallet, falling back to API:', error);\n        }\n\n        // Fallback to fetching the current height from the Ergo API\n        try {\n            const response = await fetch(get(explorer_uri) + '/api/v1/networkState');\n            if (!response.ok) {\n                throw new Error(`API request failed with status: ${response.status}`);\n            }\n\n            const data = await response.json();\n            return data.height; // Extract and return the height\n        } catch (error) {\n            console.error(\"Failed to fetch network height from API:\", error);\n            throw new Error(\"Unable to get current height.\");\n        }\n    }\n\n    async get_balance(id?: string): Promise<Map<string, number>> {\n        const balanceMap = new Map<string, number>();\n\n        // Get address from new wallet system or fallback to ergo global\n        let addr: string | null = null;\n        try {\n            const walletAddr = get(walletAddress);\n            if (walletAddr) {\n                addr = walletAddr;\n            } else if (typeof window !== 'undefined' && window.ergo) {\n                addr = await window.ergo.get_change_address();\n            }\n        } catch (error) {\n            console.error('Failed to get wallet address:', error);\n        }\n\n        if (addr) {\n            try {\n                // Fetch balance for the specific address from the API\n                const response = await fetch(get(explorer_uri) + `/api/v1/addresses/${addr}/balance/confirmed`);\n                if (!response.ok) {\n                    throw new Error(`API request failed with status: ${response.status}`);\n                }\n\n                const data = await response.json();\n\n                // Add nanoErgs balance to the map\n                balanceMap.set(\"ERG\", data.nanoErgs);\n                balance.set(data.nanoErgs)\n\n                // Add tokens balances to the map\n                data.tokens.forEach((token: { tokenId: string; amount: number }) => {\n                    balanceMap.set(token.tokenId, token.amount);\n                });\n            } catch (error) {\n                console.error(`Failed to fetch balance for address ${addr} from API:`, error);\n                throw new Error(\"Unable to fetch balance.\");\n            }\n        } else {\n            throw new Error(\"Address is required to fetch balance.\");\n        }\n\n        return balanceMap;\n    }\n\n    async buy_refund(project: Project, token_amount: number): Promise<string | null> {\n        return await buy_refund(project, token_amount);\n    }\n\n    async rebalance(project: Project, token_amount: number): Promise<string | null> {\n        return await rebalance(project, token_amount);\n    }\n\n    async *submit(\n        version: contract_version,\n        token_id: string,\n        token_amount: number,\n        blockLimit: number,\n        is_timestamp_limit: boolean,\n        exchangeRate: number,\n        projectContent: string,\n        minimumSold: number,\n        title: string,\n        base_token_id: string = \"\",\n        owner_ergotree: string = \"\"\n    ): AsyncGenerator<string, string | null, void> {\n        return yield* submit_project(\n            version,\n            token_id,\n            token_amount,\n            blockLimit,\n            is_timestamp_limit,\n            exchangeRate,\n            projectContent,\n            minimumSold,\n            title,\n            base_token_id,\n            owner_ergotree\n        );\n    }\n\n    async withdraw(project: Project, amount: number): Promise<string | null> {\n        return await withdraw(project, amount);\n    }\n\n    async temp_exchange(project: Project, token_amount: number): Promise<string | null> {\n        return await temp_exchange(project, token_amount);\n    }\n\n    async fetch(offset: number = 0): Promise<Map<string, Project>> {\n        return await new Map();\n    }\n}","path":null,"size_bytes":6229,"size_tokens":null},"src/lib/components/ui/button/index.ts":{"content":"import { type VariantProps, tv } from \"tailwind-variants\";\nimport type { Button as ButtonPrimitive } from \"bits-ui\";\nimport Root from \"./button.svelte\";\n\nconst buttonVariants = tv({\n\tbase: \"ring-offset-background focus-visible:ring-ring inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50\",\n\tvariants: {\n\t\tvariant: {\n\t\t\tdefault: \"bg-primary text-primary-foreground hover:bg-primary/90\",\n\t\t\tdestructive: \"bg-destructive text-destructive-foreground hover:bg-destructive/90\",\n\t\t\toutline:\n\t\t\t\t\"border-input bg-background hover:bg-accent hover:text-accent-foreground border\",\n\t\t\tsecondary: \"bg-secondary text-secondary-foreground hover:bg-secondary/80\",\n\t\t\tghost: \"hover:bg-accent hover:text-accent-foreground\",\n\t\t\tlink: \"text-primary underline-offset-4 hover:underline\",\n\t\t},\n\t\tsize: {\n\t\t\tdefault: \"h-10 px-4 py-2\",\n\t\t\tsm: \"h-9 rounded-md px-3\",\n\t\t\tlg: \"h-11 rounded-md px-8\",\n\t\t\ticon: \"h-10 w-10\",\n\t\t},\n\t},\n\tdefaultVariants: {\n\t\tvariant: \"default\",\n\t\tsize: \"default\",\n\t},\n});\n\ntype Variant = VariantProps<typeof buttonVariants>[\"variant\"];\ntype Size = VariantProps<typeof buttonVariants>[\"size\"];\n\ntype Props = ButtonPrimitive.Props & {\n\tvariant?: Variant;\n\tsize?: Size;\n};\n\ntype Events = ButtonPrimitive.Events;\n\nexport {\n\tRoot,\n\ttype Props,\n\ttype Events,\n\t//\n\tRoot as Button,\n\ttype Props as ButtonProps,\n\ttype Events as ButtonEvents,\n\tbuttonVariants,\n};\n","path":null,"size_bytes":1533,"size_tokens":null},"tests/contracts/refund_tokens.test.ts":{"content":"// ===== TEST FILE: Refund APT Tokens =====\n// Tests the refund mechanism where buyers can get their payment back\n// Refunds are ONLY allowed when: (1) Past deadline AND (2) Minimum NOT reached\n// Verifies refund counter updates and payment returns\n\nimport { describe, it, expect, beforeEach } from \"vitest\";\nimport { Box, OutputBuilder, TransactionBuilder, RECOMMENDED_MIN_FEE_VALUE } from \"@fleet-sdk/core\";\nimport { SByte, SColl, SInt, SLong, SBool, SPair } from \"@fleet-sdk/serializer\";\nimport { stringToBytes } from \"@scure/base\";\nimport { setupBeneTestContext, ERG_BASE_TOKEN, ERG_BASE_TOKEN_NAME, type BeneTestContext, USD_BASE_TOKEN_NAME, USD_BASE_TOKEN, createR4 } from \"./bene_contract_helpers\";\n\n// EXECUTION FLOW:\n// 1. beforeEach() â†’ Creates blockchain + project box with MINIMUM NOT REACHED (25k sold < 50k minimum)\n// 2. Give buyer 5k APT tokens to refund\n// 3. Test jumps past deadline, then builds refund transaction\n// 4. Contract validates: deadline passed + minimum not reached + correct refund amount\n\nconst baseModes = [\n  { name: \"USD Token Mode\", token: USD_BASE_TOKEN, tokenName: USD_BASE_TOKEN_NAME },\n  { name: \"ERG Mode\", token: ERG_BASE_TOKEN, tokenName: ERG_BASE_TOKEN_NAME },\n];\n\nconst timeModes = [\n  { name: \"Block Height\", useTimestamp: false },\n  { name: \"Timestamp\", useTimestamp: true },\n];\n\nconst testModes = baseModes.flatMap(base =>\n  timeModes.map(time => ({ ...base, ...time, fullName: `${base.name} - ${time.name}` }))\n);\n\ndescribe.each(testModes)(\"Bene Contract v1.2 - Refund APT Tokens (%s)\", (mode) => {\n  let ctx: BeneTestContext;  // Test environment\n  let projectBox: Box;       // Contract box\n\n  // SETUP: Runs before each test\n  beforeEach(() => {\n    // STEP 1: Initialize test context with BASE_TOKEN (see bene_contract_helpers.ts to change)\n    ctx = setupBeneTestContext(mode.token, mode.tokenName);\n\n    // STEP 2: Create project box with MINIMUM NOT REACHED (failed campaign)\n    const soldTokens = ctx.minimumTokensSold / 2n;  // Only 25,000 sold (need 50,000) - FAILED!\n    const collectedPayment = soldTokens * ctx.exchangeRate;  // 25 ERG collected\n\n    // Build contract assets (differs based on ERG vs custom token mode)\n    const contractAssets = [\n      { tokenId: ctx.projectNftId, amount: 1n + ctx.totalPFTokens - soldTokens },  // APT: 1 + 100k - 25k = 75,001\n      { tokenId: ctx.pftTokenId, amount: ctx.totalPFTokens },                      // PFT: 100,000\n    ];\n    // In custom token mode, collected payment is stored as tokens\n    if (!ctx.isErgMode) {\n      contractAssets.push({ tokenId: ctx.baseTokenId, amount: collectedPayment });\n    }\n\n    ctx.beneContract.addUTxOs({\n      // In ERG mode: store payment as ERG value; In token mode: only minimum ERG\n      value: ctx.isErgMode ? RECOMMENDED_MIN_FEE_VALUE + collectedPayment : RECOMMENDED_MIN_FEE_VALUE,\n      ergoTree: ctx.beneErgoTree.toHex(),\n      assets: contractAssets,\n      creationHeight: ctx.mockChain.height - 100,  // Created 100 blocks ago\n      additionalRegisters: {\n        R4: createR4(ctx, mode.useTimestamp),\n        R5: SLong(ctx.minimumTokensSold).toHex(),                          // Minimum: 50,000\n        R6: SColl(SLong, [soldTokens, 0n, 0n]).toHex(),                    // [25k sold, 0 refunded, 0 exchanged]\n        R7: SLong(ctx.exchangeRate).toHex(),  // [price, token_len]\n        R8: ctx.constants.toHex(),\n        R9: SColl(SByte, stringToBytes(\"utf8\", \"{}\")).toHex(),\n      },\n    });\n\n    // STEP 3: Give buyer APT tokens to refund (from previous purchase)\n    const tokensToRefund = 5_000n;\n    ctx.buyer.addUTxOs({\n      value: 10_000_000_000n,                                     // 10 ERG for transaction fees\n      ergoTree: ctx.buyer.address.ergoTree,\n      assets: [{ tokenId: ctx.projectNftId, amount: tokensToRefund }],  // Buyer has 5,000 APT to refund\n      creationHeight: ctx.mockChain.height - 50,                  // Acquired 50 blocks ago\n      additionalRegisters: {},\n    });\n\n    // STEP 4: Get reference to project box\n    projectBox = ctx.beneContract.utxos.toArray()[0];\n  });\n\n  it(\"should allow refunding APT tokens after deadline when minimum not reached\", () => {\n    // ARRANGE: Jump blockchain PAST the deadline\n    ctx.mockChain.jumpTo(ctx.deadlineBlock + 2);  // Move to block 800,202 (past 800,200 deadline)\n\n    // Find buyer's box with APT tokens\n    const buyerTokenBox = ctx.buyer.utxos\n      .toArray()\n      .find((box) => box.assets.some((asset) => asset.tokenId === ctx.projectNftId))!;\n    const tokensToRefund = buyerTokenBox.assets[0].amount;  // 5,000 APT\n    const refundAmount = tokensToRefund * ctx.exchangeRate;  // 5 ERG to refund\n\n    const soldTokens = ctx.minimumTokensSold / 2n;                    // 25,000 (from beforeEach)\n    const newAPTAmount = BigInt(projectBox.assets[0].amount) + tokensToRefund;  // Contract gains: 75,001 + 5k = 80,001 APT\n\n    const decimalDivisor = 10 ** ctx.baseTokenDecimals;\n    console.log(\"\\nREFUND TRANSACTION:\");\n    console.log(`   APT to Refund:     ${tokensToRefund.toLocaleString()}`);\n    console.log(`   Refund Amount:     ${Number(refundAmount) / decimalDivisor} ${ctx.baseTokenName}`);\n    console.log(`   Campaign Failed?   YES (${soldTokens.toLocaleString()} < ${ctx.minimumTokensSold.toLocaleString()})`);\n    console.log(`   Past Deadline?     YES (block ${ctx.mockChain.height} > ${ctx.deadlineBlock})`);\n    console.log(`   Past Deadline timeline? YES (time ${ctx.mockChain.timestamp} > ${ctx.deadlineTimestamp})`);\n    console.log(`   Refund Counter:    0 â†’ ${tokensToRefund.toLocaleString()}`);\n\n    // LOG: Show buyer state before refund\n    console.log(`   BUYER STATE BEFORE:`);\n    const buyerAPTBefore = buyerTokenBox.assets[0].amount;\n    const buyerPFTBefore = ctx.buyer.utxos.toArray()\n      .find((box) => box.assets.some((asset) => asset.tokenId === ctx.pftTokenId))?.assets[0]?.amount || 0n;\n    console.log(`      APT Balance:     ${buyerAPTBefore.toLocaleString()}`);\n    console.log(`      PFT Balance:     ${buyerPFTBefore.toLocaleString()}`);\n    console.log(`      ERG Balance:     ${Number(ctx.buyer.balance.nanoergs) / 1_000_000_000} ERG`);\n\n    // Build updated contract token list\n    const contractAssets = [\n      { tokenId: ctx.projectNftId, amount: newAPTAmount },        // APT: 80,001 (gained 5k back)\n      { tokenId: ctx.pftTokenId, amount: ctx.totalPFTokens },     // PFT: 100,000 (unchanged)\n    ];\n    if (!ctx.isErgMode) {\n      // In custom token mode, contract loses payment tokens\n      const currentBaseTokens = BigInt(projectBox.assets.find(a => a.tokenId === ctx.baseTokenId)!.amount);\n      contractAssets.push({ tokenId: ctx.baseTokenId, amount: currentBaseTokens - refundAmount });\n    }\n\n    // Build buyer's refund output (ERG or custom tokens)\n    const refundOutputBuilder = ctx.isErgMode\n      ? new OutputBuilder(refundAmount, ctx.buyer.address)  // In ERG mode: buyer gets 5 ERG back\n      : new OutputBuilder(RECOMMENDED_MIN_FEE_VALUE, ctx.buyer.address).addTokens([  // In token mode: payment tokens\n        { tokenId: ctx.baseTokenId, amount: refundAmount },\n      ]);\n\n    // ACT: Build and execute refund transaction\n    const transaction = new TransactionBuilder(ctx.mockChain.height)\n      // INPUTS: Contract box + buyer's APT box\n      .from([projectBox, buyerTokenBox])\n\n      // OUTPUTS:\n      .to([\n        // Output 0: Updated contract (gains APT back, loses payment)\n        new OutputBuilder(\n          ctx.isErgMode ? BigInt(projectBox.value) - refundAmount : projectBox.value,  // Loses 5 ERG\n          ctx.beneErgoTree\n        )\n          .addTokens(contractAssets)\n          .setAdditionalRegisters({\n            R4: projectBox.additionalRegisters.R4,\n            R5: SLong(ctx.minimumTokensSold).toHex(),\n            R6: SColl(SLong, [soldTokens, tokensToRefund, 0n]).toHex(),  // [25k sold, 5k refunded, 0 exchanged]\n            R7: SLong(ctx.exchangeRate).toHex(),\n            R8: projectBox.additionalRegisters.R8,\n            R9: projectBox.additionalRegisters.R9,\n          }),\n        // Output 1: Buyer receives payment refund\n        refundOutputBuilder,\n      ])\n      .sendChangeTo(ctx.buyer.address)\n      .payFee(RECOMMENDED_MIN_FEE_VALUE)\n      .build();\n\n    // Execute transaction (contract validates: deadline passed + minimum not reached)\n    const result = ctx.mockChain.execute(transaction, { signers: [ctx.buyer] });\n\n    // ASSERT: Verify refund succeeded\n    expect(result).toBe(true);                          // Transaction valid\n    expect(ctx.beneContract.utxos.length).toEqual(1);   // Contract still has 1 box\n\n    const updatedBox = ctx.beneContract.utxos.toArray()[0];\n    expect(updatedBox.assets[0].amount).toEqual(newAPTAmount);  // Contract has 80,001 APT\n\n    // LOG: Show buyer state after refund\n    console.log(`   BUYER STATE AFTER:`);\n    const buyerAPTAfter = ctx.buyer.utxos.toArray()\n      .find((box) => box.assets.some((asset) => asset.tokenId === ctx.projectNftId))?.assets[0]?.amount || 0n;\n    const buyerPFTAfter = ctx.buyer.utxos.toArray()\n      .find((box) => box.assets.some((asset) => asset.tokenId === ctx.pftTokenId))?.assets[0]?.amount || 0n;\n    console.log(`      APT Balance:     ${buyerAPTAfter.toLocaleString()}`);\n    console.log(`      PFT Balance:     ${buyerPFTAfter.toLocaleString()}`);\n    console.log(`      ERG Balance:     ${Number(ctx.buyer.balance.nanoergs) / 1_000_000_000} ERG`);\n\n    // LOG: Show final state after refund\n    console.log(`   CONTRACT STATE AFTER:`);\n    console.log(`      APT Balance:     ${updatedBox.assets[0].amount.toLocaleString()}`);\n    console.log(`      PFT Balance:     ${updatedBox.assets[1].amount.toLocaleString()}`);\n    if (ctx.isErgMode) {\n      console.log(`      ERG Balance:     ${Number(updatedBox.value) / 1_000_000_000} ERG`);\n    } else {\n      const baseTokenAsset = updatedBox.assets.find((a) => a.tokenId === ctx.baseTokenId);\n      if (baseTokenAsset) {\n        console.log(`      ${ctx.baseTokenName} Balance: ${Number(baseTokenAsset.amount) / decimalDivisor} ${ctx.baseTokenName}`);\n      }\n    }\n    console.log(`      Sold Counter:    ${soldTokens} tokens`);\n    console.log(`      Refund Counter:  ${tokensToRefund} tokens`);\n    console.log(`   Refund successful!`);\n  });\n\n  it(\"should allow multiple sequential refunds and update refund counter cumulatively\", () => {\n    // ARRANGE: Give buyer an additional APT box so we can refund in two separate txs\n    const secondTokens = 3_000n;\n    ctx.buyer.addUTxOs({\n      value: 5_000_000_000n,\n      ergoTree: ctx.buyer.address.ergoTree,\n      assets: [{ tokenId: ctx.projectNftId, amount: secondTokens }],\n      creationHeight: ctx.mockChain.height - 40,\n      additionalRegisters: {},\n    });\n\n    // Jump past deadline\n    ctx.mockChain.jumpTo(ctx.deadlineBlock + 2);\n\n    // First refund uses original box (5,000)\n    const firstBox = ctx.buyer.utxos\n      .toArray()\n      .find((box) => box.assets.some((asset) => asset.tokenId === ctx.projectNftId && asset.amount === 5_000n))!;\n    const firstRefundTokens = firstBox.assets[0].amount;\n    const firstRefundAmount = firstRefundTokens * ctx.exchangeRate;\n\n    // Build and execute first refund tx\n    let soldTokens = ctx.minimumTokensSold / 2n;\n    let contractAfterFirstAssets = [\n      { tokenId: ctx.projectNftId, amount: BigInt(projectBox.assets[0].amount) + firstRefundTokens },\n      { tokenId: ctx.pftTokenId, amount: ctx.totalPFTokens },\n    ];\n    if (!ctx.isErgMode) {\n      const currentBaseTokens = BigInt(projectBox.assets.find(a => a.tokenId === ctx.baseTokenId)!.amount);\n      contractAfterFirstAssets.push({ tokenId: ctx.baseTokenId, amount: currentBaseTokens - firstRefundAmount });\n    }\n\n    const firstTx = new TransactionBuilder(ctx.mockChain.height)\n      .from([projectBox, firstBox])\n      .to([\n        new OutputBuilder(\n          ctx.isErgMode ? BigInt(projectBox.value) - firstRefundAmount : projectBox.value,\n          ctx.beneErgoTree\n        )\n          .addTokens(contractAfterFirstAssets)\n          .setAdditionalRegisters({\n            R4: projectBox.additionalRegisters.R4,\n            R5: SLong(ctx.minimumTokensSold).toHex(),\n            R6: SColl(SLong, [soldTokens, firstRefundTokens, 0n]).toHex(),\n            R7: SLong(ctx.exchangeRate).toHex(),\n            R8: projectBox.additionalRegisters.R8,\n            R9: projectBox.additionalRegisters.R9,\n          }),\n        ctx.isErgMode ? new OutputBuilder(firstRefundAmount, ctx.buyer.address) : new OutputBuilder(RECOMMENDED_MIN_FEE_VALUE, ctx.buyer.address).addTokens([\n          { tokenId: ctx.baseTokenId, amount: firstRefundAmount },\n        ]),\n      ])\n      .sendChangeTo(ctx.buyer.address)\n      .payFee(RECOMMENDED_MIN_FEE_VALUE)\n      .build();\n\n    const res1 = ctx.mockChain.execute(firstTx, { signers: [ctx.buyer] });\n    expect(res1).toBe(true);\n\n    // Prepare for second refund using the updated contract box and the second APT box\n    const updatedContractAfter1 = ctx.beneContract.utxos.toArray()[0];\n    const secondBox = ctx.buyer.utxos\n      .toArray()\n      .find((box) => box.assets.some((asset) => asset.tokenId === ctx.projectNftId && asset.amount === secondTokens))!;\n    const secondRefundTokens = secondBox.assets[0].amount;\n    const secondRefundAmount = secondRefundTokens * ctx.exchangeRate;\n\n    // Compute expected cumulative values\n    const cumulativeRefund = firstRefundTokens + secondRefundTokens;\n    const expectedAPTOnContract = BigInt(projectBox.assets[0].amount) + cumulativeRefund;\n\n    // Build and execute second refund tx\n    const contractAfterSecondAssets = [\n      { tokenId: ctx.projectNftId, amount: expectedAPTOnContract },\n      { tokenId: ctx.pftTokenId, amount: ctx.totalPFTokens },\n    ];\n    if (!ctx.isErgMode) {\n      const currentBaseTokens = BigInt(updatedContractAfter1.assets.find(a => a.tokenId === ctx.baseTokenId)!.amount);\n      contractAfterSecondAssets.push({ tokenId: ctx.baseTokenId, amount: currentBaseTokens - secondRefundAmount });\n    }\n\n    const secondTx = new TransactionBuilder(ctx.mockChain.height)\n      .from([updatedContractAfter1, secondBox])\n      .to([\n        new OutputBuilder(\n          ctx.isErgMode ? BigInt(updatedContractAfter1.value) - secondRefundAmount : updatedContractAfter1.value,\n          ctx.beneErgoTree\n        )\n          .addTokens(contractAfterSecondAssets)\n          .setAdditionalRegisters({\n            R4: projectBox.additionalRegisters.R4,\n            R5: SLong(ctx.minimumTokensSold).toHex(),\n            R6: SColl(SLong, [soldTokens, cumulativeRefund, 0n]).toHex(),\n            R7: SLong(ctx.exchangeRate).toHex(),\n            R8: updatedContractAfter1.additionalRegisters.R8,\n            R9: updatedContractAfter1.additionalRegisters.R9,\n          }),\n        ctx.isErgMode ? new OutputBuilder(secondRefundAmount, ctx.buyer.address) : new OutputBuilder(RECOMMENDED_MIN_FEE_VALUE, ctx.buyer.address).addTokens([\n          { tokenId: ctx.baseTokenId, amount: secondRefundAmount },\n        ]),\n      ])\n      .sendChangeTo(ctx.buyer.address)\n      .payFee(RECOMMENDED_MIN_FEE_VALUE)\n      .build();\n\n    const res2 = ctx.mockChain.execute(secondTx, { signers: [ctx.buyer] });\n    expect(res2).toBe(true);\n\n    // ASSERT final contract and counters\n    const finalContract = ctx.beneContract.utxos.toArray()[0];\n    expect(finalContract.assets[0].amount).toEqual(expectedAPTOnContract); // APT increased by both refunds\n\n    expect(cumulativeRefund).toBeGreaterThan(0n);\n    expect(finalContract.assets[0].amount).toEqual(expectedAPTOnContract);\n  });\n\n  it(\"should fail to refund before deadline\", () => {\n    // ARRANGE: Try to refund BEFORE deadline (should fail)\n    ctx.mockChain.jumpTo(ctx.deadlineBlock - 10);  // Jump to block 800,190 (deadline is 800,200)\n\n    const buyerTokenBox = ctx.buyer.utxos\n      .toArray()\n      .find((box) => box.assets.some((asset) => asset.tokenId === ctx.projectNftId))!;\n    const tokensToRefund = buyerTokenBox.assets[0].amount;\n    const refundAmount = tokensToRefund * ctx.exchangeRate;\n\n    const soldTokens = ctx.minimumTokensSold / 2n;\n    const newAPTAmount = BigInt(projectBox.assets[0].amount) + tokensToRefund;\n\n    // Build contract output based on payment mode\n    const contractAssets = [\n      { tokenId: ctx.projectNftId, amount: newAPTAmount },\n      { tokenId: ctx.pftTokenId, amount: ctx.totalPFTokens },\n    ];\n    if (!ctx.isErgMode) {\n      const currentBaseTokens = BigInt(projectBox.assets.find(a => a.tokenId === ctx.baseTokenId)!.amount);\n      contractAssets.push({ tokenId: ctx.baseTokenId, amount: currentBaseTokens - refundAmount });\n    }\n\n    // Build refund output based on payment mode\n    const refundOutputBuilder = ctx.isErgMode\n      ? new OutputBuilder(refundAmount, ctx.buyer.address)\n      : new OutputBuilder(RECOMMENDED_MIN_FEE_VALUE, ctx.buyer.address).addTokens([\n        { tokenId: ctx.baseTokenId, amount: refundAmount },\n      ]);\n\n    // Act\n    const transaction = new TransactionBuilder(ctx.mockChain.height)\n      .from([projectBox, buyerTokenBox])\n      .to([\n        new OutputBuilder(\n          ctx.isErgMode ? BigInt(projectBox.value) - refundAmount : projectBox.value,\n          ctx.beneErgoTree\n        )\n          .addTokens(contractAssets)\n          .setAdditionalRegisters({\n            R4: projectBox.additionalRegisters.R4,\n            R5: SLong(ctx.minimumTokensSold).toHex(),\n            R6: SColl(SLong, [soldTokens, tokensToRefund, 0n]).toHex(),\n            R7: SLong(ctx.exchangeRate).toHex(),\n            R8: projectBox.additionalRegisters.R8,\n            R9: projectBox.additionalRegisters.R9,\n          }),\n        refundOutputBuilder,\n      ])\n      .sendChangeTo(ctx.buyer.address)\n      .payFee(RECOMMENDED_MIN_FEE_VALUE)\n      .build();\n\n    // Execute with throw: false to capture failure\n    const result = ctx.mockChain.execute(transaction, { signers: [ctx.buyer], throw: false });\n\n    // ASSERT: Transaction should FAIL (deadline not reached yet)\n    expect(result).toBe(false);                          // Contract rejects refund before deadline\n    expect(ctx.beneContract.utxos.length).toEqual(1);    // Box not spent\n  });\n\n  it(\"should fail to refund after deadline when minimum IS reached\", () => {\n    // ARRANGE: Create scenario where minimum WAS reached (successful campaign - no refunds!)\n    ctx.beneContract.utxos.clear();  // Clear existing box\n    const soldTokens = ctx.minimumTokensSold;       // 50,000 sold = minimum REACHED!\n    const collectedPayment = soldTokens * ctx.exchangeRate;  // 50 ERG collected\n\n    const contractAssets = [\n      { tokenId: ctx.projectNftId, amount: 1n + ctx.totalPFTokens - soldTokens },\n      { tokenId: ctx.pftTokenId, amount: ctx.totalPFTokens },\n    ];\n    if (!ctx.isErgMode) {\n      contractAssets.push({ tokenId: ctx.baseTokenId, amount: collectedPayment });\n    }\n\n    ctx.beneContract.addUTxOs({\n      value: ctx.isErgMode ? RECOMMENDED_MIN_FEE_VALUE + collectedPayment : RECOMMENDED_MIN_FEE_VALUE,\n      ergoTree: ctx.beneErgoTree.toHex(),\n      assets: contractAssets,\n      creationHeight: ctx.mockChain.height - 100,\n      additionalRegisters: {\n        R4: mode.useTimestamp\n          ? SPair(SBool(true), SLong(-1n)).toHex()\n          : SPair(SBool(false), SLong(BigInt(ctx.deadlineBlock))).toHex(),\n        R5: SLong(ctx.minimumTokensSold).toHex(),\n        R6: SColl(SLong, [soldTokens, 0n, 0n]).toHex(), // Minimum reached!\n        R7: SLong(ctx.exchangeRate).toHex(),\n        R8: ctx.constants.toHex(),\n        R9: SColl(SByte, stringToBytes(\"utf8\", \"{}\")).toHex(),\n      },\n    });\n\n    const boxMinReached = ctx.beneContract.utxos.toArray()[0];\n    ctx.mockChain.jumpTo(ctx.deadlineBlock + 2);  // Jump PAST deadline\n\n    // Find buyer's APT tokens\n    const buyerTokenBox = ctx.buyer.utxos\n      .toArray()\n      .find((box) => box.assets.some((asset) => asset.tokenId === ctx.projectNftId))!;\n    const tokensToRefund = buyerTokenBox.assets[0].amount;  // 5,000 APT\n    const refundAmount = tokensToRefund * ctx.exchangeRate;  // 5 ERG\n\n    const newAPTAmount = BigInt(boxMinReached.assets[0].amount) + tokensToRefund;\n\n    const refundContractAssets = [\n      { tokenId: ctx.projectNftId, amount: newAPTAmount },\n      { tokenId: ctx.pftTokenId, amount: ctx.totalPFTokens },\n    ];\n    if (!ctx.isErgMode) {\n      const currentBaseTokens = BigInt(boxMinReached.assets.find(a => a.tokenId === ctx.baseTokenId)!.amount);\n      refundContractAssets.push({ tokenId: ctx.baseTokenId, amount: currentBaseTokens - refundAmount });\n    }\n\n    const refundOutputBuilder = ctx.isErgMode\n      ? new OutputBuilder(refundAmount, ctx.buyer.address)\n      : new OutputBuilder(RECOMMENDED_MIN_FEE_VALUE, ctx.buyer.address).addTokens([\n        { tokenId: ctx.baseTokenId, amount: refundAmount },\n      ]);\n\n    // ACT: Try to refund even though minimum was reached\n    const transaction = new TransactionBuilder(ctx.mockChain.height)\n      .from([boxMinReached, buyerTokenBox])\n      .to([\n        new OutputBuilder(\n          ctx.isErgMode ? BigInt(boxMinReached.value) - refundAmount : boxMinReached.value,\n          ctx.beneErgoTree\n        )\n          .addTokens(refundContractAssets)\n          .setAdditionalRegisters({\n            R4: projectBox.additionalRegisters.R4,\n            R5: SLong(ctx.minimumTokensSold).toHex(),\n            R6: SColl(SLong, [soldTokens, tokensToRefund, 0n]).toHex(),  // Try to record refund\n            R7: SLong(ctx.exchangeRate).toHex(),\n            R8: boxMinReached.additionalRegisters.R8,\n            R9: boxMinReached.additionalRegisters.R9,\n          }),\n        refundOutputBuilder,\n      ])\n      .sendChangeTo(ctx.buyer.address)\n      .payFee(RECOMMENDED_MIN_FEE_VALUE)\n      .build();\n\n    // Execute with throw: false to capture failure\n    const result = ctx.mockChain.execute(transaction, { signers: [ctx.buyer], throw: false });\n\n    // ASSERT: Transaction should FAIL (campaign was successful, no refunds allowed)\n    expect(result).toBe(false);                          // Contract rejects: minimum WAS reached\n    expect(ctx.beneContract.utxos.length).toEqual(1);    // Box not spent\n  });\n\n  it(\"should fail to refund at exact deadline (HEIGHT == R4)\", () => {\n    // ARRANGE: Jump to exact deadline block (equal to R4). Contract requires HEIGHT > R4.\n    ctx.mockChain.jumpTo(ctx.deadlineBlock - 1); // exactly R4 (Fleet SDK's MockChain.execute() validates transactions at HEIGHT + 1, not at the current height.)\n\n    const buyerTokenBox = ctx.buyer.utxos\n      .toArray()\n      .find((box) => box.assets.some((asset) => asset.tokenId === ctx.projectNftId))!;\n    const tokensToRefund = buyerTokenBox.assets[0].amount;\n    const refundAmount = tokensToRefund * ctx.exchangeRate;\n\n    const soldTokens = ctx.minimumTokensSold / 2n;\n    const newAPTAmount = BigInt(projectBox.assets[0].amount) + tokensToRefund;\n\n    const contractAssets = [\n      { tokenId: ctx.projectNftId, amount: newAPTAmount },\n      { tokenId: ctx.pftTokenId, amount: ctx.totalPFTokens },\n    ];\n    if (!ctx.isErgMode) {\n      const currentBaseTokens = BigInt(projectBox.assets.find(a => a.tokenId === ctx.baseTokenId)!.amount);\n      contractAssets.push({ tokenId: ctx.baseTokenId, amount: currentBaseTokens - refundAmount });\n    }\n\n    const refundOutputBuilder = ctx.isErgMode\n      ? new OutputBuilder(refundAmount, ctx.buyer.address)\n      : new OutputBuilder(RECOMMENDED_MIN_FEE_VALUE, ctx.buyer.address).addTokens([\n        { tokenId: ctx.baseTokenId, amount: refundAmount },\n      ]);\n\n    const transaction = new TransactionBuilder(ctx.mockChain.height)\n      .from([projectBox, buyerTokenBox])\n      .to([\n        new OutputBuilder(\n          ctx.isErgMode ? BigInt(projectBox.value) - refundAmount : projectBox.value,\n          ctx.beneErgoTree\n        )\n          .addTokens(contractAssets)\n          .setAdditionalRegisters({\n            R4: projectBox.additionalRegisters.R4,\n            R5: SLong(ctx.minimumTokensSold).toHex(),\n            R6: SColl(SLong, [soldTokens, tokensToRefund, 0n]).toHex(),\n            R7: SLong(ctx.exchangeRate).toHex(),\n            R8: projectBox.additionalRegisters.R8,\n            R9: projectBox.additionalRegisters.R9,\n          }),\n        refundOutputBuilder,\n      ])\n      .sendChangeTo(ctx.buyer.address)\n      .payFee(RECOMMENDED_MIN_FEE_VALUE)\n      .build();\n\n    const result = ctx.mockChain.execute(transaction, { signers: [ctx.buyer], throw: false });\n\n    // ASSERT: Refund at HEIGHT == R4 should fail\n    expect(result).toBe(false);\n    expect(ctx.beneContract.utxos.length).toEqual(1);\n  });\n\n  it(\"should fail to refund when refund amount is incorrect (wrong exchange value)\", () => {\n    // ARRANGE: Jump past deadline\n    ctx.mockChain.jumpTo(ctx.deadlineBlock + 2);\n\n    const buyerTokenBox = ctx.buyer.utxos\n      .toArray()\n      .find((box) => box.assets.some((asset) => asset.tokenId === ctx.projectNftId))!;\n    const tokensToRefund = buyerTokenBox.assets[0].amount;\n    const correctRefundAmount = tokensToRefund * ctx.exchangeRate;\n\n    // Intentionally use wrong amount (e.g. one base token less)\n    const wrongRefundAmount = correctRefundAmount - (1n * (10n ** BigInt(ctx.baseTokenDecimals - ctx.baseTokenDecimals + 0))); // subtract 1 base unit\n    // For ERG mode above will subtract 1 nanoERG, ensure non-negative fallback\n    const attemptedRefund = wrongRefundAmount > 0n ? wrongRefundAmount : 0n;\n\n    const soldTokens = ctx.minimumTokensSold / 2n;\n    const newAPTAmount = BigInt(projectBox.assets[0].amount) + tokensToRefund;\n\n    const contractAssets = [\n      { tokenId: ctx.projectNftId, amount: newAPTAmount },\n      { tokenId: ctx.pftTokenId, amount: ctx.totalPFTokens },\n    ];\n    if (!ctx.isErgMode) {\n      const currentBaseTokens = BigInt(projectBox.assets.find(a => a.tokenId === ctx.baseTokenId)!.amount);\n      contractAssets.push({ tokenId: ctx.baseTokenId, amount: currentBaseTokens - attemptedRefund });\n    }\n\n    const refundOutputBuilder = ctx.isErgMode\n      ? new OutputBuilder(attemptedRefund, ctx.buyer.address)\n      : new OutputBuilder(RECOMMENDED_MIN_FEE_VALUE, ctx.buyer.address).addTokens([\n        { tokenId: ctx.baseTokenId, amount: attemptedRefund },\n      ]);\n\n    const transaction = new TransactionBuilder(ctx.mockChain.height)\n      .from([projectBox, buyerTokenBox])\n      .to([\n        new OutputBuilder(\n          ctx.isErgMode ? BigInt(projectBox.value) - attemptedRefund : projectBox.value,\n          ctx.beneErgoTree\n        )\n          .addTokens(contractAssets)\n          .setAdditionalRegisters({\n            R4: projectBox.additionalRegisters.R4,\n            R5: SLong(ctx.minimumTokensSold).toHex(),\n            R6: SColl(SLong, [soldTokens, tokensToRefund, 0n]).toHex(),\n            R7: SLong(ctx.exchangeRate).toHex(),\n            R8: projectBox.additionalRegisters.R8,\n            R9: projectBox.additionalRegisters.R9,\n          }),\n        refundOutputBuilder,\n      ])\n      .sendChangeTo(ctx.buyer.address)\n      .payFee(RECOMMENDED_MIN_FEE_VALUE)\n      .build();\n\n    const result = ctx.mockChain.execute(transaction, { signers: [ctx.buyer], throw: false });\n\n    // ASSERT: Transaction should fail because the refund amount doesn't match exchange rate\n    expect(result).toBe(false);\n    expect(ctx.beneContract.utxos.length).toEqual(1);\n  });\n\n  it(\"should fail to refund when R6 refund counter does not match tokens added (counter mismatch)\", () => {\n    // ARRANGE: Jump past deadline\n    ctx.mockChain.jumpTo(ctx.deadlineBlock + 2);\n\n    const buyerTokenBox = ctx.buyer.utxos\n      .toArray()\n      .find((box) => box.assets.some((asset) => asset.tokenId === ctx.projectNftId))!;\n    const tokensToRefund = buyerTokenBox.assets[0].amount;\n    const refundAmount = tokensToRefund * ctx.exchangeRate;\n\n    const soldTokens = ctx.minimumTokensSold / 2n;\n    const newAPTAmount = BigInt(projectBox.assets[0].amount) + tokensToRefund;\n\n    // Intentionally put wrong refund counter (tokensToRefund - 1) to simulate mismatch\n    const wrongRefundCounter = tokensToRefund - 1n;\n\n    const contractAssets = [\n      { tokenId: ctx.projectNftId, amount: newAPTAmount },\n      { tokenId: ctx.pftTokenId, amount: ctx.totalPFTokens },\n    ];\n    if (!ctx.isErgMode) {\n      const currentBaseTokens = BigInt(projectBox.assets.find(a => a.tokenId === ctx.baseTokenId)!.amount);\n      contractAssets.push({ tokenId: ctx.baseTokenId, amount: currentBaseTokens - refundAmount });\n    }\n\n    const refundOutputBuilder = ctx.isErgMode\n      ? new OutputBuilder(refundAmount, ctx.buyer.address)\n      : new OutputBuilder(RECOMMENDED_MIN_FEE_VALUE, ctx.buyer.address).addTokens([\n        { tokenId: ctx.baseTokenId, amount: refundAmount },\n      ]);\n\n    const transaction = new TransactionBuilder(ctx.mockChain.height)\n      .from([projectBox, buyerTokenBox])\n      .to([\n        new OutputBuilder(\n          ctx.isErgMode ? BigInt(projectBox.value) - refundAmount : projectBox.value,\n          ctx.beneErgoTree\n        )\n          .addTokens(contractAssets)\n          .setAdditionalRegisters({\n            R4: projectBox.additionalRegisters.R4,\n            R5: SLong(ctx.minimumTokensSold).toHex(),\n            // WRONG COUNTER intentionally\n            R6: SColl(SLong, [soldTokens, wrongRefundCounter, 0n]).toHex(),\n            R7: SLong(ctx.exchangeRate).toHex(),\n            R8: projectBox.additionalRegisters.R8,\n            R9: projectBox.additionalRegisters.R9,\n          }),\n        refundOutputBuilder,\n      ])\n      .sendChangeTo(ctx.buyer.address)\n      .payFee(RECOMMENDED_MIN_FEE_VALUE)\n      .build();\n\n    const result = ctx.mockChain.execute(transaction, { signers: [ctx.buyer], throw: false });\n\n    // ASSERT: Transaction should fail because R6 refund counter doesn't match tokens added\n    expect(result).toBe(false);\n    expect(ctx.beneContract.utxos.length).toEqual(1);\n  });\n});\n","path":null,"size_bytes":29808,"size_tokens":null},"src/app.d.ts":{"content":"// See https://kit.svelte.dev/docs/types#app\n// for information about these interfaces\ndeclare global {\n\tnamespace App {\n\t\t// interface Error {}\n\t\t// interface Locals {}\n\t\t// interface PageData {}\n\t\t// interface Platform {}\n\t}\n}\n\nexport {};\n","path":null,"size_bytes":241,"size_tokens":null},"tests/contracts/bene_contract_helpers.ts":{"content":"import { MockChain, type KeyedMockChainParty, type NonKeyedMockChainParty } from \"@fleet-sdk/mock-chain\";\nimport { compile } from \"@fleet-sdk/compiler\";\nimport { ErgoAddress } from \"@fleet-sdk/core\";\nimport { blake2b256 } from \"@fleet-sdk/crypto\";\nimport * as fs from \"fs\";\nimport * as path from \"path\";\nimport { ConstantContent, createR8Structure } from \"$lib/common/project\";\n\n// ===== Utility Functions ===== //\n\nexport function uint8ArrayToHex(bytes: Uint8Array): string {\n  return Buffer.from(bytes).toString(\"hex\");\n}\n\n// ===== Contract Loading ===== //\n// Read v2 contract template from file system\nconst contractsDir = path.resolve(__dirname, \"../../contracts/bene_contract\");\nexport const BENE_CONTRACT_V2 = fs.readFileSync(\n  path.join(contractsDir, \"contract_v2.es\"),\n  \"utf-8\"\n);\n\n// ===== Test Parameters ===== //\n\n// TOKEN CONFIGURATION: Configure ALL parameters for the token you're testing\n// âš ï¸ CRITICAL: exchangeRate = FUNDING_GOAL / TOTAL_PFT_TOKENS must be >= 1 (BigInt truncates!)\n\nexport const TOTAL_PFT_TOKENS = 100_000n;       // 100,000 tokens\n\n// --- ERG ---\nexport const ERG_BASE_TOKEN = \"\";\nexport const ERG_BASE_TOKEN_NAME = \"ERG\";\nexport const ERG_BASE_TOKEN_DECIMALS = 9;\nexport const ERG_FUNDING_GOAL = 100_000_000_000n;  // 100 ERG = 100 * 10^9\n// exchangeRate = 100,000,000,000 / 100,000 = 1,000,000 nanoERG per token\n\n// --- SigmaUSD ---\nexport const USD_BASE_TOKEN = \"03faf2cb329f2e90d6d23b58d91bbb6c046aa143261cc21f52fbe2824bfcbf04\";\nexport const USD_BASE_TOKEN_NAME = \"SigmaUSD\";\nexport const USD_BASE_TOKEN_DECIMALS = 2;\nexport const USD_FUNDING_GOAL = 10_000_000n;  // 100,000 SigUSD = 100,000 * 10^2\n// exchangeRate = 10,000,000 / 100,000 = 100 = 1.00 SigUSD per token\n\n\n// ===== Test Context Setup ===== //\n\nexport interface BeneTestContext {\n  mockChain: MockChain;\n  constants: any;\n  projectOwner: KeyedMockChainParty;\n  buyer: KeyedMockChainParty;\n  beneContract: NonKeyedMockChainParty;\n  beneErgoTree: ReturnType<typeof compile>;\n  projectNftId: string;\n  pftTokenId: string;\n  baseTokenId: string;\n  baseTokenName: string;\n  baseTokenDecimals: number;\n  isErgMode: boolean;\n  fundingGoal: bigint;\n  exchangeRate: bigint;\n  totalPFTokens: bigint;\n  minimumTokensSold: bigint;\n  deadlineBlock: number;\n  deadlineTimestamp: bigint;\n  devFeePercentage: number;\n}\n//\n// MAIN SETUP FUNCTION: Creates a complete test environment for Bene contract testing\n// This function is called in beforeEach() of each test file to get a fresh mock blockchain\n//\n// NOTE: This creates TEST DEFAULTS for:\n// - Funding parameters (goal, tokens, minimum, deadline)\n// - Token IDs (APT and PFT are hardcoded test values)\n//\n// NOT SET HERE (individual tests should define these):\n// - Project metadata: name, description, image (stored in R8/R9 registers)\n// - Specific funding amounts (tests override defaults as needed)\nexport function setupBeneTestContext(\n  baseTokenId: string,      // PAYMENT token: \"\" for ERG mode, or token ID for custom token mode\n  baseTokenName: string,\n  ownerAddress: ErgoAddress | null = null\n): BeneTestContext {\n  // STEP 1: Initialize mock blockchain at block height 800,000\n  const mockChain = new MockChain({ height: 800_000 });\n\n  // STEP 2: Create mock participants (wallets/addresses) on the blockchain\n  const projectOwner = mockChain.newParty(\"ProjectOwner\");  // Creator of the fundraising project (in case ownerAddress is provided, this party is simply used to execute transactions)\n  const buyer = mockChain.newParty(\"Buyer\");                // User who will buy tokens\n\n  // STEP 3: Define project parameters (using values from configuration above)\n  const fundingGoal = ERG_FUNDING_GOAL;                  // From config: varies by token decimals\n  const totalPFTokens = TOTAL_PFT_TOKENS;            // From config: total tokens to sell\n  const exchangeRate = fundingGoal / totalPFTokens;  // Calculated price per token (MUST be >= 1!)\n  const minimumTokensSold = totalPFTokens / 2n;      // Minimum threshold: 50% (owner chooses - can be any value)\n  const deadlineBlock = 800_200;                     // Campaign deadline: block 800,200 (owner chooses)\n  // Calculate deadline timestamp based on MockChain's 2-minute block time\n  const deadlineTimestamp = BigInt(mockChain.timestamp) + (BigInt(deadlineBlock - 800_000) * 120_000n);\n  const devFeePercentage = 5;                        // Platform fee: 5% of raised funds (platform constant)\n\n  // Validation: Ensure exchange rate is valid\n  if (exchangeRate === 0n) {\n    throw new Error(\n      `âŒ INVALID CONFIGURATION: Exchange rate is 0!\\n` +\n      `   FUNDING_GOAL (${fundingGoal}) / TOTAL_PFT_TOKENS (${totalPFTokens}) = ${exchangeRate}\\n` +\n      `   Exchange rate must be >= 1 (smallest unit).\\n` +\n      `   Either increase FUNDING_GOAL or decrease TOTAL_PFT_TOKENS.`\n    );\n  }\n\n  // LOGGING: Display test configuration (only once per test run)\n  const decimalDivisor = 10 ** ERG_BASE_TOKEN_DECIMALS;  // Use actual decimals from config\n\n  // Only log configuration if this is the first time setup is called\n  if (!(globalThis as any).__beneTestConfigLogged) {\n    console.log(\"\\n\" + \"=\".repeat(80));\n    console.log(\"BENE CONTRACT TEST CONFIGURATION\");\n    console.log(\"=\".repeat(80));\n    console.log(`Payment Token:        ${baseTokenName} (${ERG_BASE_TOKEN_DECIMALS} decimals) ${baseTokenId === \"\" ? \"[native ERG]\" : \"\"}`);\n    if (baseTokenId !== \"\") {\n      console.log(`   Token ID:             ${baseTokenId.substring(0, 20)}...${baseTokenId.substring(baseTokenId.length - 10)}`);\n    }\n\n    const fundingGoalDisplay = Number(fundingGoal) / decimalDivisor;\n    console.log(`Funding Goal:         ${fundingGoalDisplay} ${baseTokenName}`);\n    console.log(`   (Smallest units):     ${fundingGoal.toLocaleString()}`);\n    console.log(`Reward Tokens (PFT):  ${totalPFTokens.toLocaleString()} tokens`);\n\n    const exchangeRateDisplay = Number(exchangeRate) / decimalDivisor;\n    console.log(`Exchange Rate:        ${exchangeRateDisplay} ${baseTokenName} per token`);\n    console.log(`   (Inverse):            ${(1 / exchangeRateDisplay).toFixed(6)} tokens per ${baseTokenName}`);\n    console.log(`   (Smallest units):     ${exchangeRate.toLocaleString()} per token`);\n\n    console.log(`Minimum to Sell:      ${minimumTokensSold.toLocaleString()} tokens (${(Number(minimumTokensSold) / Number(totalPFTokens) * 100).toFixed(0)}%)`);\n    console.log(`Deadline Block:       ${deadlineBlock.toLocaleString()}`);\n    console.log(`Deadline Timestamp:   ${deadlineTimestamp.toLocaleString()}`);\n    console.log(`Platform Dev Fee:     ${devFeePercentage}%`);\n    console.log(\"=\".repeat(80) + \"\\n\");\n\n    (globalThis as any).__beneTestConfigLogged = true;\n  }\n\n  // STEP 4: Calculate payment mode flags\n  const isErgMode = baseTokenId === \"\";                   // true = accept ERG, false = accept custom token\n\n  // STEP 5: Fund the buyer with ERG for transaction fees\n  buyer.addBalance({ nanoergs: 50_000_000_000n });  // Give buyer 50 ERG for gas fees\n\n  // STEP 6: If using custom token mode, also give buyer the payment tokens\n  if (!isErgMode) {\n    const buyerTokenAmount = fundingGoal * 10n;  // Give buyer 10x the funding goal to ensure sufficient funds\n    buyer.addUTxOs({\n      value: 10_000_000_000n,                      // 10 ERG for transaction fees\n      ergoTree: buyer.address.ergoTree,            // Buyer's address\n      assets: [{ tokenId: baseTokenId, amount: buyerTokenAmount }], // Sufficient custom tokens\n      creationHeight: mockChain.height - 50,       // Created 50 blocks ago\n      additionalRegisters: {},\n    });\n  }\n\n  const projectNftId = \"1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef\";  // APT token ID (hardcoded for testing)\n  const pftTokenId = \"abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890\";    // PFT/reward token ID (hardcoded for testing)\n\n  // STEP 8: Compile the Bene smart contract with actual values replacing placeholders\n  // In case is not provided, use the projectOwner. If is provided, the actual project owner will not be added into the contract.\n  if (ownerAddress === null) {\n    const ownerAddressStr = projectOwner.address.toString();\n    ownerAddress = ErgoAddress.fromBase58(ownerAddressStr)\n  }\n\n  // STEP 8a: Convert owner address to ErgoTree hex for P2S/P2PK support\n  const ownerErgoTree = ownerAddress.ergoTree;\n\n  // STEP 8b: Create dev fee contract (simple contract that accepts any transaction)\n  const devFeeContract = compile(`{ sigmaProp(true) }`);        // Always returns true (for testing)\n  const devFeeContractBytes = devFeeContract.bytes;              // Get bytes property (not method!)\n  const devFeeContractHashBytes = blake2b256(devFeeContractBytes); // Hash the contract\n  const devFeeContractHash = uint8ArrayToHex(devFeeContractHashBytes); // Convert to hex string\n\n  const constants = createR8Structure({\n    owner: ownerErgoTree,\n    dev_hash: devFeeContractHash,\n    dev_fee: devFeePercentage,\n    pft_token_id: pftTokenId,\n    base_token_id: baseTokenId\n  });\n\n  // STEP 8c: Compile the contract source code into ErgoTree (executable bytecode)\n  const beneErgoTree = compile(BENE_CONTRACT_V2);\n\n  // STEP 9: Register the contract as a \"party\" on the mock blockchain\n  const beneContract = mockChain.addParty(beneErgoTree.toHex(), `BeneContract-${baseTokenName}`);\n\n  // STEP 10: Return the complete test context object\n  // This object contains everything needed for testing: blockchain, actors, and configuration\n  return {\n    mockChain,           // The simulated blockchain\n    constants,            // Constant content for the project\n    projectOwner,        // Project creator's wallet\n    buyer,               // Token buyer's wallet\n    beneContract,        // The smart contract party\n    beneErgoTree,        // Compiled contract bytecode\n    projectNftId,        // APT token ID\n    pftTokenId,          // PFT token ID\n    baseTokenId,         // Payment token ID (\"\" for ERG)\n    baseTokenName,       // Human-readable name (\"ERG\", \"SigUSD\", etc.)\n    baseTokenDecimals: ERG_BASE_TOKEN_DECIMALS,  // Number of decimals (9 for ERG, 2 for SigUSD, etc.)\n    isErgMode,           // true if accepting ERG, false if accepting custom token\n    fundingGoal,         // Total amount to raise\n    exchangeRate,        // Price per APT token\n    totalPFTokens,       // Total APT tokens available (100,000)\n    minimumTokensSold,   // Minimum threshold (50,000)\n    deadlineBlock,       // Campaign deadline (block 800,200)\n    deadlineTimestamp,   // Campaign deadline (timestamp)\n    devFeePercentage,    // Platform fee (5%)\n  };\n}\n\nimport { SBool, SLong, SPair } from \"@fleet-sdk/serializer\";\n\nexport function createR4(ctx: BeneTestContext, useTimestamp: boolean = false) {\n  return useTimestamp\n    ? SPair(SBool(true), SLong(ctx.deadlineTimestamp)).toHex()\n    : SPair(SBool(false), SLong(BigInt(ctx.deadlineBlock))).toHex();\n}\n","path":null,"size_bytes":10897,"size_tokens":null},"src/lib/ergo/actions/temp_exchange.ts":{"content":"import {\n    OutputBuilder,\n    RECOMMENDED_MIN_FEE_VALUE,\n    TransactionBuilder,\n    SLong,\n    SInt,\n    SAFE_MIN_BOX_VALUE\n} from '@fleet-sdk/core';\n\nimport { SString } from '../utils';\nimport { createR8Structure, type Project } from '../../common/project';\nimport { get_ergotree_hex } from '../contract';\nimport { getCurrentHeight, getChangeAddress, signTransaction, submitTransaction } from '../wallet-utils';\nimport { SBool, SColl, SPair } from '@fleet-sdk/serializer';\n\n// Function to submit a project to the blockchain\nexport async function temp_exchange(\n    project: Project,\n    token_amount: number\n): Promise<string | null> {\n\n    token_amount = Math.floor(token_amount * Math.pow(10, project.token_details.decimals));\n\n    // Get the wallet address (will be the user address)\n    const walletPk = await getChangeAddress();\n\n    // Get the UTXOs from the current wallet to use as inputs\n    const inputs = [project.box, ...(await window.ergo!.get_utxos())];\n\n    // Building the project output\n    let contractOutput = new OutputBuilder(\n        BigInt(project.value),\n        get_ergotree_hex(project.constants, project.version)\n    )\n        .addTokens({\n            tokenId: project.project_id,\n            amount: BigInt(project.current_idt_amount + token_amount)\n        });\n\n    if (project.current_pft_amount !== token_amount) {\n        contractOutput.addTokens({\n            tokenId: project.pft_token_id,\n            amount: BigInt(project.current_pft_amount - token_amount)\n        });\n    }\n\n    // Handle base tokens for v2 multitoken contracts\n    if (project.version === \"v2\" && project.base_token_id && project.base_token_id !== \"\") {\n        // Find current base token amount in the project box\n        let currentBaseTokenAmount = 0;\n        for (const token of project.box.assets) {\n            if (token.tokenId === project.base_token_id) {\n                currentBaseTokenAmount = Number(token.amount);\n                break;\n            }\n        }\n\n        // Add base token to contract output (amount remains unchanged during temp exchange)\n        if (currentBaseTokenAmount > 0) {\n            contractOutput.addTokens({\n                tokenId: project.base_token_id,\n                amount: BigInt(currentBaseTokenAmount)\n            });\n        }\n    }\n\n    // Set additional registers based on contract version\n    contractOutput.setAdditionalRegisters({\n        R4: SPair(SBool(project.is_timestamp_limit), SLong(BigInt(project.block_limit))).toHex(),\n        R5: SLong(BigInt(project.minimum_amount)).toHex(),\n        R6: SColl(SLong, [BigInt(project.sold_counter), BigInt(project.refund_counter), BigInt(project.auxiliar_exchange_counter + token_amount)]).toHex(),\n        R7: SLong(BigInt(project.exchange_rate)).toHex(),\n        R8: createR8Structure(project.constants).toHex(),\n        R9: SString(project.content.raw)\n    });\n\n    let walletOutput = new OutputBuilder(\n        SAFE_MIN_BOX_VALUE,\n        walletPk\n    )\n        .addTokens({\n            tokenId: project.pft_token_id,\n            amount: BigInt(token_amount)\n        })\n\n    let outputs = [contractOutput, walletOutput];\n\n    // Building the unsigned transaction\n    const unsignedTransaction = await new TransactionBuilder(await getCurrentHeight())\n        .from(inputs)                          // Inputs coming from the user's UTXOs\n        .to(outputs)                           // Outputs (the new project box)\n        .sendChangeTo(walletPk)                // Send change back to the wallet\n        .payFee(RECOMMENDED_MIN_FEE_VALUE)     // Pay the recommended minimum fee\n        .build()                               // Build the transaction\n        .toEIP12Object();                      // Convert the transaction to an EIP-12 compatible object\n\n    try {\n        // Sign the transaction\n        const signedTransaction = await signTransaction(unsignedTransaction);\n\n        // Send the transaction to the Ergo network\n        const transactionId = await submitTransaction(signedTransaction);\n\n        console.log(\"Transaction id -> \", transactionId);\n        return transactionId;\n    } catch (e) {\n        console.log(e)\n    }\n}\n","path":null,"size_bytes":4157,"size_tokens":null},"src/lib/components/ui/scroll-area/index.ts":{"content":"import Scrollbar from \"./scroll-area-scrollbar.svelte\";\nimport Root from \"./scroll-area.svelte\";\n\nexport {\n\tRoot,\n\tScrollbar,\n\t//,\n\tRoot as ScrollArea,\n\tScrollbar as ScrollAreaScrollbar,\n};\n","path":null,"size_bytes":190,"size_tokens":null},"src/lib/wallet/adapters/nautilus.ts":{"content":"import { BaseWalletAdapter } from './base';\nimport type { WalletBalance, WalletDownloadUrls } from '../types';\n\nexport class NautilusWalletAdapter extends BaseWalletAdapter {\n  id = 'nautilus';\n  name = 'Nautilus Wallet';\n  icon = '/wallet-icons/nautilus.svg';\n  downloadUrls: WalletDownloadUrls = {\n    chrome: 'https://chrome.google.com/webstore/detail/nautilus-wallet/gjlmehlldlphhljhpnlddaodbjjcchai',\n    firefox: 'https://addons.mozilla.org/en-US/firefox/addon/nautilus/',\n    browserExtension: 'https://github.com/capt-nemo429/nautilus-wallet'\n  };\n\n  async connect(): Promise<boolean> {\n    try {\n      if (!this.isInstalled()) {\n        throw new Error('Nautilus wallet is not installed');\n      }\n\n      const nautilus = window.ergoConnector?.nautilus;\n      if (!nautilus) {\n        throw new Error('Nautilus connector not available');\n      }\n\n      const connected = await nautilus.connect();\n      if (connected) {\n        this.emit('connect');\n        return true;\n      }\n      return false;\n    } catch (error) {\n      this.handleError(error, 'connect');\n    }\n  }\n\n  async disconnect(): Promise<void> {\n    try {\n      const nautilus = window.ergoConnector?.nautilus;\n      if (nautilus) {\n        await nautilus.disconnect();\n        this.emit('disconnect');\n      }\n    } catch (error) {\n      this.handleError(error, 'disconnect');\n    }\n  }\n\n  async isConnected(): Promise<boolean> {\n    try {\n      const nautilus = window.ergoConnector?.nautilus;\n      if (!nautilus) return false;\n      return await nautilus.isConnected();\n    } catch (error) {\n      return false;\n    }\n  }\n\n  async getAddresses(): Promise<string[]> {\n    try {\n      if (!(await this.isConnected())) {\n        throw new Error('Wallet not connected');\n      }\n      return await window.ergo!.get_used_addresses();\n    } catch (error) {\n      this.handleError(error, 'getAddresses');\n    }\n  }\n\n  async getChangeAddress(): Promise<string> {\n    try {\n      if (!(await this.isConnected())) {\n        throw new Error('Wallet not connected');\n      }\n      return await window.ergo!.get_change_address();\n    } catch (error) {\n      this.handleError(error, 'getChangeAddress');\n    }\n  }\n\n  async getBalance(address?: string): Promise<WalletBalance> {\n    try {\n      if (!(await this.isConnected())) {\n        throw new Error('Wallet not connected');\n      }\n\n      const addr = address || await this.getChangeAddress();\n      \n      // Use the same API endpoint as the existing platform\n      const response = await fetch(`https://api.ergoplatform.com/api/v1/addresses/${addr}/balance/confirmed`);\n      if (!response.ok) {\n        throw new Error(`API request failed with status: ${response.status}`);\n      }\n\n      const data = await response.json();\n      \n      return {\n        nanoErgs: BigInt(data.nanoErgs),\n        tokens: data.tokens.map((token: any) => ({\n          tokenId: token.tokenId,\n          amount: BigInt(token.amount),\n          name: token.name,\n          decimals: token.decimals\n        }))\n      };\n    } catch (error) {\n      this.handleError(error, 'getBalance');\n    }\n  }\n\n  async signTransaction(unsignedTx: any): Promise<any> {\n    try {\n      if (!(await this.isConnected())) {\n        throw new Error('Wallet not connected');\n      }\n      return await window.ergo!.sign_tx(unsignedTx);\n    } catch (error) {\n      this.handleError(error, 'signTransaction');\n    }\n  }\n\n  async submitTransaction(signedTx: any): Promise<string> {\n    try {\n      if (!(await this.isConnected())) {\n        throw new Error('Wallet not connected');\n      }\n      return await window.ergo!.submit_tx(signedTx);\n    } catch (error) {\n      this.handleError(error, 'submitTransaction');\n    }\n  }\n\n  async getNetworkId(): Promise<string> {\n    try {\n      if (!(await this.isConnected())) {\n        throw new Error('Wallet not connected');\n      }\n      // Import network_id from environment configuration\n      const { network_id } = await import('../../ergo/envs');\n      return network_id === 'mainnet' ? 'mainnet' : 'testnet';\n    } catch (error) {\n      this.handleError(error, 'getNetworkId');\n    }\n  }\n\n  async getCurrentHeight(): Promise<number> {\n    try {\n      if (!(await this.isConnected())) {\n        throw new Error('Wallet not connected');\n      }\n      return await window.ergo!.get_current_height();\n    } catch (error) {\n      this.handleError(error, 'getCurrentHeight');\n    }\n  }\n\n  isInstalled(): boolean {\n    return typeof window !== 'undefined' && \n           typeof window.ergoConnector !== 'undefined' && \n           typeof window.ergoConnector.nautilus !== 'undefined';\n  }\n}\n","path":null,"size_bytes":4611,"size_tokens":null},"src/lib/components/ui/input/index.ts":{"content":"import Root from \"./input.svelte\";\n\nexport type FormInputEvent<T extends Event = Event> = T & {\n\tcurrentTarget: EventTarget & HTMLInputElement;\n};\nexport type InputEvents = {\n\tblur: FormInputEvent<FocusEvent>;\n\tchange: FormInputEvent<Event>;\n\tclick: FormInputEvent<MouseEvent>;\n\tfocus: FormInputEvent<FocusEvent>;\n\tfocusin: FormInputEvent<FocusEvent>;\n\tfocusout: FormInputEvent<FocusEvent>;\n\tkeydown: FormInputEvent<KeyboardEvent>;\n\tkeypress: FormInputEvent<KeyboardEvent>;\n\tkeyup: FormInputEvent<KeyboardEvent>;\n\tmouseover: FormInputEvent<MouseEvent>;\n\tmouseenter: FormInputEvent<MouseEvent>;\n\tmouseleave: FormInputEvent<MouseEvent>;\n\tmousemove: FormInputEvent<MouseEvent>;\n\tpaste: FormInputEvent<ClipboardEvent>;\n\tinput: FormInputEvent<InputEvent>;\n\twheel: FormInputEvent<WheelEvent>;\n};\n\nexport {\n\tRoot,\n\t//\n\tRoot as Input,\n};\n","path":null,"size_bytes":830,"size_tokens":null},"src/lib/ergo/forum/object.ts":{"content":"import { type Amount, type Box } from \"@fleet-sdk/core\";\nimport { get } from 'svelte/store';\nimport { proofs, compute_deep_level } from \"./store\";\nimport { stringToRendered } from \"./utils\";\n\n// --- CORE TYPES ---\n\nexport interface TypeNFT {\n    tokenId: string;\n    boxId: string;\n    typeName: string;\n    description: string;\n    schemaURI: string;\n    isRepProof: boolean;\n}\n\nexport interface ReputationProof {\n    token_id: string;\n    type: TypeNFT;  // SELF identification of the proof type (by Type NFT)\n    total_amount: number;\n    owner_address: string;\n    owner_serialized: string;\n    can_be_spend: boolean;\n    current_boxes: RPBox[];\n    number_of_boxes: number;\n    network: Network;\n    data: object;\n}\n\nexport interface RPBox {\n    box: Box<Amount>;\n    box_id: string;\n    type: TypeNFT; \n    token_id: string;\n    token_amount: number;\n    object_pointer: string;\n    is_locked: boolean;\n    polarization: boolean;\n    content: object|string|null;\n}\n\n// --- ENUMS & UTILITIES ---\n\nexport function token_rendered(proof: ReputationProof): string {\n    return stringToRendered(proof.token_id);\n};\n\nexport enum Network {\n    ErgoTestnet = \"ergo-testnet\",\n    ErgoMainnet = \"ergo\",\n    BitcoinTestnet = \"btc-testnet\",\n    BitcoinMainnet = \"btc\"\n}\n\n// --- REPUTATION COMPUTATION LOGIC ---\n\nexport function compute(proof: ReputationProof, target_object_pointer: string): number {\n    const all_proofs = get(proofs);\n    return internal_compute(\n        all_proofs,\n        proof,\n        target_object_pointer,\n        get(compute_deep_level)\n    );\n}\n\nfunction internal_compute(\n    all_proofs: Map<string, ReputationProof>,\n    proof: ReputationProof,\n    target_object_pointer: string,\n    deep_level: number\n): number {\n    console.log(`Compute (deep_level: ${deep_level}) on proof: ${proof.type.typeName} (${proof.token_id})`);\n    \n    return proof.current_boxes.reduce((total, box) => {\n        if (proof.total_amount === 0) return total; // Avoid division by zero\n        const proportion = box.token_amount / proof.total_amount;\n        const boxReputation = computeBoxReputation(all_proofs, proof, box, target_object_pointer, deep_level);\n        const signedReputation = (box.polarization ? 1 : -1) * boxReputation;\n        return total + (proportion * signedReputation);\n    }, 0);\n}\n\nfunction computeBoxReputation(\n    all_proofs: Map<string, ReputationProof>,\n    parent_proof: ReputationProof,\n    box: RPBox,\n    target_object_pointer: string,\n    deep_level: number\n): number {\n    if (parent_proof.type.typeName.includes(\"Proof-by-Token\")) {\n        const pointed_token_id = box.object_pointer;\n        if (pointed_token_id === parent_proof.token_id) return 0.00;\n\n        const pointed_proof = all_proofs.get(pointed_token_id);\n        if (pointed_proof) {\n            if (deep_level <= 0) return 0.00;\n            return internal_compute(all_proofs, pointed_proof, target_object_pointer, deep_level - 1);\n        } else {\n            return 0.00;\n        }\n    } else {\n        return box.object_pointer === target_object_pointer ? 1.00 : 0.00;\n    }\n}","path":null,"size_bytes":3086,"size_tokens":null},"src/lib/ergo/utils/box-size-calculator.ts":{"content":"/**\n * Utilities for calculating and validating Ergo box sizes\n */\n\nimport { SInt, SLong, SColl, SPair, SBool } from '@fleet-sdk/serializer';\nimport { SString } from '../utils';\nimport { get_dev_contract_address, get_dev_contract_hash, get_dev_fee } from '../dev/dev_contract';\nimport { get_ergotree_hex } from '../contract';\nimport type { ConstantContent } from '$lib/common/project';\n\n/**\n * Calculate the UTF-8 byte length of a string\n */\nexport function utf8ByteLength(str: string): number {\n    return new TextEncoder().encode(str).length;\n}\n\n/**\n * Calculate the hex byte length from a hex string\n */\nexport function hexByteLength(hexStr: string): number {\n    if (!hexStr) return 0;\n    const stripped = hexStr.startsWith('0x') ? hexStr.slice(2) : hexStr;\n    return Math.ceil(stripped.length / 2);\n}\n\n/**\n * Project content structure\n */\nexport interface ProjectContent {\n    title: string;\n    description: string;\n    image: string;\n    link: string;\n}\n\n/**\n * Calculate the size in bytes of the project content JSON (R9 register)\n */\nexport function calculateProjectContentBytes(content: ProjectContent): number {\n    const jsonString = JSON.stringify(content);\n    return utf8ByteLength(jsonString);\n}\n\n/**\n * Estimate the total size of all registers (R4-R9) in bytes\n * This includes the content itself plus per-register overhead\n */\nexport interface RegisterSizes {\n    r4Bytes: number;  // blockLimit (SInt)\n    r5Bytes: number;  // minimumSold (SLong)\n    r6Bytes: number;  // SColl(SLong, [0,0,0])\n    r7Bytes: number;  // exchangeRate (SLong)\n    r8Bytes: number;  // addressContent JSON\n    r9Bytes: number;  // projectContent JSON\n}\n\nexport function estimateRegisterSizes(\n    r4Hex: string,\n    r5Hex: string,\n    r6Hex: string,\n    r7Hex: string,\n    r8Hex: string,\n    r9Hex: string\n): RegisterSizes {\n    const PER_REGISTER_OVERHEAD = 1;\n\n    return {\n        r4Bytes: hexByteLength(r4Hex) + PER_REGISTER_OVERHEAD,\n        r5Bytes: hexByteLength(r5Hex) + PER_REGISTER_OVERHEAD,\n        r6Bytes: hexByteLength(r6Hex) + PER_REGISTER_OVERHEAD,\n        r7Bytes: hexByteLength(r7Hex) + PER_REGISTER_OVERHEAD,\n        r8Bytes: hexByteLength(r8Hex) + PER_REGISTER_OVERHEAD,\n        r9Bytes: hexByteLength(r9Hex) + PER_REGISTER_OVERHEAD,\n    };\n}\n\n/**\n * Estimate the total box size including all components\n */\nexport function estimateTotalBoxSize(\n    ergoTreeLength: number,\n    numTokens: number,\n    registerSizes: RegisterSizes\n): number {\n    const BASE_BOX_OVERHEAD = 60;\n    const PER_TOKEN_BYTES = 40;\n    const SIZE_MARGIN = 120;\n\n    const totalRegistersBytes =\n        registerSizes.r4Bytes +\n        registerSizes.r5Bytes +\n        registerSizes.r6Bytes +\n        registerSizes.r7Bytes +\n        registerSizes.r8Bytes +\n        registerSizes.r9Bytes;\n\n    return (\n        BASE_BOX_OVERHEAD +\n        ergoTreeLength +\n        (PER_TOKEN_BYTES * numTokens) +\n        totalRegistersBytes +\n        SIZE_MARGIN\n    );\n}\n\n/**\n * Maximum box size in Ergo blockchain\n * This is the hard limit we must never exceed\n */\nexport const MAX_BOX_SIZE = 4096;\n\n/**\n * Calculate the actual size of R8 (addressContent) using typical values\n */\nexport function calculateR8Size(): number {\n    try {\n        // Use typical address content structure\n        const addressContent = {\n            \"owner\": \"9fcwctfPQPkDfHgxBns5Uu3dwWpaoywhkpLEobLuztfQuV5mt3T\", // Typical address\n            \"dev_addr\": get_dev_contract_address(),\n            \"dev_hash\": get_dev_contract_hash(),\n            \"dev_fee\": get_dev_fee(),\n            \"pft_token_id\": \"a3f7c9e12bd45890ef12aa7c6d54b9317c0df4a28b6e5590d4f1b3e8c92d77af\",\n            \"base_token_id\": \"\" // Empty for ERG\n        };\n\n        const r8Hex = SString(JSON.stringify(addressContent));\n        return hexByteLength(r8Hex) + 1; // +1 for register overhead\n    } catch (error) {\n        console.warn('Could not calculate R8 size dynamically, using measured value:', error);\n        return 251; // Fallback to measured value\n    }\n}\n\n/**\n * Calculate the actual size of R4-R7 registers using typical values\n */\nexport function calculateRegisterSizesEstimate(): {\n    r4: number;\n    r5: number;\n    r6: number;\n    r7: number;\n} {\n    try {\n        const PER_REGISTER_OVERHEAD = 1;\n\n        // Use typical values for calculation\n        const r4Hex = SPair(SBool(false), SInt(1000000)).toHex(); // Typical blockLimit\n        const r5Hex = SLong(BigInt(0)).toHex(); // Typical minimumSold\n        const r6Hex = SColl(SLong, [BigInt(0), BigInt(0), BigInt(0)]).toHex(); // Always same\n        const r7Hex = SLong(BigInt(1000000)).toHex(); // Typical exchangeRate\n\n        return {\n            r4: hexByteLength(r4Hex) + PER_REGISTER_OVERHEAD,\n            r5: hexByteLength(r5Hex) + PER_REGISTER_OVERHEAD,\n            r6: hexByteLength(r6Hex) + PER_REGISTER_OVERHEAD,\n            r7: hexByteLength(r7Hex) + PER_REGISTER_OVERHEAD\n        };\n    } catch (error) {\n        console.warn('Could not calculate register sizes dynamically, using measured values:', error);\n        // Fallback to measured values\n        return {\n            r4: 6,\n            r5: 10,\n            r6: 26,\n            r7: 10\n        };\n    }\n}\n\n/**\n * Calculate the actual ErgoTree size for a given contract version\n * Uses template constants (random values) to generate a representative ErgoTree\n */\nexport function calculateErgoTreeSize(version: string = \"v2\"): number {\n    try {\n        // Use the same random constants as in contract.ts get_template_hash()\n        const random_constants: ConstantContent = {\n            \"owner\": \"9fcwctfPQPkDfHgxBns5Uu3dwWpaoywhkpLEobLuztfQuV5mt3T\",  // RANDOM\n            \"dev_addr\": get_dev_contract_address(),\n            \"dev_hash\": get_dev_contract_hash(),\n            \"dev_fee\": get_dev_fee(),\n            \"pft_token_id\": \"a3f7c9e12bd45890ef12aa7c6d54b9317c0df4a28b6e5590d4f1b3e8c92d77af\",   // RANDOM\n            \"base_token_id\": \"2c5d596d617aaafe16f3f58b2c562d046eda658f0243dc1119614160d92a4717\" // RANDOM\n        };\n\n        const ergoTreeHex = get_ergotree_hex(random_constants);\n        return hexByteLength(ergoTreeHex);\n    } catch (error) {\n        // Fallback to measured value if calculation fails\n        console.warn('Could not calculate ErgoTree size dynamically, using measured value:', error);\n        return 300; // This is the actual measured size of v2 contracts\n    }\n}\n\n// Cache the ErgoTree size calculation since it doesn't change\nlet cachedErgoTreeSize: number | null = null;\n\n/**\n * Get the ErgoTree size (cached for performance)\n */\nexport function getErgoTreeSize(version: string = \"v2\"): number {\n    if (cachedErgoTreeSize === null) {\n        cachedErgoTreeSize = calculateErgoTreeSize(version);\n    }\n    return cachedErgoTreeSize;\n}\n\n/**\n * Estimate total box size for a project with given content\n * This calculates the actual size using real register values\n */\nexport function estimateCompleteBoxSize(content: ProjectContent, contractVersion: string = \"v2\"): number {\n    const BASE_BOX_OVERHEAD = 60;\n    const PER_TOKEN_BYTES = 40;\n    const NUM_TOKENS = 3; // project_id, token_id, (optional base_token)\n    const SIZE_MARGIN = 120;\n    const PER_REGISTER_OVERHEAD = 1;\n\n    // Calculate R9 size (actual project content)\n    const r9ContentBytes = calculateProjectContentBytes(content);\n    const r9TotalBytes = r9ContentBytes + PER_REGISTER_OVERHEAD;\n\n    // Get actual calculated sizes\n    const ergoTreeBytes = getErgoTreeSize(contractVersion);\n    const tokensBytes = PER_TOKEN_BYTES * NUM_TOKENS;\n    const registerSizes = calculateRegisterSizesEstimate();\n    const r8Bytes = calculateR8Size();\n\n    const totalSize =\n        BASE_BOX_OVERHEAD +\n        ergoTreeBytes +\n        tokensBytes +\n        registerSizes.r4 +\n        registerSizes.r5 +\n        registerSizes.r6 +\n        registerSizes.r7 +\n        r8Bytes +\n        r9TotalBytes +\n        SIZE_MARGIN;\n\n    return totalSize;\n}\n\n/**\n * Validation result for project content\n */\nexport interface ValidationResult {\n    isValid: boolean;\n    currentBytes: number;\n    estimatedBoxSize: number;\n    remainingBytes: number;\n    message?: string;\n}\n\n/**\n * Validate that the estimated total box size fits within the 4096 byte limit\n */\nexport function validateProjectContent(content: ProjectContent): ValidationResult {\n    const currentBytes = calculateProjectContentBytes(content);\n    const estimatedBoxSize = estimateCompleteBoxSize(content);\n    const remainingBytes = Math.max(0, MAX_BOX_SIZE - estimatedBoxSize + currentBytes);\n\n    // Check if total estimated box size exceeds limit\n    if (estimatedBoxSize > MAX_BOX_SIZE) {\n        const excessBytes = estimatedBoxSize - MAX_BOX_SIZE;\n        return {\n            isValid: false,\n            currentBytes,\n            estimatedBoxSize,\n            remainingBytes,\n            message: `Estimated box size (${estimatedBoxSize} bytes) exceeds maximum (${MAX_BOX_SIZE} bytes). Please reduce content by approximately ${excessBytes} bytes.`\n        };\n    }\n\n    return {\n        isValid: true,\n        currentBytes,\n        estimatedBoxSize,\n        remainingBytes\n    };\n}\n\n/**\n * Get remaining bytes available for project content\n * Based on the total box size limit\n */\nexport function getRemainingBytes(content: ProjectContent): number {\n    const currentBytes = calculateProjectContentBytes(content);\n    const estimatedBoxSize = estimateCompleteBoxSize(content);\n\n    // Calculate how much room we have left in the box\n    return Math.max(0, MAX_BOX_SIZE - estimatedBoxSize + currentBytes);\n}\n\n/**\n * Calculate the percentage of box size used\n */\nexport function getUsagePercentage(content: ProjectContent): number {\n    const estimatedBoxSize = estimateCompleteBoxSize(content);\n    return Math.round((estimatedBoxSize / MAX_BOX_SIZE) * 100);\n}\n\n/**\n * Get detailed size breakdown for debugging\n */\nexport function getBoxSizeBreakdown(content: ProjectContent): {\n    baseOverhead: number;\n    ergoTree: number;\n    tokens: number;\n    r4: number;\n    r5: number;\n    r6: number;\n    r7: number;\n    r8: number;\n    r9: number;\n    margin: number;\n    total: number;\n} {\n    const r9Content = calculateProjectContentBytes(content);\n    const registerSizes = calculateRegisterSizesEstimate();\n    const r8Size = calculateR8Size();\n\n    return {\n        baseOverhead: 60,\n        ergoTree: getErgoTreeSize(),\n        tokens: 40 * 3,\n        r4: registerSizes.r4,\n        r5: registerSizes.r5,\n        r6: registerSizes.r6,\n        r7: registerSizes.r7,\n        r8: r8Size,\n        r9: r9Content + 1, // +1 for register overhead\n        margin: 120,\n        total: estimateCompleteBoxSize(content)\n    };\n}\n","path":null,"size_bytes":10637,"size_tokens":null},"src/app.css":{"content":"@tailwind base;\n@tailwind components;\n@tailwind utilities;\n \n@layer base {\n  :root {\n    --background: 0 0% 100%;\n    --foreground: 0 0% 3.9%;\n    --card: 0 0% 100%;\n    --card-foreground: 0 0% 3.9%;\n    --popover: 0 0% 100%;\n    --popover-foreground: 0 0% 3.9%;\n    --primary: 0 0% 9%;\n    --primary-foreground: 0 0% 98%;\n    --secondary: 0 0% 96.1%;\n    --secondary-foreground: 0 0% 9%;\n    --muted: 0 0% 96.1%;\n    --muted-foreground: 0 0% 45.1%;\n    --accent: 0 0% 96.1%;\n    --accent-foreground: 0 0% 9%;\n    --destructive: 0 72.22% 50.59%;\n    --destructive-foreground: 0 0% 98%;\n    --border: 0 0% 89.8%;\n    --input: 0 0% 89.8%;\n    --ring: 0 0% 3.9%;\n    --radius: 0.75rem;\n\n    --footer-bg-color: hsl(0 0% 100% / 0.8);\n    --footer-border-color: hsl(0 0% 0% / 0.1);\n  }\n\n  .dark {\n    --background: 0 0% 3.9%;\n    --foreground: 0 0% 98%;\n    --card: 0 0% 3.9%;\n    --card-foreground: 0 0% 98%;\n    --popover: 0 0% 3.9%;\n    --popover-foreground: 0 0% 98%;\n    --primary: 0 0% 98%;\n    --primary-foreground: 0 0% 9%;\n    --secondary: 0 0% 14.9%;\n    --secondary-foreground: 0 0% 98%;\n    --muted: 0 0% 14.9%;\n    --muted-foreground: 0 0% 63.9%;\n    --accent: 0 0% 14.9%;\n    --accent-foreground: 0 0% 98%;\n    --destructive: 0 62.8% 30.6%;\n    --destructive-foreground: 0 0% 98%;\n    --border: 0 0% 14.9%;\n    --input: 0 0% 14.9%;\n    --ring: 0 0% 83.1%;\n\n    --footer-bg-color: hsl(0 0% 3.9% / 0.8);\n    --footer-border-color: hsl(0 0% 100% / 0.1);\n  }\n}\n \n@layer base {\n  * {\n    @apply border-border;\n  }\n  body {\n    @apply bg-background text-foreground;\n  }\n}","path":null,"size_bytes":1573,"size_tokens":null},"src/lib/components/ui/textarea/index.ts":{"content":"import Root from \"./textarea.svelte\";\n\ntype FormTextareaEvent<T extends Event = Event> = T & {\n\tcurrentTarget: EventTarget & HTMLTextAreaElement;\n};\n\ntype TextareaEvents = {\n\tblur: FormTextareaEvent<FocusEvent>;\n\tchange: FormTextareaEvent<Event>;\n\tclick: FormTextareaEvent<MouseEvent>;\n\tfocus: FormTextareaEvent<FocusEvent>;\n\tkeydown: FormTextareaEvent<KeyboardEvent>;\n\tkeypress: FormTextareaEvent<KeyboardEvent>;\n\tkeyup: FormTextareaEvent<KeyboardEvent>;\n\tmouseover: FormTextareaEvent<MouseEvent>;\n\tmouseenter: FormTextareaEvent<MouseEvent>;\n\tmouseleave: FormTextareaEvent<MouseEvent>;\n\tpaste: FormTextareaEvent<ClipboardEvent>;\n\tinput: FormTextareaEvent<InputEvent>;\n};\n\nexport {\n\tRoot,\n\t//\n\tRoot as Textarea,\n\ttype TextareaEvents,\n\ttype FormTextareaEvent,\n};\n","path":null,"size_bytes":762,"size_tokens":null},"src/lib/ergo/forum/store.ts":{"content":"import { writable } from 'svelte/store';\nimport { type ReputationProof, type TypeNFT } from './object';\n\nexport const address = writable<string|null>(null);\nexport const network = writable<string|null>(null);\nexport const connected = writable<boolean>(false);\nexport const balance = writable<number|null>(null);\n\n// App logic stores\nexport const compute_deep_level = writable<number>(5);\nexport const searchStore = writable<string|null>(null);\nexport const data_store = writable<any | null>(null);\nexport const types = writable<Map<string, TypeNFT>>(new Map());\n\n// Main store for holding fetched reputation proofs, keyed by token ID.\nexport const proofs = writable<Map<string, ReputationProof>>(new Map());\nexport const reputation_proof = writable<ReputationProof | null>(null);\n\nexport const viewMode = writable<'nested' | 'forum'>('forum');","path":null,"size_bytes":843,"size_tokens":null},"src/lib/components/ui/calendar/index.ts":{"content":"import Root from \"./calendar.svelte\";\nimport Cell from \"./calendar-cell.svelte\";\nimport Day from \"./calendar-day.svelte\";\nimport Grid from \"./calendar-grid.svelte\";\nimport Header from \"./calendar-header.svelte\";\nimport Months from \"./calendar-months.svelte\";\nimport GridRow from \"./calendar-grid-row.svelte\";\nimport Heading from \"./calendar-heading.svelte\";\nimport GridBody from \"./calendar-grid-body.svelte\";\nimport GridHead from \"./calendar-grid-head.svelte\";\nimport HeadCell from \"./calendar-head-cell.svelte\";\nimport NextButton from \"./calendar-next-button.svelte\";\nimport PrevButton from \"./calendar-prev-button.svelte\";\n\nexport {\n\tDay,\n\tCell,\n\tGrid,\n\tHeader,\n\tMonths,\n\tGridRow,\n\tHeading,\n\tGridBody,\n\tGridHead,\n\tHeadCell,\n\tNextButton,\n\tPrevButton,\n\t//\n\tRoot as Calendar,\n};\n","path":null,"size_bytes":779,"size_tokens":null},"src/lib/common/error-utils.ts":{"content":"\nexport function formatTransactionError(error: any): string {\n    const errorMessage = error?.message || String(error);\n\n    // Common patterns for double spending or box spent errors in Ergo/FleetSDK\n    const doubleSpendKeywords = [\n        \"Input box already spent\",\n        \"Double spend\",\n        \"Box not found\", // Sometimes happens if box is spent and indexer hasn't caught up\n        \"Inputs are not valid\"\n    ];\n\n    const isDoubleSpend = doubleSpendKeywords.some(keyword =>\n        errorMessage.includes(keyword)\n    );\n\n    if (isDoubleSpend) {\n        return \"Transaction failed due to double spending (someone else might have interacted with the box at the same time). Please try again.\";\n    }\n\n    return `An unexpected error occurred. Please try again or contact the community/developers on Discord or Telegram for assistance. Error details: ${errorMessage}`;\n}\n","path":null,"size_bytes":880,"size_tokens":null},"src/lib/common/utils.ts":{"content":"// Function to convert a string to an ArrayBuffer\nfunction stringToArrayBuffer(str: string): ArrayBuffer {\n    const encoder = new TextEncoder();\n    return encoder.encode(str).buffer;\n}\n\n// Function to convert an ArrayBuffer to a hexadecimal string\nfunction arrayBufferToHex(buffer: ArrayBuffer): string {\n    const byteArray = new Uint8Array(buffer);\n    return Array.from(byteArray)\n        .map(byte => byte.toString(16).padStart(2, '0'))\n        .join('');\n}\n\n// Function to compute SHA-256 hash\nexport async function sha256(input: string): Promise<string> {\n    const data = stringToArrayBuffer(input);\n    const hashBuffer = await crypto.subtle.digest('SHA-256', data);\n    return arrayBufferToHex(hashBuffer);\n}","path":null,"size_bytes":719,"size_tokens":null},"src/routes/+layout.ts":{"content":"export const ssr = false;\nexport const prerender = true;","path":null,"size_bytes":56,"size_tokens":null},"src/lib/ergo/forum/commentObject.ts":{"content":"export interface Comment {\n    id: string; // Box ID of the comment.\n    discussion: string;  // Discussion ID  (any invented ID, in case of Bounty or Bene, is the project ID)\n    authorProfileTokenId: string; // Reputation proof token ID (profile ID)\n    text: string;\n    timestamp: number;  // Timestamp of the height of the box.\n    isSpam: boolean;\n    replies: Comment[];\n    tx: string|null;\n    posting: boolean;\n    sentiment: boolean;\n}\n\n/**\n * Returns the base sentiment value of a comment.\n * +1 for positive (true)\n * -1 for negative (false)\n * 0 if it's spam (which nullifies the score of that branch)\n */\nfunction getSentimentValue(comment: Comment): number {\n    if (comment.isSpam) {\n        return 0;\n    }\n    return comment.sentiment ? 1 : -1;\n}\n\n/**\n * Calculates the score of a comment based on your specific rules.\n *\n * The score of a comment 'C' is the sum of the \"contributions\"\n * from each of its replies 'R'.\n *\n * - If 'R' has no replies (it's a leaf node, N2): Its contribution is V(R).\n * - If 'R' has replies (it's a branch, N1): Its contribution is V(R) + Score(R)\n * or V(R) - Score(R), depending on the sentiment of R.\n */\nexport function getScore(comment: Comment): number {\n    let totalScore = 0;\n\n    // We iterate over all direct replies (R) of the comment (C)\n    for (const reply of comment.replies) {\n        \n        const replyValue = getSentimentValue(reply);\n\n        // If the reply is spam, it contributes nothing and we stop.\n        if (replyValue === 0) {\n            continue;\n        }\n\n        // CASE 1: The 'reply' (R) does NOT have its own replies.\n        // (e.g., 'reply' is N2, and 'comment' is N1)\n        // Its contribution to the score of 'comment' is\n        // simply its value.\n        if (reply.replies.length === 0) {\n            totalScore += replyValue;\n        }\n        \n        // CASE 2: The 'reply' (R) DOES have replies.\n        // (e.g., 'reply' is N1, and 'comment' is N0)\n        else {\n            // 1. We recursively calculate the score of the reply.\n            //    (We call getScore(N1), which will calculate the sum of V(N2))\n            const replyScore = getScore(reply);\n\n            // 2. We apply your special logic based on the sentiment of 'reply' (N1)\n            if (replyValue === 1) { // If N1 is Positive\n                totalScore += replyValue + replyScore;\n            } \n            else if (replyValue === -1) { // If N1 is Negative\n                totalScore += replyValue - replyScore;\n            }\n            // (If replyValue is 0 (spam), we already skipped it above)\n        }\n    }\n\n    return totalScore;\n}\n","path":null,"size_bytes":2624,"size_tokens":null},"src/lib/ergo/fetch.ts":{"content":"import { type Box, SAFE_MIN_BOX_VALUE } from \"@fleet-sdk/core\";\nimport { type ConstantContent, type Project, type TokenEIP4, getConstantContent, getProjectContent } from \"../common/project\";\nimport { ErgoPlatform } from \"./platform\";\nimport { hexToUtf8 } from \"./utils\";\nimport { type contract_version, get_template_hash } from \"./contract\";\nimport { explorer_uri, projects } from \"$lib/common/store\";\nimport { get } from \"svelte/store\";\n\nconst expectedSigmaTypesV1 = {\n    R4: 'SInt',\n    R5: 'SLong',\n    R6: 'Coll[SLong]',\n    R7: 'SLong',\n    R8: 'Coll[SByte]',\n    R9: 'Coll[SByte]'\n};\n\nconst expectedSigmaTypesV2 = {\n    R4: '(SBoolean, SLong)',\n    R5: 'SLong',\n    R6: 'Coll[SLong]',\n    R7: 'SLong',\n    R8: 'Coll[Coll[SByte]]',\n    R9: 'Coll[SByte]'\n};\n\n// Cache duration (e.g. 5 minutes)\nconst CACHE_DURATION_MS = 1000 * 60 * 5;\n\n// Variable to track an ongoing request\nlet inFlightFetch: Promise<Map<string, Project>> | null = null;\n\nfunction hasValidSigmaTypes(additionalRegisters: any, version: contract_version): boolean {\n    const expectedTypes = version === \"v2\" ? expectedSigmaTypesV2 : expectedSigmaTypesV1;\n    for (const [key, expectedType] of Object.entries(expectedTypes)) {\n        if (additionalRegisters[key] && additionalRegisters[key].sigmaType !== expectedType) {\n            return false;\n        }\n    }\n    return true;\n}\n\nexport async function fetch_token_details(id: string): Promise<TokenEIP4> {\n    console.log(\"Fetching token details for \", id);\n    const url = get(explorer_uri) + '/api/v1/tokens/' + id;\n    const response = await fetch(url, {\n        method: 'GET',\n    });\n\n    try {\n        if (response.ok) {\n            let json_data = await response.json();\n            if (json_data['type'] == 'EIP-004') {\n                return {\n                    \"name\": json_data['name'],\n                    \"description\": json_data['description'],\n                    \"decimals\": json_data['decimals'],\n                    \"emissionAmount\": json_data['emissionAmount']\n                }\n            }\n            else if (json_data['type'] == null) {\n                return {\n                    \"name\": id.slice(0, 6),\n                    \"description\": \"\",\n                    \"decimals\": 0,\n                    \"emissionAmount\": json_data['emissionAmount']\n                }\n            }\n        }\n    } catch { }\n    return {\n        'name': 'token',\n        'description': \"\",\n        'decimals': 0,\n        'emissionAmount': null\n    };\n}\n\nexport async function wait_until_confirmation(tx_id: string): Promise<Box | null> {\n    const url = get(explorer_uri) + '/api/v1/transactions/' + tx_id;\n\n    // Wait for 90 seconds before retrying\n    await new Promise(resolve => setTimeout(resolve, 90000));\n\n    const startTime = Date.now();\n\n    while (true) {\n        try {\n            // Perform GET request to fetch transaction details\n            const response = await fetch(url, {\n                method: 'GET',\n            });\n\n            if (response.ok) {\n                const json_data = await response.json();\n\n                // Check if numConfirmations is greater than 0\n                if (json_data.numConfirmations > 0) {\n                    let e = json_data['outputs'][0];\n                    return {\n                        boxId: e.boxId,\n                        value: e.value,\n                        assets: e.assets,\n                        ergoTree: e.ergoTree,\n                        creationHeight: e.creationHeight,\n                        additionalRegisters: Object.entries(e.additionalRegisters).reduce((acc, [key, value]) => {\n                            acc[key] = (value as any).serializedValue;\n                            return acc;\n                        }, {} as {\n                            [key: string]: string;\n                        }),\n                        index: e.index,\n                        transactionId: e.transactionId\n                    };\n                }\n            } else {\n                //  console.log(`Error fetching transaction: ${response.statusText}`);\n            }\n        } catch (error) {\n            //  console.log(`Error during fetch: ${error}`);\n        }\n\n        // Check if 15 minutes have passed\n        if (Date.now() - startTime > 15 * 60 * 1000) {\n            return null;\n        }\n\n        // Wait for 5 seconds before retrying\n        await new Promise(resolve => setTimeout(resolve, 5000));\n    }\n}\n\n// Internal function for fetching projects from blockchain\nexport async function fetchProjectsFromBlockchain() {\n    console.log(\"Fetch projects from blockchain\");\n    const registers = {};\n    let moreDataAvailable;\n\n    const versions: contract_version[] = [\"v2\", \"v1_1\", \"v1_0\"];\n\n    try {\n        for (const version of versions) {\n            moreDataAvailable = true;\n            let params = {\n                offset: 0, // Starts at 0 for each version\n                limit: 100, // Increased limit for fewer requests\n            };\n\n            let template = get_template_hash(version);\n\n            while (moreDataAvailable) {\n                const url = get(explorer_uri) + '/api/v1/boxes/unspent/search';\n                const response = await fetch(url + '?' + new URLSearchParams({\n                    offset: params.offset.toString(),\n                    limit: params.limit.toString(),\n                }), {\n                    method: 'POST',\n                    headers: { 'Content-Type': 'application/json' },\n                    body: JSON.stringify({\n                        \"ergoTreeTemplateHash\": template,\n                        \"registers\": registers,\n                        \"constants\": {},\n                        \"assets\": []\n                    }),\n                });\n\n                if (!response.ok) {\n                    console.error('Error while making the POST request');\n                    moreDataAvailable = false; // Stop loop on error\n                    break;\n                }\n\n                const json_data = await response.json();\n\n                if (!json_data.items || json_data.items.length === 0) {\n                    moreDataAvailable = false;\n                    break;\n                }\n\n                for (const e of json_data.items) {\n                    if (hasValidSigmaTypes(e.additionalRegisters, version)) {\n                        let constants: ConstantContent | null = null;\n\n                        if (version === \"v1_0\" || version === \"v1_1\") {\n                            constants = getConstantContent(hexToUtf8(e.additionalRegisters.R8.renderedValue) ?? \"\");\n                            if (constants === null) { console.warn(\"constants null\"); continue; }\n                        }\n                        else {\n                            try {\n                                if (!e.additionalRegisters.R8) throw new Error(\"R8 missing\");\n\n                                // Parse R8 using regex/split as requested, handling brackets, quotes, and spaces\n                                const rawValues = e.additionalRegisters.R8.renderedValue\n                                    .replace(/[\\[\\]\"'\\s]/g, \"\")\n                                    .split(\",\")\n                                    .filter((s: string) => s.length > 0);\n\n                                console.log(rawValues)\n                                if (rawValues.length < 3) throw new Error(\"Insufficient R8 constants\");\n\n                                constants = {\n                                    owner: rawValues[0],\n                                    dev_hash: rawValues[1],\n                                    dev_fee: parseInt(rawValues[2], 16),\n                                    pft_token_id: rawValues[3],\n                                    base_token_id: rawValues[4] ?? \"\",\n                                    raw: e.additionalRegisters.R8.serializedValue\n                                };\n                            } catch (err) {\n                                console.warn(\"Failed to parse R8 constants\", err);\n                                continue;\n                            }\n                        }\n\n                        let project_id = e.assets[0].tokenId;\n                        let token_id = constants.pft_token_id;\n                        let [token_amount_sold, refunded_token_amount, auxiliar_exchange_counter] = JSON.parse(e.additionalRegisters.R6.renderedValue);\n\n\n                        let exchange_rate = parseInt(e.additionalRegisters.R7.renderedValue);\n                        let base_token_id = constants.base_token_id ?? \"\";\n\n                        let current_pft_amount = (e.assets.find((asset: any) => asset.tokenId === constants.pft_token_id)?.amount) ?? 0;\n                        let total_pft_amount = current_pft_amount + auxiliar_exchange_counter;\n                        let unsold_pft_amount = current_pft_amount - token_amount_sold + refunded_token_amount + auxiliar_exchange_counter;\n                        let current_erg_value = e.value - Number(SAFE_MIN_BOX_VALUE);\n                        let minimum_token_amount = parseInt(e.additionalRegisters.R5.renderedValue);\n\n\n                        let block_limit: number = 0;\n                        let is_timestamp_limit = false;\n                        if (version === \"v2\") {\n                            const r4Value = JSON.parse(e.additionalRegisters.R4?.renderedValue.replace(/\\[([a-f0-9]+)(,.*)/, '[\"$1\"$2'));\n                            if (!Array.isArray(r4Value) || r4Value.length < 2) throw new Error(\"R4 is not a valid tuple (Type, Deadline).\");\n\n                            is_timestamp_limit = r4Value[0] === true;\n                            block_limit = Number(r4Value[1]);\n                            console.log(\"Parsed R4 for v2:\", r4Value, \"is_timestamp_limit:\", is_timestamp_limit, \"block_limit:\", block_limit);\n                        } else {\n                            block_limit = parseInt(e.additionalRegisters.R4.renderedValue);\n                        }\n\n                        let base_token_details = undefined;\n                        if (base_token_id && base_token_id !== \"\" && base_token_id !== undefined && base_token_id !== \"00\".repeat(32)) {\n                            try {\n                                base_token_details = await fetch_token_details(base_token_id);\n                            } catch (error) {\n                                console.warn(`Failed to fetch base token details for ${base_token_id}:`, error);\n                            }\n                        }\n\n                        const project: Project = {\n                            version: version,\n                            platform: new ErgoPlatform(),\n                            box: {\n                                boxId: e.boxId,\n                                value: e.value,\n                                assets: e.assets,\n                                ergoTree: e.ergoTree,\n                                creationHeight: e.creationHeight,\n                                additionalRegisters: Object.entries(e.additionalRegisters).reduce((acc, [key, value]) => {\n                                    acc[key] = (value as any).serializedValue;\n                                    return acc;\n                                }, {} as { [key: string]: string; }),\n                                index: e.index,\n                                transactionId: e.transactionId\n                            },\n                            project_id: project_id,\n                            current_idt_amount: e.assets[0].amount,\n                            pft_token_id: constants.pft_token_id,\n                            base_token_id: base_token_id,\n                            base_token_details: base_token_details,\n                            block_limit: block_limit,\n                            is_timestamp_limit: is_timestamp_limit,\n                            minimum_amount: minimum_token_amount,\n                            maximum_amount: total_pft_amount,\n                            total_pft_amount: total_pft_amount,\n                            current_pft_amount: current_pft_amount,\n                            unsold_pft_amount: unsold_pft_amount,\n                            refund_counter: refunded_token_amount,\n                            sold_counter: token_amount_sold,\n                            auxiliar_exchange_counter: auxiliar_exchange_counter,\n                            exchange_rate: exchange_rate,\n                            content: getProjectContent(\n                                token_id.slice(0, 8),\n                                hexToUtf8(e.additionalRegisters.R9.renderedValue) ?? \"\"\n                            ),\n                            constants: constants,\n                            value: e.value,\n                            current_value: current_erg_value,\n                            token_details: await fetch_token_details(token_id)\n                        };\n\n                        const current = get(projects).data;\n                        current.set(project_id, project)\n                        projects.set({ data: current, last_fetch: get(projects).last_fetch });\n                    } else {\n                        console.warn(`Box ${e.boxId} has invalid sigma types, skipping.`);\n                        console.log(e.additionalRegisters);\n                    }\n                }\n                params.offset += params.limit;\n            }\n        }\n    } catch (error) {\n        console.error('Error while making the POST request:', error);\n        return new Map(); // Returns empty map in case of error\n    }\n}\n\nexport async function fetchProjects(force: boolean = false): Promise<Map<string, Project>> {\n\n    const current = get(projects);\n\n    // 1. Return cached data if valid and not forced\n    if (!force && (Date.now() - current.last_fetch < CACHE_DURATION_MS)) {\n        return current.data;\n    }\n\n    // 2. If a request is in progress, return its promise\n    if (inFlightFetch) {\n        return inFlightFetch;\n    }\n\n    // 3. Start the fetch operation\n    inFlightFetch = (async () => {\n        try {\n            if (force) {\n                console.log(\"[fetchProjects] Forcing reload, clearing store...\");\n                projects.set({ data: new Map(), last_fetch: Date.now() });\n            } else {\n                projects.update(current => ({ ...current, last_fetch: Date.now() }));\n            }\n\n            await fetchProjectsFromBlockchain();\n\n            return get(projects).data;\n\n        } catch (error) {\n            console.error(\"Critical error during fetchProjects:\", error);\n            // In case of error, return the data we had before the failure\n            return get(projects).data;\n        } finally {\n            // 4. Release the lock for future requests\n            inFlightFetch = null;\n        }\n    })();\n\n    return inFlightFetch;\n}","path":null,"size_bytes":14911,"size_tokens":null},"README.md":{"content":"# Bene: Decentralized Fundraising Platform\n\n![Logo](static/favicon.png)\n\n## ðŸŒŸ Overview\n\n**Bene** is a decentralized application (DApp) on the Ergo blockchain designed for **Proof-of-Funding** fundraising. Its purpose is to eliminate the need for trust in a counterparty, using smart contracts to ensure that projects can only access funds if they meet a predefined minimum goal.\n\n### ðŸ”’ Serverless Architecture: Sovereignty and Local Execution\nA fundamental feature of Bene is its **100% Client-Side** architecture:\n* **No Backend:** The platform does not use central servers or private databases. Everything runs locally in your browser.\n* **Direct Connection:** You choose which public node or explorer to connect to. The application reads and writes directly to the Ergo blockchain.\n* **Censorship Resistance:** By not relying on proprietary servers, the interface is resilient and truly decentralized.\n* **The Contract is the Rule:** Business logic and fund custody reside exclusively in the immutable smart contract.\n\n---\n\n## ðŸ“– Guide for Users (Contributors)\n\nThis section details the lifecycle of your contribution and the guarantees offered by the contract.\n\n### Key Concepts: The Two Tokens\n\nThe platform uses a dual-token system to ensure traceability and internal accounting:\n\n1.  **APT (Auxiliary Project Token):**\n    * **Function:** This is your **temporary deposit receipt**. It is used to track and measure your contribution to this specific campaign.\n    * **Mechanism:** Upon purchase, you receive APTs. These APTs are your key to the future: you either exchange them for the real token (PFT) or use them to claim your refund.\n\n2.  **PFT (Proof-funding Token):**\n    * **Function:** This is the **real project participation token** (governance, shares, utility, etc.).\n    * **Distribution:** PFTs are released from the contract and distributed **only after** the campaign is declared successful.\n\n### Detailed Contribution Flow\n\n#### 1. Participation and Fund Locking\n* When you contribute (in ERG or Base Token), the contract acts as an *escrow* guarantee deposit.\n* The contract receives your funds and issues the corresponding amount of **APTs** based on the price (`R7`).\n* **Guarantee:** Both your funds and the project's PFTs remain **locked** in the contract box until the Deadline is met or the Minimum Goal is reached.\n\n#### 2. Campaign Resolution (Outcome Determination)\n\n| Outcome | Unlock Conditions | Required Action (User) |\n| :--- | :--- | :--- |\n| **Success** | Net Sales **>= Minimum Goal** (`R5`). | **Exchange:** Swap your APTs for PFTs. |\n| **Failure** | **Deadline Expired** (`R4`) **AND** Net Sales **< Minimum Goal** (`R5`). | **Guaranteed Refund:** Return your APTs to receive **100%** of your original funds. |\n\n#### 3. Community Interaction and Comments\nEach project integrates a decentralized discussion forum.\n* **Fully On-Chain:** All comments and discussions are recorded directly on the Ergo blockchain, ensuring no one can censor the project discussion.\n* **Protocol:** This system is based on the open reputation protocol, ensuring the permanence and transparency of interactions.\n* *More information:* [Reputation Systems Forum Protocol](https://github.com/reputation-systems/forum-application)\n\n---\n\n## ðŸ—ï¸ Guide for Creators (Project Owners)\n\nThis section covers setup, costs, and campaign management.\n\n### Requirements and Initial Setup\nYou only need to prepare **one asset** before launch:\n* **Project Token (PFT):** You must have the total amount of tokens you plan to sell already minted and available.\n* **APT:** The Auxiliary Token (APT), necessary for contract accounting, is **automatically generated** by the platform when you set up the contract box.\n\n### Costs and Fees\nBene applies a \"shared success\" model:\n* **Developer Fee:** **5%** of the funds raised.\n* **Condition:** This fee is **only charged if the campaign is successful** and you withdraw the funds. If the campaign fails and users request a refund, the platform does not charge anything.\n\n### Critical Parameters\nWhen creating the campaign, the following parameters are immutably recorded in the contract:\n* **Minimum Goal (`R5`):** The threshold that determines success. If exceeded, fund withdrawal is enabled and refunds are blocked.\n* **Deadline (`R4`):** Defines when the \"guaranteed refund\" period ends. Users can only request a refund if this date has passed and the goal was not met.\n* **Base Token:** Flexibility to choose between ERG or a specific token ID for the fundraising (e.g., a stablecoin).\n\n### Fund Management\n\n| Action | Condition | Management Implication |\n| :--- | :--- | :--- |\n| **Withdraw Funds** | Success (Minimum Goal reached). | The contract automatically executes the fee split: 95% to the owner, 5% to the developer. |\n| **Withdraw Unsold Tokens (Stock)** | Available at any time. | Allows the owner to recover the *surplus stock* of PFTs that have not yet been sold, while maintaining the security invariant. |\n| **Add Stock (PFT)** | At any time. | Allows increasing the total PFT supply available for sale to extend the campaign or meet higher demand. |\n\n---\n\n## âš™ï¸ Technical Guide (Detailed Architecture)\n\nThis section is for developers and auditors who wish to understand the inner workings of the `contract_v2.es`.\n\n### Token Dynamics and Accounting\n\n#### 1. The Dual Nature of the APT\nThe APT has two roles, reflected in its total supply (`PFT Supply + 1`):\n* **NFT Unit:** One unit of APT always remains in the box (`R1`) as a unique identifier (similar to an NFT) associating the contract with the project.\n* **Circulating Supply:** The remaining units of APT act as contribution receipts, ensuring traceability.\n\n#### 2. Security Invariant\nThe core of fund protection is the following invariant: **The contract must always maintain enough PFTs to cover all circulating APTs that have not yet been exchanged.**\n\n* $PFT_{in\\_box} \\ge APT_{in\\_circulation}$\n* This invariant is rigorously applied in the **Withdraw Unsold Tokens** logic, ensuring the owner cannot withdraw PFTs if it jeopardizes the contract's ability to redeem users' APTs.\n\n#### 3. Multi-Token Support\nThe contract handles payment token flexibility using Register `R8`:\n* If the `base_token_id` field in `R8` is empty, the contract assumes fundraising is in **ERG**.\n* If `base_token_id` contains a token ID, all price calculations (`R7`) and refunds are based on that specific token.\n\n### Complete Register Specification (Registers)\n\n| Register | Type | Functional Description |\n| :--- | :--- | :--- |\n| **R4** | `(Boolean, Long)` | **Temporal Limit.** Defines the expiration time for refunds (Block Height or Timestamp). |\n| **R5** | `Long` | **Success Threshold.** Minimum number of tokens to be sold. |\n| **R6** | `Coll[Long]` | **Counters:** [0] Tokens Sold, [1] Tokens Refunded, [2] APTs Exchanged for PFTs. |\n| **R7** | `Long` | **Price.** Exchange rate (Base Token per PFT). |\n| **R8** | `Coll[Coll[Byte]]` | **Immutable Configuration:** Owner's Script, Fee address Hash, **Fee Percentage (5%)**, PFT ID, and Base Token ID. |\n| **R9** | `Coll[Byte]` | **Metadata.** Descriptive project information (JSON). |\n\n---\n\n## ðŸš€ Installation and Development\n\nAs a *client-side* application, you can run it locally without third-party dependencies, connecting to your preferred node.\n\n### Requirements\n* Node.js v20+\n* Git\n\n### Steps\n1.  **Clone the Repository:**\n    ```bash\n    git clone [https://github.com/StabilityNexus/BenefactionPlatform-Ergo](https://github.com/StabilityNexus/BenefactionPlatform-Ergo)\n    cd BenefactionPlatform-Ergo\n    ```\n\n2.  **Install Dependencies:**\n    ```bash\n    npm install\n    ```\n\n3.  **Run the Local Development Server:**\n    ```bash\n    npm run dev\n    ```\n\nYou can access the deployed version at: [BenefactionPlatform-Ergo](https://stabilitynexus.github.io/BenefactionPlatform-Ergo/)","path":null,"size_bytes":7876,"size_tokens":null},"vitest.config.ts":{"content":"import { defineConfig } from 'vitest/config';\nimport path from 'path';\n\nexport default defineConfig({\n  test: {\n    include: ['tests/**/*.test.ts'],\n    exclude: ['web/**', 'node_modules/**', '.svelte-kit/**'],\n    globals: true,\n    environment: 'node',\n  },\n  resolve: {\n    alias: {\n      $lib: path.resolve(__dirname, './src/lib'),\n    },\n  },\n});","path":null,"size_bytes":351,"size_tokens":null},"src/lib/ergo/utils.ts":{"content":"import { ErgoAddress, SByte, SColl, SConstant, SGroupElement } from \"@fleet-sdk/core\";\nimport { stringToBytes } from \"@scure/base\";\nimport { connected } from \"../common/store\";\nimport { get } from \"svelte/store\";\n\nexport function serializedToRendered(serializedValue: string): string {\n    // Assuming the serialized value always starts with a pattern to strip (e.g., '0e')\n    const patternToStrip = '0e';\n    if (serializedValue.startsWith(patternToStrip)) {\n        // Remove the pattern and return the hex string\n        return serializedValue.substring(patternToStrip.length).substring(2);\n    } else {\n        // If the pattern does not exist at the start, return the original string\n        return serializedValue.substring(2);\n    }\n}\n\nexport function hexToUtf8(hexString: string): string | null {\n    try {\n        if (hexString.length % 2 !== 0) {\n            return null;\n        }\n    \n        // Convierte la cadena hexadecimal a un array de bytes\n        const byteArray = new Uint8Array(hexString.match(/.{1,2}/g)!.map(byte => parseInt(byte, 16)));\n    \n        // Crea un nuevo TextDecoder para convertir el array de bytes a una cadena UTF-8\n        const decoder = new TextDecoder('utf-8');\n        const utf8String = decoder.decode(byteArray);\n    \n        return utf8String;\n    } catch {\n        return null;\n    }\n  }\n\nexport function generate_pk_proposition(wallet_pk: string): string {\n    const pk = ErgoAddress.fromBase58(wallet_pk).getPublicKeys()[0];\n    const encodedProp = SGroupElement(pk);\n    return encodedProp.toHex();\n}\n\nexport function SString(value: string): string {\n    return SConstant(SColl(SByte, stringToBytes('utf8', value)));\n}\n\nexport function stringToRendered(value: string): string {\n    return serializedToRendered(SString(value));\n}\n\nexport async function is_local_addr(value: string): Promise<boolean> {\n    if (!get(connected)) return false;\n    return stringToRendered(generate_pk_proposition((await ergo.get_change_address()))).substring(4,) === stringToRendered(value);\n}\n\nexport function uint8ArrayToHex(array: Uint8Array): string { \n    return [...new Uint8Array(array)]\n        .map(x => x.toString(16).padStart(2, '0'))\n        .join('');\n  }","path":null,"size_bytes":2201,"size_tokens":null},"tests/contracts/withdraw_funds.test.ts":{"content":"import { describe, it, expect, beforeEach } from \"vitest\";\nimport { Box, OutputBuilder, TransactionBuilder, RECOMMENDED_MIN_FEE_VALUE, Amount, TokenAmount, TokensCollection, SAFE_MIN_BOX_VALUE, ErgoAddress, ErgoTree } from \"@fleet-sdk/core\";\nimport { SByte, SColl, SInt, SLong } from \"@fleet-sdk/serializer\";\nimport { stringToBytes } from \"@scure/base\";\nimport { compile } from \"@fleet-sdk/compiler\";\nimport { setupBeneTestContext, ERG_BASE_TOKEN, ERG_BASE_TOKEN_NAME, type BeneTestContext, USD_BASE_TOKEN, USD_BASE_TOKEN_NAME, createR4 } from \"./bene_contract_helpers\";\nimport { OneOrMore } from \"@fleet-sdk/common\";\n\n// EXECUTION FLOW:\n// Owner can withdraw raised funds if minimum reached (split: project + dev fee)\n\nconst baseModes = [\n  { name: \"USD Token Mode\", token: USD_BASE_TOKEN, tokenName: USD_BASE_TOKEN_NAME },\n  { name: \"ERG Mode\", token: ERG_BASE_TOKEN, tokenName: ERG_BASE_TOKEN_NAME },\n];\n\ndescribe.each(baseModes)(\"Bene Contract v1.2 - Withdraw funds (%s)\", (mode) => {\n  let ctx: BeneTestContext;  // Test environment\n  let projectBox: Box;  // Contract box\n  let soldTokens: bigint;\n  let collectedFunds: bigint;\n\n  describe(\"Withdraw funds after minimum reached\", () => {\n    beforeEach(() => {\n\n      // Initialize test context with BASE_TOKEN (see bene_contract_helpers.ts to change)\n      ctx = setupBeneTestContext(mode.token, mode.tokenName);\n\n      // STEP 1: Fund project owner with ERG for transaction fees\n      ctx.projectOwner.addBalance({ nanoergs: 10_000_000_000n });  // 10 ERG for fees\n\n      // STEP 2: Create project box with MINIMUM REACHED (successful campaign)\n      soldTokens = ctx.minimumTokensSold;              // minimum reached\n      collectedFunds = soldTokens * ctx.exchangeRate;\n\n      let assets = [\n        { tokenId: ctx.projectNftId, amount: 1n + ctx.totalPFTokens - soldTokens },\n        // { tokenId: ctx.pftTokenId, amount: ctx.totalPFTokens },   There are no PFTs on contract.  All PFT were exchanged with their respectives APTs\n      ];\n\n      let value = SAFE_MIN_BOX_VALUE;\n\n      if (!ctx.isErgMode) {\n        assets.push({ tokenId: ctx.baseTokenId, amount: collectedFunds })\n      }\n      else {\n        value += collectedFunds;\n        collectedFunds = value;  // Must be divided considering SAFE_MIN_BOX_VALUE too.\n      }\n\n      ctx.beneContract.addUTxOs({\n        value: value,\n        ergoTree: ctx.beneErgoTree.toHex(),\n        assets: assets,\n        creationHeight: ctx.mockChain.height - 100,\n        additionalRegisters: {\n          R4: createR4(ctx),\n          R5: SLong(ctx.minimumTokensSold).toHex(),\n          R6: SColl(SLong, [soldTokens, 0n, ctx.totalPFTokens]).toHex(),\n          R7: SLong(ctx.exchangeRate).toHex(),\n          R8: ctx.constants.toHex(),\n          R9: SColl(SByte, stringToBytes(\"utf8\", \"{}\")).toHex(),\n        },\n      });\n\n      // STEP 3: Get reference to project box\n      projectBox = ctx.beneContract.utxos.toArray()[0];\n    });\n\n    it(\"should pass full withdraw\", () => {\n\n      const devFeeAmount = (collectedFunds * BigInt(ctx.devFeePercentage)) / 100n;\n      const projectAmount = collectedFunds - devFeeAmount;\n      const devFeeContract = compile(`{ sigmaProp(true) }`);\n\n      let projectValue: bigint;\n      let projectAssets: OneOrMore<TokenAmount<Amount>> | TokensCollection;\n      let devFeeValue: bigint;\n      let devFeeAssets: OneOrMore<TokenAmount<Amount>> | TokensCollection;\n\n      if (ctx.isErgMode) {\n        projectValue = projectAmount;\n        projectAssets = [];\n\n        devFeeValue = devFeeAmount;\n        devFeeAssets = [];\n\n      } else {\n        projectValue = SAFE_MIN_BOX_VALUE;\n        projectAssets = [\n          { tokenId: ctx.baseTokenId, amount: projectAmount }\n        ];\n\n        devFeeValue = SAFE_MIN_BOX_VALUE;\n        devFeeAssets = [\n          { tokenId: ctx.baseTokenId, amount: devFeeAmount }\n        ];\n      }\n\n      // ACT: Try to withdraw funds even though minimum not reached\n      const transaction = new TransactionBuilder(ctx.mockChain.height)\n        .from([projectBox, ...ctx.projectOwner.utxos.toArray()])\n        .to([\n          // Output 0: Owner tries to receive project funds\n          new OutputBuilder(projectValue, ctx.projectOwner.address).addTokens(projectAssets),\n          // Output 1: Dev fee contract\n          new OutputBuilder(devFeeValue, devFeeContract).addTokens(devFeeAssets),\n        ])\n        .sendChangeTo(ctx.projectOwner.address)\n        .payFee(RECOMMENDED_MIN_FEE_VALUE)\n        .build();\n\n      const result = ctx.mockChain.execute(transaction, { signers: [ctx.projectOwner] });\n\n      // ASSERT: Transaction should SUCCESS (minimum reached)\n      expect(result).toBe(true);\n\n    });\n\n    it(\"should pass partial withdraw\", () => {\n\n      const remainingAmount = collectedFunds / 2n;\n      const devFeeAmount = (collectedFunds / 2n * BigInt(ctx.devFeePercentage)) / 100n;\n      const projectAmount = collectedFunds / 2n - devFeeAmount;\n      const devFeeContract = compile(`{ sigmaProp(true) }`);\n\n      let remainingValue: bigint;\n      let remainingAssets: OneOrMore<TokenAmount<Amount>> | TokensCollection;\n      let projectValue: bigint;\n      let projectAssets: OneOrMore<TokenAmount<Amount>> | TokensCollection;\n      let devFeeValue: bigint;\n      let devFeeAssets: OneOrMore<TokenAmount<Amount>> | TokensCollection;\n\n      if (ctx.isErgMode) {\n        remainingValue = remainingAmount;\n        remainingAssets = [\n          { tokenId: ctx.projectNftId, amount: projectBox.assets[0].amount },\n        ];\n\n        projectValue = projectAmount;\n        projectAssets = [];\n\n        devFeeValue = devFeeAmount;\n        devFeeAssets = [];\n\n      } else {\n        remainingValue = SAFE_MIN_BOX_VALUE;\n        remainingAssets = [\n          { tokenId: ctx.projectNftId, amount: projectBox.assets[0].amount },\n          { tokenId: ctx.baseTokenId, amount: remainingAmount }\n        ];\n\n        projectValue = SAFE_MIN_BOX_VALUE;\n        projectAssets = [\n          { tokenId: ctx.baseTokenId, amount: projectAmount }\n        ];\n\n        devFeeValue = SAFE_MIN_BOX_VALUE;\n        devFeeAssets = [\n          { tokenId: ctx.baseTokenId, amount: devFeeAmount }\n        ];\n      }\n\n      // ACT: Try to withdraw funds even though minimum not reached\n      const transaction = new TransactionBuilder(ctx.mockChain.height)\n        .from([projectBox, ...ctx.projectOwner.utxos.toArray()])\n        .to([\n          // Output 0: Self contract\n          new OutputBuilder(remainingValue, ctx.beneErgoTree)\n            .addTokens(remainingAssets)\n            .setAdditionalRegisters({\n              R4: projectBox.additionalRegisters.R4,\n              R5: SLong(ctx.minimumTokensSold).toHex(),\n              R6: SColl(SLong, [soldTokens, 0n, ctx.totalPFTokens]).toHex(),\n              R7: SLong(ctx.exchangeRate).toHex(),\n              R8: projectBox.additionalRegisters.R8,\n              R9: projectBox.additionalRegisters.R9,\n            }),\n          // Output 1: Owner tries to receive project funds\n          new OutputBuilder(projectValue, ctx.projectOwner.address).addTokens(projectAssets),\n          // Output 2: Dev fee contract\n          new OutputBuilder(devFeeValue, devFeeContract).addTokens(devFeeAssets),\n        ])\n        .sendChangeTo(ctx.projectOwner.address)\n        .payFee(RECOMMENDED_MIN_FEE_VALUE)\n        .build();\n\n      const result = ctx.mockChain.execute(transaction, { signers: [ctx.projectOwner] });\n\n      // ASSERT: Transaction should SUCCESS (minimum reached)\n      expect(result).toBe(true);\n\n    });\n\n    it(\"should fail if owner tries to get more funds\", () => {\n\n      const devFeeAmount = ((collectedFunds * BigInt(ctx.devFeePercentage)) / 100n) - 1n;\n      const projectAmount = (collectedFunds - devFeeAmount);\n      const devFeeContract = compile(`{ sigmaProp(true) }`);\n\n      let projectValue: bigint;\n      let projectAssets: OneOrMore<TokenAmount<Amount>> | TokensCollection;\n      let devFeeValue: bigint;\n      let devFeeAssets: OneOrMore<TokenAmount<Amount>> | TokensCollection;\n\n      if (ctx.isErgMode) {\n        projectValue = projectAmount;\n        projectAssets = [];\n\n        devFeeValue = devFeeAmount;\n        devFeeAssets = [];\n\n      } else {\n        projectValue = SAFE_MIN_BOX_VALUE;\n        projectAssets = [\n          { tokenId: ctx.baseTokenId, amount: projectAmount }\n        ];\n\n        devFeeValue = SAFE_MIN_BOX_VALUE;\n        devFeeAssets = [\n          { tokenId: ctx.baseTokenId, amount: devFeeAmount }\n        ];\n      }\n\n      // ACT: Try to withdraw funds even though minimum not reached\n      const transaction = new TransactionBuilder(ctx.mockChain.height)\n        .from([projectBox, ...ctx.projectOwner.utxos.toArray()])\n        .to([\n          // Output 0: Owner tries to receive project funds\n          new OutputBuilder(projectValue, ctx.projectOwner.address).addTokens(projectAssets),\n          // Output 1: Dev fee contract\n          new OutputBuilder(devFeeValue, devFeeContract).addTokens(devFeeAssets),\n        ])\n        .sendChangeTo(ctx.projectOwner.address)\n        .payFee(RECOMMENDED_MIN_FEE_VALUE)\n        .build();\n\n      const result = ctx.mockChain.execute(transaction, { signers: [ctx.projectOwner], throw: false });\n\n      // ASSERT: Transaction should SUCCESS (minimum reached)\n      expect(result).toBe(false);\n\n    });\n\n    it(\"should fail if dev tries to get more funds\", () => {\n\n      const devFeeAmount = ((collectedFunds * BigInt(ctx.devFeePercentage)) / 100n) + 1n;\n      const projectAmount = (collectedFunds - devFeeAmount);\n      const devFeeContract = compile(`{ sigmaProp(true) }`);\n\n      let projectValue: bigint;\n      let projectAssets: OneOrMore<TokenAmount<Amount>> | TokensCollection;\n      let devFeeValue: bigint;\n      let devFeeAssets: OneOrMore<TokenAmount<Amount>> | TokensCollection;\n\n      if (ctx.isErgMode) {\n        projectValue = projectAmount;\n        projectAssets = [];\n\n        devFeeValue = devFeeAmount;\n        devFeeAssets = [];\n\n      } else {\n        projectValue = SAFE_MIN_BOX_VALUE;\n        projectAssets = [\n          { tokenId: ctx.baseTokenId, amount: projectAmount }\n        ];\n\n        devFeeValue = SAFE_MIN_BOX_VALUE;\n        devFeeAssets = [\n          { tokenId: ctx.baseTokenId, amount: devFeeAmount }\n        ];\n      }\n\n      // ACT: Try to withdraw funds even though minimum not reached\n      const transaction = new TransactionBuilder(ctx.mockChain.height)\n        .from([projectBox, ...ctx.projectOwner.utxos.toArray()])\n        .to([\n          // Output 0: Owner tries to receive project funds\n          new OutputBuilder(projectValue, ctx.projectOwner.address).addTokens(projectAssets),\n          // Output 1: Dev fee contract\n          new OutputBuilder(devFeeValue, devFeeContract).addTokens(devFeeAssets),\n        ])\n        .sendChangeTo(ctx.projectOwner.address)\n        .payFee(RECOMMENDED_MIN_FEE_VALUE)\n        .build();\n\n      const result = ctx.mockChain.execute(transaction, { signers: [ctx.projectOwner], throw: false });\n\n      // ASSERT: Transaction should SUCCESS (minimum reached)\n      expect(result).toBe(false);\n\n    });\n\n    it(\"should fail if owner address is incorrect\", () => {\n\n      const devFeeAmount = ((collectedFunds * BigInt(ctx.devFeePercentage)) / 100n);\n      const projectAmount = (collectedFunds - devFeeAmount);\n      const devFeeContract = compile(`{ sigmaProp(true) }`);\n\n      let projectValue: bigint;\n      let projectAssets: OneOrMore<TokenAmount<Amount>> | TokensCollection;\n      let devFeeValue: bigint;\n      let devFeeAssets: OneOrMore<TokenAmount<Amount>> | TokensCollection;\n\n      if (ctx.isErgMode) {\n        projectValue = projectAmount;\n        projectAssets = [];\n\n        devFeeValue = devFeeAmount;\n        devFeeAssets = [];\n\n      } else {\n        projectValue = SAFE_MIN_BOX_VALUE;\n        projectAssets = [\n          { tokenId: ctx.baseTokenId, amount: projectAmount }\n        ];\n\n        devFeeValue = SAFE_MIN_BOX_VALUE;\n        devFeeAssets = [\n          { tokenId: ctx.baseTokenId, amount: devFeeAmount }\n        ];\n      }\n\n      // ACT: Try to withdraw funds even though minimum not reached\n      const transaction = new TransactionBuilder(ctx.mockChain.height)\n        .from([projectBox, ...ctx.projectOwner.utxos.toArray()])\n        .to([\n          // Output 0: Owner tries to receive project funds\n          new OutputBuilder(projectValue, compile(`{ sigmaProp(HEIGHT == 1) }`)).addTokens(projectAssets),\n          // Output 1: Dev fee contract\n          new OutputBuilder(devFeeValue, devFeeContract).addTokens(devFeeAssets),\n        ])\n        .sendChangeTo(ctx.projectOwner.address)\n        .payFee(RECOMMENDED_MIN_FEE_VALUE)\n        .build();\n\n      const result = ctx.mockChain.execute(transaction, { signers: [ctx.projectOwner], throw: false });\n\n      // ASSERT: Transaction should SUCCESS (minimum reached)\n      expect(result).toBe(false);\n\n    });\n\n    it(\"should fail if dev address is incorrect\", () => {\n\n      const devFeeAmount = ((collectedFunds * BigInt(ctx.devFeePercentage)) / 100n);\n      const projectAmount = (collectedFunds - devFeeAmount);\n      const devFeeContract = compile(`{ sigmaProp(HEIGHT == 1) }`);\n\n      let projectValue: bigint;\n      let projectAssets: OneOrMore<TokenAmount<Amount>> | TokensCollection;\n      let devFeeValue: bigint;\n      let devFeeAssets: OneOrMore<TokenAmount<Amount>> | TokensCollection;\n\n      if (ctx.isErgMode) {\n        projectValue = projectAmount;\n        projectAssets = [];\n\n        devFeeValue = devFeeAmount;\n        devFeeAssets = [];\n\n      } else {\n        projectValue = SAFE_MIN_BOX_VALUE;\n        projectAssets = [\n          { tokenId: ctx.baseTokenId, amount: projectAmount }\n        ];\n\n        devFeeValue = SAFE_MIN_BOX_VALUE;\n        devFeeAssets = [\n          { tokenId: ctx.baseTokenId, amount: devFeeAmount }\n        ];\n      }\n\n      // ACT: Try to withdraw funds even though minimum not reached\n      const transaction = new TransactionBuilder(ctx.mockChain.height)\n        .from([projectBox, ...ctx.projectOwner.utxos.toArray()])\n        .to([\n          // Output 0: Owner tries to receive project funds\n          new OutputBuilder(projectValue, ctx.projectOwner.address).addTokens(projectAssets),\n          // Output 1: Dev fee contract\n          new OutputBuilder(devFeeValue, devFeeContract).addTokens(devFeeAssets),\n        ])\n        .sendChangeTo(ctx.projectOwner.address)\n        .payFee(RECOMMENDED_MIN_FEE_VALUE)\n        .build();\n\n      const result = ctx.mockChain.execute(transaction, { signers: [ctx.projectOwner], throw: false });\n\n      // ASSERT: Transaction should SUCCESS (minimum reached)\n      expect(result).toBe(false);\n\n    });\n  });\n\n  describe(\"Withdraw funds after minimum reached. any PFT exchanged.\", () => {\n    beforeEach(() => {\n\n      // Initialize test context with BASE_TOKEN (see bene_contract_helpers.ts to change)\n      ctx = setupBeneTestContext(mode.token, mode.tokenName);\n\n      // STEP 1: Fund project owner with ERG for transaction fees\n      ctx.projectOwner.addBalance({ nanoergs: 10_000_000_000n });  // 10 ERG for fees\n\n      // STEP 2: Create project box with MINIMUM REACHED (successful campaign)\n      soldTokens = ctx.minimumTokensSold;              // minimum reached\n      collectedFunds = soldTokens * ctx.exchangeRate;\n\n      let assets = [\n        { tokenId: ctx.projectNftId, amount: 1n + ctx.totalPFTokens - soldTokens },\n        { tokenId: ctx.pftTokenId, amount: ctx.totalPFTokens },  // Any PFT exchanged\n      ];\n\n      let value = SAFE_MIN_BOX_VALUE;\n\n      if (!ctx.isErgMode) {\n        assets.push({ tokenId: ctx.baseTokenId, amount: collectedFunds })\n      }\n      else {\n        value += collectedFunds;\n        collectedFunds = value;  // Must be divided considering SAFE_MIN_BOX_VALUE too.\n      }\n\n      ctx.beneContract.addUTxOs({\n        value: value,\n        ergoTree: ctx.beneErgoTree.toHex(),\n        assets: assets,\n        creationHeight: ctx.mockChain.height - 100,\n        additionalRegisters: {\n          R4: createR4(ctx),\n          R5: SLong(ctx.minimumTokensSold).toHex(),\n          R6: SColl(SLong, [soldTokens, 0n, 0n]).toHex(),\n          R7: SLong(ctx.exchangeRate).toHex(),\n          R8: ctx.constants.toHex(),\n          R9: SColl(SByte, stringToBytes(\"utf8\", \"{}\")).toHex(),\n        },\n      });\n\n      // STEP 3: Get reference to project box\n      projectBox = ctx.beneContract.utxos.toArray()[0];\n    });\n\n    it(\"should pass partial withdraw\", () => {\n\n      const remainingAmount = collectedFunds / 2n;\n      const devFeeAmount = (collectedFunds / 2n * BigInt(ctx.devFeePercentage)) / 100n;\n      const projectAmount = collectedFunds / 2n - devFeeAmount;\n      const devFeeContract = compile(`{ sigmaProp(true) }`);\n\n      let remainingValue: bigint;\n      let remainingAssets: OneOrMore<TokenAmount<Amount>> | TokensCollection;\n      let projectValue: bigint;\n      let projectAssets: OneOrMore<TokenAmount<Amount>> | TokensCollection;\n      let devFeeValue: bigint;\n      let devFeeAssets: OneOrMore<TokenAmount<Amount>> | TokensCollection;\n\n      if (ctx.isErgMode) {\n        remainingValue = remainingAmount;\n        remainingAssets = [\n          { tokenId: ctx.projectNftId, amount: projectBox.assets[0].amount },\n          { tokenId: ctx.pftTokenId, amount: ctx.totalPFTokens },  // Any PFT exchanged\n        ];\n\n        projectValue = projectAmount;\n        projectAssets = [];\n\n        devFeeValue = devFeeAmount;\n        devFeeAssets = [];\n\n      } else {\n        remainingValue = SAFE_MIN_BOX_VALUE;\n        remainingAssets = [\n          { tokenId: ctx.projectNftId, amount: projectBox.assets[0].amount },\n          { tokenId: ctx.pftTokenId, amount: ctx.totalPFTokens },  // Any PFT exchanged\n          { tokenId: ctx.baseTokenId, amount: remainingAmount } // In that case, base token is on index 2.\n        ];\n\n        projectValue = SAFE_MIN_BOX_VALUE;\n        projectAssets = [\n          { tokenId: ctx.baseTokenId, amount: projectAmount }\n        ];\n\n        devFeeValue = SAFE_MIN_BOX_VALUE;\n        devFeeAssets = [\n          { tokenId: ctx.baseTokenId, amount: devFeeAmount }\n        ];\n      }\n\n      // ACT: Try to withdraw funds even though minimum not reached\n      const transaction = new TransactionBuilder(ctx.mockChain.height)\n        .from([projectBox, ...ctx.projectOwner.utxos.toArray()])\n        .to([\n          // Output 0: Self contract\n          new OutputBuilder(remainingValue, ctx.beneErgoTree)\n            .addTokens(remainingAssets)\n            .setAdditionalRegisters({\n              R4: projectBox.additionalRegisters.R4,\n              R5: SLong(ctx.minimumTokensSold).toHex(),\n              R6: SColl(SLong, [soldTokens, 0n, 0n]).toHex(),\n              R7: SLong(ctx.exchangeRate).toHex(),\n              R8: projectBox.additionalRegisters.R8,\n              R9: projectBox.additionalRegisters.R9,\n            }),\n          // Output 1: Owner tries to receive project funds\n          new OutputBuilder(projectValue, ctx.projectOwner.address).addTokens(projectAssets),\n          // Output 2: Dev fee contract\n          new OutputBuilder(devFeeValue, devFeeContract).addTokens(devFeeAssets),\n        ])\n        .sendChangeTo(ctx.projectOwner.address)\n        .payFee(RECOMMENDED_MIN_FEE_VALUE)\n        .build();\n\n      const result = ctx.mockChain.execute(transaction, { signers: [ctx.projectOwner] });\n\n      // ASSERT: Transaction should SUCCESS (minimum reached)\n      expect(result).toBe(true);\n\n    });\n  });\n\n  describe(\"Withdraw funds after minimum reached. complex owner contract.\", () => {\n    let ownerContract: ErgoTree;\n\n    beforeEach(() => {\n\n      ownerContract = compile(`{ sigmaProp(false) }`);\n\n      // Initialize test context with BASE_TOKEN (see bene_contract_helpers.ts to change)\n      ctx = setupBeneTestContext(mode.token, mode.tokenName, ownerContract.toAddress());\n\n      // STEP 1: Fund project owner with ERG for transaction fees\n      ctx.projectOwner.addBalance({ nanoergs: 10_000_000_000n });  // 10 ERG for fees\n\n      // STEP 2: Create project box with MINIMUM REACHED (successful campaign)\n      soldTokens = ctx.minimumTokensSold;              // minimum reached\n      collectedFunds = soldTokens * ctx.exchangeRate;\n\n      let assets = [\n        { tokenId: ctx.projectNftId, amount: 1n + ctx.totalPFTokens - soldTokens },\n        { tokenId: ctx.pftTokenId, amount: ctx.totalPFTokens },  // Any PFT exchanged\n      ];\n\n      let value = SAFE_MIN_BOX_VALUE;\n\n      if (!ctx.isErgMode) {\n        assets.push({ tokenId: ctx.baseTokenId, amount: collectedFunds })\n      }\n      else {\n        value += collectedFunds;\n        collectedFunds = value;  // Must be divided considering SAFE_MIN_BOX_VALUE too.\n      }\n\n      ctx.beneContract.addUTxOs({\n        value: value,\n        ergoTree: ctx.beneErgoTree.toHex(),\n        assets: assets,\n        creationHeight: ctx.mockChain.height - 100,\n        additionalRegisters: {\n          R4: createR4(ctx),\n          R5: SLong(ctx.minimumTokensSold).toHex(),\n          R6: SColl(SLong, [soldTokens, 0n, 0n]).toHex(),\n          R7: SLong(ctx.exchangeRate).toHex(),\n          R8: ctx.constants.toHex(),\n          R9: SColl(SByte, stringToBytes(\"utf8\", \"{}\")).toHex(),\n        },\n      });\n\n      // STEP 3: Get reference to project box\n      projectBox = ctx.beneContract.utxos.toArray()[0];\n    });\n\n    it(\"should pass partial withdraw\", () => {\n\n      const remainingAmount = collectedFunds / 2n;\n      const devFeeAmount = (collectedFunds / 2n * BigInt(ctx.devFeePercentage)) / 100n;\n      const projectAmount = collectedFunds / 2n - devFeeAmount;\n      const devFeeContract = compile(`{ sigmaProp(true) }`);\n\n      let remainingValue: bigint;\n      let remainingAssets: OneOrMore<TokenAmount<Amount>> | TokensCollection;\n      let projectValue: bigint;\n      let projectAssets: OneOrMore<TokenAmount<Amount>> | TokensCollection;\n      let devFeeValue: bigint;\n      let devFeeAssets: OneOrMore<TokenAmount<Amount>> | TokensCollection;\n\n      if (ctx.isErgMode) {\n        remainingValue = remainingAmount;\n        remainingAssets = [\n          { tokenId: ctx.projectNftId, amount: projectBox.assets[0].amount },\n          { tokenId: ctx.pftTokenId, amount: ctx.totalPFTokens },  // Any PFT exchanged\n        ];\n\n        projectValue = projectAmount;\n        projectAssets = [];\n\n        devFeeValue = devFeeAmount;\n        devFeeAssets = [];\n\n      } else {\n        remainingValue = SAFE_MIN_BOX_VALUE;\n        remainingAssets = [\n          { tokenId: ctx.projectNftId, amount: projectBox.assets[0].amount },\n          { tokenId: ctx.pftTokenId, amount: ctx.totalPFTokens },  // Any PFT exchanged\n          { tokenId: ctx.baseTokenId, amount: remainingAmount } // In that case, base token is on index 2.\n        ];\n\n        projectValue = SAFE_MIN_BOX_VALUE;\n        projectAssets = [\n          { tokenId: ctx.baseTokenId, amount: projectAmount }\n        ];\n\n        devFeeValue = SAFE_MIN_BOX_VALUE;\n        devFeeAssets = [\n          { tokenId: ctx.baseTokenId, amount: devFeeAmount }\n        ];\n      }\n\n      // ACT: Try to withdraw funds even though minimum not reached\n      const transaction = new TransactionBuilder(ctx.mockChain.height)\n        .from([projectBox, ...ctx.projectOwner.utxos.toArray()])\n        .to([\n          // Output 0: Self contract\n          new OutputBuilder(remainingValue, ctx.beneErgoTree)\n            .addTokens(remainingAssets)\n            .setAdditionalRegisters({\n              R4: projectBox.additionalRegisters.R4,\n              R5: SLong(ctx.minimumTokensSold).toHex(),\n              R6: SColl(SLong, [soldTokens, 0n, 0n]).toHex(),\n              R7: SLong(ctx.exchangeRate).toHex(),\n              R8: projectBox.additionalRegisters.R8,\n              R9: projectBox.additionalRegisters.R9,\n            }),\n          // Output 1: Owner tries to receive project funds\n          new OutputBuilder(projectValue, ownerContract).addTokens(projectAssets),\n          // Output 2: Dev fee contract\n          new OutputBuilder(devFeeValue, devFeeContract).addTokens(devFeeAssets),\n        ])\n        .sendChangeTo(ctx.projectOwner.address)\n        .payFee(RECOMMENDED_MIN_FEE_VALUE)\n        .build();\n\n      const result = ctx.mockChain.execute(transaction, { signers: [ctx.projectOwner] });\n\n      // ASSERT: Transaction should SUCCESS (minimum reached)\n      expect(result).toBe(true);\n\n    });\n  });\n\n  describe(\"Withdraw funds before minimum reached\", () => {\n\n    beforeEach(() => {\n\n      // Initialize test context with BASE_TOKEN (see bene_contract_helpers.ts to change)\n      ctx = setupBeneTestContext(mode.token, mode.tokenName);\n\n      // STEP 1: Fund project owner with ERG for transaction fees\n      ctx.projectOwner.addBalance({ nanoergs: 10_000_000_000n });  // 10 ERG for fees\n\n      // STEP 2: Create project box with MINIMUM NOT REACHED (non-successful campaign)\n      soldTokens = ctx.minimumTokensSold - 1n;              // minimum not reached\n      collectedFunds = soldTokens * ctx.exchangeRate;\n\n      let assets = [\n        { tokenId: ctx.projectNftId, amount: 1n + ctx.totalPFTokens - soldTokens },\n        // { tokenId: ctx.pftTokenId, amount: ctx.totalPFTokens },   There are no PFTs on contract.  All PFT were exchanged with their respectives APTs\n      ];\n\n      let value = SAFE_MIN_BOX_VALUE;\n\n      if (!ctx.isErgMode) {\n        assets.push({ tokenId: ctx.baseTokenId, amount: collectedFunds })\n      }\n      else {\n        value += collectedFunds;\n        collectedFunds = value;  // Must be divided considering SAFE_MIN_BOX_VALUE too.\n      }\n\n      ctx.beneContract.addUTxOs({\n        value: value,\n        ergoTree: ctx.beneErgoTree.toHex(),\n        assets: assets,\n        creationHeight: ctx.mockChain.height - 100,\n        additionalRegisters: {\n          R4: createR4(ctx),\n          R5: SLong(ctx.minimumTokensSold).toHex(),\n          R6: SColl(SLong, [soldTokens, 0n, 0n]).toHex(),\n          R7: SLong(ctx.exchangeRate).toHex(),\n          R8: ctx.constants.toHex(),\n          R9: SColl(SByte, stringToBytes(\"utf8\", \"{}\")).toHex(),\n        },\n      });\n\n      // STEP 3: Get reference to project box\n      projectBox = ctx.beneContract.utxos.toArray()[0];\n    });\n\n    it(\"should fail full withdraw\", () => {\n\n      const devFeeAmount = (collectedFunds * BigInt(ctx.devFeePercentage)) / 100n;\n      const projectAmount = collectedFunds - devFeeAmount;\n      const devFeeContract = compile(`{ sigmaProp(true) }`);\n\n      let projectValue: bigint;\n      let projectAssets: OneOrMore<TokenAmount<Amount>> | TokensCollection;\n      let devFeeValue: bigint;\n      let devFeeAssets: OneOrMore<TokenAmount<Amount>> | TokensCollection;\n\n      if (ctx.isErgMode) {\n        projectValue = projectAmount;\n        projectAssets = [];\n\n        devFeeValue = devFeeAmount;\n        devFeeAssets = [];\n\n      } else {\n        projectValue = SAFE_MIN_BOX_VALUE;\n        projectAssets = [\n          { tokenId: ctx.baseTokenId, amount: projectAmount }\n        ];\n\n        devFeeValue = SAFE_MIN_BOX_VALUE;\n        devFeeAssets = [\n          { tokenId: ctx.baseTokenId, amount: devFeeAmount }\n        ];\n      }\n\n      // ACT: Try to withdraw funds even though minimum not reached\n      const transaction = new TransactionBuilder(ctx.mockChain.height)\n        .from([projectBox, ...ctx.projectOwner.utxos.toArray()])\n        .to([\n          // Output 0: Owner tries to receive project funds\n          new OutputBuilder(projectValue, ctx.projectOwner.address).addTokens(projectAssets),\n          // Output 1: Dev fee contract\n          new OutputBuilder(devFeeValue, devFeeContract).addTokens(devFeeAssets),\n        ])\n        .sendChangeTo(ctx.projectOwner.address)\n        .payFee(RECOMMENDED_MIN_FEE_VALUE)\n        .build();\n\n      const result = ctx.mockChain.execute(transaction, { signers: [ctx.projectOwner], throw: false });\n\n      // ASSERT: Transaction should FAIL (minimum not reached)\n      expect(result).toBe(false);\n\n    });\n  });\n});\n","path":null,"size_bytes":27895,"size_tokens":null},"src/lib/ergo/forum/contract.ts":{"content":"import { compile } from \"@fleet-sdk/compiler\";\nimport { ErgoAddress, Network } from \"@fleet-sdk/core\";\nimport { sha256, hex, blake2b256 } from \"@fleet-sdk/crypto\";\n\nfunction uint8ArrayToHex(array: Uint8Array): string {\n    return [...new Uint8Array(array)]\n        .map(x => x.toString(16).padStart(2, '0'))\n        .join('');\n}\n\n// --- Explorer Configuration ---\nexport const min_erg_value = \"1000000\"; // 0.001 ERG\n\n// --- Digital Public Good (for Type NFTs) ---\n// This contract protects the Type NFT boxes, making them immutable public records.\nimport DIGITAL_PUBLIC_GOOD_SCRIPT from '../../../../contracts/forum_contract/digital_public_good.es?raw';\n\n// Compile the Digital Public Good contract\nconst digitalPublicGoodErgoTree = compile(DIGITAL_PUBLIC_GOOD_SCRIPT, { version: 1 });\nconst digitalPublicGoodErgoTreeHex = digitalPublicGoodErgoTree.toHex();\nconst digitalPublicGoodHash = hex.encode(sha256(digitalPublicGoodErgoTree.template));\n\n// Export the constant for the Type NFT contract\nexport const digital_public_good_ergo_tree = digitalPublicGoodErgoTreeHex;\nexport const digital_public_good_contract_hash = digitalPublicGoodHash;\n\n// --- Reputation Proof ---\n// This is the main contract for creating comments, replies, etc.\nimport REPUTATION_PROOF_SCRIPT from '../../../../contracts/forum_contract/reputation_proof.es?raw';\n\n// Compile the Reputation Proof contract\nconst reputationProofErgoTree = compile(REPUTATION_PROOF_SCRIPT.replace(/`\\+DIGITAL_PUBLIC_GOOD_SCRIPT_HASH\\+`/g, uint8ArrayToHex(blake2b256(digitalPublicGoodErgoTree.bytes))), { version: 1 });\n\n// Derive the P2S address and the template hash\nconst reputationProofAddress = ErgoAddress.fromErgoTree(reputationProofErgoTree.toHex(), Network.Mainnet).toString();\nconst reputationProofHash = hex.encode(sha256(reputationProofErgoTree.template));\n\n// Export constants for the Reputation Proof contract\nexport const ergo_tree_address = reputationProofAddress;\nexport const ergo_tree_hash = reputationProofHash;\nexport const ergo_tree = reputationProofErgoTree.toHex();","path":null,"size_bytes":2042,"size_tokens":null},"src/lib/common/platform.ts":{"content":"// src/common/platform.ts\nimport { type Project } from \"$lib/common/project\";\nimport { type contract_version } from \"$lib/ergo/contract\";\n\nexport interface Platform {\n    id: string;  // ergo, basis ...\n    main_token: string; // ERG, BTC ...\n    icon: string;  // Icon path or url.\n    time_per_block: number; // milliseconds\n    last_version: contract_version;\n    connect(): Promise<void>;\n    get_current_height(): Promise<number>;\n    get_balance(id?: string): Promise<Map<string, number>>;\n    withdraw(project: Project, amount: number): Promise<string | null>;\n    buy_refund(project: Project, token_amount: number): Promise<string | null>;\n    rebalance(project: Project, token_amount: number): Promise<string | null>;\n    temp_exchange(project: Project, token_amount: number): Promise<string | null>;\n    submit(\n        version: contract_version,\n        token_id: string,\n        token_amount: number,\n        blockLimit: number,\n        is_timestamp_limit: boolean,\n        exchangeRate: number,\n        projectLink: string,\n        minimumSold: number,\n        title: string,\n        base_token_id?: string\n    ): AsyncGenerator<string, string | null, void>;\n    fetch(): Promise<Map<string, Project>>;\n}\n","path":null,"size_bytes":1218,"size_tokens":null},"tests/contracts/add_tokens.test.ts":{"content":"import { describe, it, expect, beforeEach } from \"vitest\";\nimport { Box, OutputBuilder, TransactionBuilder, RECOMMENDED_MIN_FEE_VALUE, ErgoTree } from \"@fleet-sdk/core\";\nimport { SByte, SColl, SInt, SLong } from \"@fleet-sdk/serializer\";\nimport { stringToBytes } from \"@scure/base\";\nimport { setupBeneTestContext, ERG_BASE_TOKEN, ERG_BASE_TOKEN_NAME, type BeneTestContext, USD_BASE_TOKEN, USD_BASE_TOKEN_NAME, createR4 } from \"./bene_contract_helpers\";\nimport { compile } from \"@fleet-sdk/compiler\";\n\n\nconst baseModes = [\n  { name: \"USD Token Mode\", token: USD_BASE_TOKEN, tokenName: USD_BASE_TOKEN_NAME },\n  { name: \"ERG Mode\", token: ERG_BASE_TOKEN, tokenName: ERG_BASE_TOKEN_NAME },\n];\n\ndescribe.each(baseModes)(\"Bene Contract v1.2 - Add Tokens (%s)\", (mode) => {\n  describe((\"Adds more tokens\"), () => {\n    let ctx: BeneTestContext;\n    let projectBox: Box;\n\n    beforeEach(() => {\n      ctx = setupBeneTestContext(mode.token, mode.tokenName);\n\n      ctx.beneContract.addUTxOs({\n        value: RECOMMENDED_MIN_FEE_VALUE,\n        ergoTree: ctx.beneErgoTree.toHex(),\n        assets: [\n          { tokenId: ctx.projectNftId, amount: 1n + ctx.totalPFTokens },\n          { tokenId: ctx.pftTokenId, amount: ctx.totalPFTokens }, // 100k PFT\n        ],\n        creationHeight: ctx.mockChain.height - 100,\n        additionalRegisters: {\n          R4: createR4(ctx),\n          R5: SLong(ctx.minimumTokensSold).toHex(),\n          R6: SColl(SLong, [0n, 0n, 0n]).toHex(),\n          R7: SLong(ctx.exchangeRate).toHex(),\n          R8: ctx.constants.toHex(),\n          R9: SColl(SByte, stringToBytes(\"utf8\", \"{}\")).toHex(),\n        },\n      });\n\n      projectBox = ctx.beneContract.utxos.toArray()[0];\n    });\n\n    it(\"should allow project owner to add more PFT tokens\", () => {\n      // Arrange\n      const tokensToAdd = 50_000n;\n      const newPFTAmount = BigInt(projectBox.assets[1].amount) + tokensToAdd;\n\n      // Owner has PFT tokens to add\n      ctx.projectOwner.addUTxOs({\n        value: 10_000_000_000n, // ERG for fees\n        ergoTree: ctx.projectOwner.address.ergoTree,\n        assets: [{ tokenId: ctx.pftTokenId, amount: tokensToAdd }],\n        creationHeight: ctx.mockChain.height - 50,\n        additionalRegisters: {},\n      });\n\n      const ownerTokenBox = ctx.projectOwner.utxos\n        .toArray()\n        .find((box) => box.assets.some((a) => a.tokenId === ctx.pftTokenId))!;\n\n      // Act\n      const transaction = new TransactionBuilder(ctx.mockChain.height)\n        .from([projectBox, ownerTokenBox])\n        .to([\n          // Output 0: Updated contract with more PFT\n          new OutputBuilder(projectBox.value, ctx.beneErgoTree)\n            .addTokens([\n              { tokenId: ctx.projectNftId, amount: projectBox.assets[0].amount },\n              { tokenId: ctx.pftTokenId, amount: newPFTAmount }\n            ])\n            .setAdditionalRegisters({\n              R4: projectBox.additionalRegisters.R4,\n              R5: SLong(ctx.minimumTokensSold).toHex(),\n              R6: SColl(SLong, [0n, 0n, 0n]).toHex(),\n              R7: SLong(ctx.exchangeRate).toHex(),\n              R8: projectBox.additionalRegisters.R8,\n              R9: projectBox.additionalRegisters.R9,\n            }),\n        ])\n        .sendChangeTo(ctx.projectOwner.address)\n        .payFee(RECOMMENDED_MIN_FEE_VALUE)\n        .build();\n\n      const result = ctx.mockChain.execute(transaction, { signers: [ctx.projectOwner] });\n\n      // Assert\n      expect(result).toBe(true);\n      expect(ctx.beneContract.utxos.length).toEqual(1);\n\n      const updatedBox = ctx.beneContract.utxos.toArray()[0];\n      expect(updatedBox.assets[1].amount).toEqual(newPFTAmount);\n    });\n\n    it(\"should fail when non-owner tries to add tokens\", () => {\n      // Arrange\n      const tokensToAdd = 50_000n;\n\n      // Buyer (non-owner) tries to add tokens\n      ctx.buyer.addUTxOs({\n        value: 10_000_000_000n,\n        ergoTree: ctx.buyer.address.ergoTree,\n        assets: [{ tokenId: ctx.pftTokenId, amount: tokensToAdd }],\n        creationHeight: ctx.mockChain.height - 50,\n        additionalRegisters: {},\n      });\n\n      const buyerTokenBox = ctx.buyer.utxos\n        .toArray()\n        .find((box) => box.assets.some((a) => a.tokenId === ctx.pftTokenId))!;\n\n      // Act\n      const transaction = new TransactionBuilder(ctx.mockChain.height)\n        .from([projectBox, buyerTokenBox])\n        .to([\n          new OutputBuilder(projectBox.value, ctx.beneErgoTree)\n            .addTokens([\n              { tokenId: ctx.projectNftId, amount: projectBox.assets[0].amount },\n              { tokenId: ctx.pftTokenId, amount: BigInt(projectBox.assets[1].amount) + tokensToAdd },\n            ])\n            .setAdditionalRegisters({\n              R4: projectBox.additionalRegisters.R4,\n              R5: SLong(ctx.minimumTokensSold).toHex(),\n              R6: SColl(SLong, [10_000n, 0n, 0n]).toHex(),\n              R7: SLong(ctx.exchangeRate).toHex(),\n              R8: projectBox.additionalRegisters.R8,\n              R9: projectBox.additionalRegisters.R9,\n            }),\n        ])\n        .sendChangeTo(ctx.buyer.address)\n        .payFee(RECOMMENDED_MIN_FEE_VALUE)\n        .build();\n\n      const result = ctx.mockChain.execute(transaction, { signers: [ctx.buyer], throw: false });\n\n      // Assert\n      expect(result).toBe(false); // Should fail - not owner\n    });\n  });\n\n  describe(\"Adds tokens to a contract that doesn't have any PFT\", () => {\n    let ctx: BeneTestContext;\n    let projectBox: Box;\n\n    beforeEach(() => {\n      ctx = setupBeneTestContext(mode.token, mode.tokenName);\n\n      ctx.beneContract.addUTxOs({\n        value: RECOMMENDED_MIN_FEE_VALUE,\n        ergoTree: ctx.beneErgoTree.toHex(),\n        assets: [\n          { tokenId: ctx.projectNftId, amount: 1n + ctx.totalPFTokens }\n        ],\n        creationHeight: ctx.mockChain.height - 100,\n        additionalRegisters: {\n          R4: createR4(ctx),\n          R5: SLong(ctx.minimumTokensSold).toHex(),\n          R6: SColl(SLong, [0n, 0n, 0n]).toHex(),\n          R7: SLong(ctx.exchangeRate).toHex(),\n          R8: ctx.constants.toHex(),\n          R9: SColl(SByte, stringToBytes(\"utf8\", \"{}\")).toHex(),\n        },\n      });\n\n      projectBox = ctx.beneContract.utxos.toArray()[0];\n    });\n\n    it(\"should allow project owner to add more PFT tokens\", () => {\n      // Arrange\n      const tokensToAdd = 50_000n;\n      const newPFTAmount = tokensToAdd;\n\n      // Owner has PFT tokens to add\n      ctx.projectOwner.addUTxOs({\n        value: 10_000_000_000n, // ERG for fees\n        ergoTree: ctx.projectOwner.address.ergoTree,\n        assets: [{ tokenId: ctx.pftTokenId, amount: tokensToAdd }],\n        creationHeight: ctx.mockChain.height - 50,\n        additionalRegisters: {},\n      });\n\n      const ownerTokenBox = ctx.projectOwner.utxos\n        .toArray()\n        .find((box) => box.assets.some((a) => a.tokenId === ctx.pftTokenId))!;\n\n      // Act\n      const transaction = new TransactionBuilder(ctx.mockChain.height)\n        .from([projectBox, ownerTokenBox])\n        .to([\n          // Output 0: Updated contract with more PFT\n          new OutputBuilder(projectBox.value, ctx.beneErgoTree)\n            .addTokens([\n              { tokenId: ctx.projectNftId, amount: projectBox.assets[0].amount },\n              { tokenId: ctx.pftTokenId, amount: newPFTAmount }\n            ])\n            .setAdditionalRegisters({\n              R4: projectBox.additionalRegisters.R4,\n              R5: SLong(ctx.minimumTokensSold).toHex(),\n              R6: SColl(SLong, [0n, 0n, 0n]).toHex(),\n              R7: SLong(ctx.exchangeRate).toHex(),\n              R8: projectBox.additionalRegisters.R8,\n              R9: projectBox.additionalRegisters.R9,\n            }),\n        ])\n        .sendChangeTo(ctx.projectOwner.address)\n        .payFee(RECOMMENDED_MIN_FEE_VALUE)\n        .build();\n\n      const result = ctx.mockChain.execute(transaction, { signers: [ctx.projectOwner] });\n\n      // Assert\n      expect(result).toBe(true);\n      expect(ctx.beneContract.utxos.length).toEqual(1);\n\n      const updatedBox = ctx.beneContract.utxos.toArray()[0];\n      expect(updatedBox.assets[1].amount).toEqual(newPFTAmount);\n    });\n\n    it(\"should fail when non-owner tries to add tokens\", () => {\n      // Arrange\n      const tokensToAdd = 50_000n;\n\n      // Buyer (non-owner) tries to add tokens\n      ctx.buyer.addUTxOs({\n        value: 10_000_000_000n,\n        ergoTree: ctx.buyer.address.ergoTree,\n        assets: [{ tokenId: ctx.pftTokenId, amount: tokensToAdd }],\n        creationHeight: ctx.mockChain.height - 50,\n        additionalRegisters: {},\n      });\n\n      const buyerTokenBox = ctx.buyer.utxos\n        .toArray()\n        .find((box) => box.assets.some((a) => a.tokenId === ctx.pftTokenId))!;\n\n      // Act\n      const transaction = new TransactionBuilder(ctx.mockChain.height)\n        .from([projectBox, buyerTokenBox])\n        .to([\n          new OutputBuilder(projectBox.value, ctx.beneErgoTree)\n            .addTokens([\n              { tokenId: ctx.projectNftId, amount: projectBox.assets[0].amount },\n              { tokenId: ctx.pftTokenId, amount: tokensToAdd },\n            ])\n            .setAdditionalRegisters({\n              R4: projectBox.additionalRegisters.R4,\n              R5: SLong(ctx.minimumTokensSold).toHex(),\n              R6: SColl(SLong, [10_000n, 0n, 0n]).toHex(),\n              R7: SLong(ctx.exchangeRate).toHex(),\n              R8: projectBox.additionalRegisters.R8,\n              R9: projectBox.additionalRegisters.R9,\n            }),\n        ])\n        .sendChangeTo(ctx.buyer.address)\n        .payFee(RECOMMENDED_MIN_FEE_VALUE)\n        .build();\n\n      const result = ctx.mockChain.execute(transaction, { signers: [ctx.buyer], throw: false });\n\n      // Assert\n      expect(result).toBe(false); // Should fail - not owner\n    });\n  });\n\n  describe((\"Adds more tokens with complex owner script authorization\"), () => {\n    let ctx: BeneTestContext;\n    let projectBox: Box;\n    let ownerContract: ErgoTree;\n\n    beforeEach(() => {\n      ownerContract = compile(`{ sigmaProp(HEIGHT > 1) }`);\n\n      ctx = setupBeneTestContext(mode.token, mode.tokenName, ownerContract.toAddress());\n\n      ctx.beneContract.addUTxOs({\n        value: RECOMMENDED_MIN_FEE_VALUE,\n        ergoTree: ctx.beneErgoTree.toHex(),\n        assets: [\n          { tokenId: ctx.projectNftId, amount: 1n + ctx.totalPFTokens },\n          { tokenId: ctx.pftTokenId, amount: ctx.totalPFTokens }, // 100k PFT\n        ],\n        creationHeight: ctx.mockChain.height - 100,\n        additionalRegisters: {\n          R4: createR4(ctx),\n          R5: SLong(ctx.minimumTokensSold).toHex(),\n          R6: SColl(SLong, [0n, 0n, 0n]).toHex(),\n          R7: SLong(ctx.exchangeRate).toHex(),\n          R8: ctx.constants.toHex(),\n          R9: SColl(SByte, stringToBytes(\"utf8\", \"{}\")).toHex(),\n        },\n      });\n\n      projectBox = ctx.beneContract.utxos.toArray()[0];\n    });\n\n    it(\"should allow project owner to add more PFT tokens\", () => {\n\n      const customOwnerContract = ctx.mockChain.addParty(ownerContract.toAddress().ergoTree, `Custom owner contract`);\n      customOwnerContract.addUTxOs({\n        value: RECOMMENDED_MIN_FEE_VALUE,\n        ergoTree: ownerContract.toAddress().ergoTree,\n        creationHeight: ctx.mockChain.height - 100,\n        assets: [],\n        additionalRegisters: {}\n      })\n      const ownerScriptBox = customOwnerContract.utxos.toArray()[0];  // TODO CHECK - This box is omitted by the transaction in both cases (ERG and USD)\n\n      // Arrange\n      const tokensToAdd = 50_000n;\n      const newPFTAmount = BigInt(projectBox.assets[1].amount) + tokensToAdd;\n\n      // Owner has PFT tokens to add\n      ctx.projectOwner.addUTxOs({\n        value: 10_000_000_000n, // ERG for fees\n        ergoTree: ctx.projectOwner.address.ergoTree,\n        assets: [{ tokenId: ctx.pftTokenId, amount: tokensToAdd }],\n        creationHeight: ctx.mockChain.height - 50,\n        additionalRegisters: {},\n      });\n\n      const ownerTokenBox = ctx.projectOwner.utxos\n        .toArray()\n        .find((box) => box.assets.some((a) => a.tokenId === ctx.pftTokenId))!;\n\n      // Act\n      const transaction = new TransactionBuilder(ctx.mockChain.height)\n        .from([projectBox, ownerTokenBox, ownerScriptBox])\n        .to([\n          // Output 0: Updated contract with more PFT\n          new OutputBuilder(projectBox.value, ctx.beneErgoTree)\n            .addTokens([\n              { tokenId: ctx.projectNftId, amount: projectBox.assets[0].amount },\n              { tokenId: ctx.pftTokenId, amount: newPFTAmount }\n            ])\n            .setAdditionalRegisters({\n              R4: projectBox.additionalRegisters.R4,\n              R5: SLong(ctx.minimumTokensSold).toHex(),\n              R6: SColl(SLong, [0n, 0n, 0n]).toHex(),\n              R7: SLong(ctx.exchangeRate).toHex(),\n              R8: projectBox.additionalRegisters.R8,\n              R9: projectBox.additionalRegisters.R9,\n            }),\n        ])\n        .sendChangeTo(ctx.projectOwner.address)\n        .payFee(RECOMMENDED_MIN_FEE_VALUE)\n        .build();\n\n      const result = ctx.mockChain.execute(transaction, { signers: [ctx.projectOwner] });\n\n      // Assert\n      expect(result).toBe(true);\n      expect(ctx.beneContract.utxos.length).toEqual(1);\n\n      const updatedBox = ctx.beneContract.utxos.toArray()[0];\n      expect(updatedBox.assets[1].amount).toEqual(newPFTAmount);\n    });\n  });\n});","path":null,"size_bytes":13395,"size_tokens":null},"tests/contracts/buy_tokens.test.ts":{"content":"// ===== TEST FILE: Buy APT Tokens =====\n// Tests the token purchase flow where users buy APT tokens with ERG (or custom tokens)\n// Verifies payment validation, token distribution, and counter updates\n\nimport { describe, it, expect, beforeEach } from \"vitest\";\nimport { Box, OutputBuilder, TransactionBuilder, RECOMMENDED_MIN_FEE_VALUE } from \"@fleet-sdk/core\";\nimport { SByte, SColl, SInt, SLong } from \"@fleet-sdk/serializer\";\nimport { stringToBytes } from \"@scure/base\";\nimport { setupBeneTestContext, ERG_BASE_TOKEN, ERG_BASE_TOKEN_NAME, type BeneTestContext, USD_BASE_TOKEN, USD_BASE_TOKEN_NAME, createR4 } from \"./bene_contract_helpers\";\n\n// EXECUTION FLOW:\n// 1. beforeEach() â†’ Creates fresh blockchain + initial project box with 100k APT tokens\n// 2. Test builds transaction: Buyer pays ERG â†’ Contract gives APT tokens\n// 3. mockChain.execute() validates the transaction against contract rules\n// 4. Assertions verify payment received and tokens distributed\n\nconst baseModes = [\n  { name: \"USD Token Mode\", token: USD_BASE_TOKEN, tokenName: USD_BASE_TOKEN_NAME },\n  { name: \"ERG Mode\", token: ERG_BASE_TOKEN, tokenName: ERG_BASE_TOKEN_NAME },\n];\n\ndescribe.each(baseModes)(\"Bene Contract v1.2 - Buy APT Tokens (%s)\", (mode) => {\n\n  describe(\"Initial scenario with any sold tokens\", () => {\n\n    let ctx: BeneTestContext;  // Test environment (blockchain, actors, config)\n    let projectBox: Box;       // The contract's UTXO holding tokens and funds\n\n    beforeEach(() => {\n      // STEP 1: Initialize test context with BASE_TOKEN (see bene_contract_helpers.ts to change)\n      ctx = setupBeneTestContext(mode.token, mode.tokenName);\n\n      // STEP 2: Create initial project box with all tokens available for sale\n      ctx.beneContract.addUTxOs({\n        value: RECOMMENDED_MIN_FEE_VALUE,               // Minimum ERG in contract\n        ergoTree: ctx.beneErgoTree.toHex(),             // Contract script\n        assets: [\n          { tokenId: ctx.projectNftId, amount: 1n + ctx.totalPFTokens }, // APT: 1 NFT + 100k tokens = 100,001 total\n          { tokenId: ctx.pftTokenId, amount: ctx.totalPFTokens },        // PFT: 100,000 tokens\n          // { tokenId: ctx.baseTokenId, amount: 0n },                    // SigmaUSD (starts empty) - (All token values should be > 0)\n        ],\n        creationHeight: ctx.mockChain.height,\n        additionalRegisters: {\n          R4: createR4(ctx),                               // Deadline block\n          R5: SLong(ctx.minimumTokensSold).toHex(),                          // Minimum: 50k tokens\n          R6: SColl(SLong, [0n, 0n, 0n]).toHex(),                            // Counters: [0 sold, 0 refunded, 0 exchanged]\n          R7: SLong(ctx.exchangeRate).toHex(),  // [price: 1M, token_len: 0]\n          R8: ctx.constants.toHex(),            // Owner details (empty)\n          R9: SColl(SByte, stringToBytes(\"utf8\", \"{}\")).toHex(),            // Metadata (empty)\n        },\n      });\n\n      // STEP 3: Get reference to the created project box\n      projectBox = ctx.beneContract.utxos.toArray()[0];\n    });\n\n    it(\"should allow buying APT tokens\", () => {\n      // ARRANGE: Calculate transaction amounts\n      const tokensToBuy = 10_000n;                                      // Buyer wants 10,000 APT\n      const paymentAmount = tokensToBuy * ctx.exchangeRate;            // Cost: 10,000 * 1M = 10 ERG\n      const newAPTAmount = BigInt(projectBox.assets[0].amount) - tokensToBuy; // Contract loses 10k APT\n\n      let value = BigInt(projectBox.value);\n      let assets = [\n        { tokenId: ctx.projectNftId, amount: newAPTAmount },\n        { tokenId: ctx.pftTokenId, amount: ctx.totalPFTokens }\n      ];\n\n      if (!ctx.isErgMode) {\n        assets.push({ tokenId: ctx.baseTokenId, amount: paymentAmount }); // In custom token mode, contract receives payment tokens\n      } else {\n        value += paymentAmount; // In ERG mode, contract receives ERG\n      }\n\n      // Build the updated contract box (receives payment, loses tokens)\n      const contractOutputBuilder = new OutputBuilder(\n        value,\n        ctx.beneErgoTree                                      // Same contract address\n      )\n        .addTokens(assets)\n        .setAdditionalRegisters({\n          R4: projectBox.additionalRegisters.R4,                               // Deadline (unchanged)\n          R5: SLong(ctx.minimumTokensSold).toHex(),                          // Minimum (unchanged)\n          R6: SColl(SLong, [tokensToBuy, 0n, 0n]).toHex(),                   // Counters: [10k sold, 0 refunded, 0 exchanged]\n          R7: SLong(ctx.exchangeRate).toHex(),  // Price (unchanged)\n          R8: projectBox.additionalRegisters.R8,                             // Owner details (unchanged)\n          R9: projectBox.additionalRegisters.R9,                             // Metadata (unchanged)\n        });\n\n      // ACT: Build and execute the purchase transaction\n      const transaction = new TransactionBuilder(ctx.mockChain.height)\n        // INPUTS: Spend contract box + buyer's UTXOs (for payment)\n        .from([projectBox, ...ctx.buyer.utxos.toArray()])\n\n        // OUTPUTS:\n        .to([\n          contractOutputBuilder,  // Output 0: Updated contract (more ERG, fewer APT)\n          new OutputBuilder(RECOMMENDED_MIN_FEE_VALUE, ctx.buyer.address).addTokens([  // Output 1: Buyer receives tokens\n            { tokenId: ctx.projectNftId, amount: tokensToBuy },  // Buyer gets 10,000 APT\n          ]),\n        ])\n\n        .sendChangeTo(ctx.buyer.address)         // Remaining ERG goes back to buyer\n        .payFee(RECOMMENDED_MIN_FEE_VALUE)        // Transaction fee: 0.001 ERG\n        .build();\n\n      // Execute transaction on mock blockchain (validates contract logic)\n      const result = ctx.mockChain.execute(transaction, { signers: [ctx.buyer] });\n\n      // ASSERT: Verify transaction succeeded\n      expect(result).toBe(true);                          // Transaction valid\n    });\n\n    it(\"should fail when payment is insufficient for token amount\", () => {\n      // ARRANGE: Calculate transaction amounts\n      const tokensToBuy = 10_000n;                                      // Buyer wants 10,000 APT\n      const insufficientPayment = (tokensToBuy * ctx.exchangeRate) / 2n;            // Cost: 10,000 * 1M / 2 = 5 ERG (INSUFFICIENT)\n      const newAPTAmount = BigInt(projectBox.assets[0].amount) - tokensToBuy; // Contract loses 10k APT\n\n      let value = BigInt(projectBox.value);\n      let assets = [\n        { tokenId: ctx.projectNftId, amount: newAPTAmount },\n        { tokenId: ctx.pftTokenId, amount: ctx.totalPFTokens }\n      ];\n\n      if (!ctx.isErgMode) {\n        assets.push({ tokenId: ctx.baseTokenId, amount: insufficientPayment }); // In custom token mode, contract receives payment tokens\n      } else {\n        value += insufficientPayment; // In ERG mode, contract receives ERG\n      }\n\n      // Build the updated contract box (receives payment, loses tokens)\n      const contractOutputBuilder = new OutputBuilder(\n        value,\n        ctx.beneErgoTree                                                  // Same contract address\n      )\n        .addTokens(assets)\n        .setAdditionalRegisters({\n          R4: projectBox.additionalRegisters.R4,                               // Deadline (unchanged)\n          R5: SLong(ctx.minimumTokensSold).toHex(),                          // Minimum (unchanged)\n          R6: SColl(SLong, [tokensToBuy, 0n, 0n]).toHex(),                   // Counters: [10k sold, 0 refunded, 0 exchanged]\n          R7: SLong(ctx.exchangeRate).toHex(),  // Price (unchanged)\n          R8: projectBox.additionalRegisters.R8,                             // Owner details (unchanged)\n          R9: projectBox.additionalRegisters.R9,                             // Metadata (unchanged)\n        });\n\n      // ACT: Build and execute the purchase transaction\n      const transaction = new TransactionBuilder(ctx.mockChain.height)\n        // INPUTS: Spend contract box + buyer's UTXOs (for payment)\n        .from([projectBox, ...ctx.buyer.utxos.toArray()])\n\n        // OUTPUTS:\n        .to([\n          contractOutputBuilder,  // Output 0: Updated contract (more ERG, fewer APT)\n          new OutputBuilder(RECOMMENDED_MIN_FEE_VALUE, ctx.buyer.address).addTokens([  // Output 1: Buyer receives tokens\n            { tokenId: ctx.projectNftId, amount: tokensToBuy },  // Buyer gets 10,000 APT\n          ]),\n        ])\n\n        .sendChangeTo(ctx.buyer.address)         // Remaining ERG goes back to buyer\n        .payFee(RECOMMENDED_MIN_FEE_VALUE)        // Transaction fee: 0.001 ERG\n        .build();\n\n      // Execute transaction on mock blockchain (validates contract logic)\n      const result = ctx.mockChain.execute(transaction, { signers: [ctx.buyer], throw: false });\n\n      expect(result).toBe(false);                          // Transaction invalid\n    });\n\n    it(\"should fail when sold counter is not correct\", () => {\n      // ARRANGE: Calculate transaction amounts\n      const tokensToBuy = 10_000n;                                      // Buyer wants 10,000 APT\n      const paymentAmount = (tokensToBuy * ctx.exchangeRate);            // Cost: 10,000 * 1M / 2 =  10 ERG (CORRECT)\n      const newAPTAmount = BigInt(projectBox.assets[0].amount) - tokensToBuy; // Contract loses 10k APT\n\n      let value = BigInt(projectBox.value);\n      let assets = [\n        { tokenId: ctx.projectNftId, amount: newAPTAmount },\n        { tokenId: ctx.pftTokenId, amount: ctx.totalPFTokens }\n      ];\n\n      if (!ctx.isErgMode) {\n        assets.push({ tokenId: ctx.baseTokenId, amount: paymentAmount }); // In custom token mode, contract receives payment tokens\n      } else {\n        value += paymentAmount; // In ERG mode, contract receives ERG\n      }\n\n      // Build the updated contract box (receives payment, loses tokens)\n      const contractOutputBuilder = new OutputBuilder(\n        value,\n        ctx.beneErgoTree                                                  // Same contract address\n      )\n        .addTokens(assets)\n        .setAdditionalRegisters({\n          R4: projectBox.additionalRegisters.R4,                               // Deadline (unchanged)\n          R5: SLong(ctx.minimumTokensSold).toHex(),                          // Minimum (unchanged)\n          R6: SColl(SLong, [tokensToBuy / 2n, 0n, 0n]).toHex(),                   // Counters: [10k sold, 0 refunded, 0 exchanged]\n          R7: SLong(ctx.exchangeRate).toHex(),  // Price (unchanged)\n          R8: projectBox.additionalRegisters.R8,                             // Owner details (unchanged)\n          R9: projectBox.additionalRegisters.R9,                             // Metadata (unchanged)\n        });\n\n      // ACT: Build and execute the purchase transaction\n      const transaction = new TransactionBuilder(ctx.mockChain.height)\n        // INPUTS: Spend contract box + buyer's UTXOs (for payment)\n        .from([projectBox, ...ctx.buyer.utxos.toArray()])\n\n        // OUTPUTS:\n        .to([\n          contractOutputBuilder,  // Output 0: Updated contract (more ERG, fewer APT)\n          new OutputBuilder(RECOMMENDED_MIN_FEE_VALUE, ctx.buyer.address).addTokens([  // Output 1: Buyer receives tokens\n            { tokenId: ctx.projectNftId, amount: tokensToBuy },  // Buyer gets 10,000 APT\n          ]),\n        ])\n\n        .sendChangeTo(ctx.buyer.address)         // Remaining ERG goes back to buyer\n        .payFee(RECOMMENDED_MIN_FEE_VALUE)        // Transaction fee: 0.001 ERG\n        .build();\n\n      // Execute transaction on mock blockchain (validates contract logic)\n      const result = ctx.mockChain.execute(transaction, { signers: [ctx.buyer], throw: false });\n\n      expect(result).toBe(false);                          // Transaction invalid\n    });\n\n\n    it(\"should fail when refunded counter is not correct\", () => {\n      // ARRANGE: Calculate transaction amounts\n      const tokensToBuy = 10_000n;                                      // Buyer wants 10,000 APT\n      const paymentAmount = (tokensToBuy * ctx.exchangeRate);            // Cost: 10,000 * 1M / 2 =  10 ERG (CORRECT)\n      const newAPTAmount = BigInt(projectBox.assets[0].amount) - tokensToBuy; // Contract loses 10k APT\n\n      let value = BigInt(projectBox.value);\n      let assets = [\n        { tokenId: ctx.projectNftId, amount: newAPTAmount },\n        { tokenId: ctx.pftTokenId, amount: ctx.totalPFTokens }\n      ];\n\n      if (!ctx.isErgMode) {\n        assets.push({ tokenId: ctx.baseTokenId, amount: paymentAmount }); // In custom token mode, contract receives payment tokens\n      } else {\n        value += paymentAmount; // In ERG mode, contract receives ERG\n      }\n\n      // Build the updated contract box (receives payment, loses tokens)\n      const contractOutputBuilder = new OutputBuilder(\n        value,\n        ctx.beneErgoTree                                                  // Same contract address\n      )\n        .addTokens(assets)\n        .setAdditionalRegisters({\n          R4: projectBox.additionalRegisters.R4,                               // Deadline (unchanged)\n          R5: SLong(ctx.minimumTokensSold).toHex(),                          // Minimum (unchanged)\n          R6: SColl(SLong, [tokensToBuy, 1n, 0n]).toHex(),                   // Counters: [10k sold, 0 refunded, 0 exchanged]\n          R7: SLong(ctx.exchangeRate).toHex(),  // Price (unchanged)\n          R8: projectBox.additionalRegisters.R8,                             // Owner details (unchanged)\n          R9: projectBox.additionalRegisters.R9,                             // Metadata (unchanged)\n        });\n\n      // ACT: Build and execute the purchase transaction\n      const transaction = new TransactionBuilder(ctx.mockChain.height)\n        // INPUTS: Spend contract box + buyer's UTXOs (for payment)\n        .from([projectBox, ...ctx.buyer.utxos.toArray()])\n\n        // OUTPUTS:\n        .to([\n          contractOutputBuilder,  // Output 0: Updated contract (more ERG, fewer APT)\n          new OutputBuilder(RECOMMENDED_MIN_FEE_VALUE, ctx.buyer.address).addTokens([  // Output 1: Buyer receives tokens\n            { tokenId: ctx.projectNftId, amount: tokensToBuy },  // Buyer gets 10,000 APT\n          ]),\n        ])\n\n        .sendChangeTo(ctx.buyer.address)         // Remaining ERG goes back to buyer\n        .payFee(RECOMMENDED_MIN_FEE_VALUE)        // Transaction fee: 0.001 ERG\n        .build();\n\n      // Execute transaction on mock blockchain (validates contract logic)\n      const result = ctx.mockChain.execute(transaction, { signers: [ctx.buyer], throw: false });\n\n      expect(result).toBe(false);                          // Transaction invalid\n    });\n\n    it(\"should fail when exchanged counter is not correct\", () => {\n      // ARRANGE: Calculate transaction amounts\n      const tokensToBuy = 10_000n;                                      // Buyer wants 10,000 APT\n      const paymentAmount = (tokensToBuy * ctx.exchangeRate);            // Cost: 10,000 * 1M / 2 =  10 ERG (CORRECT)\n      const newAPTAmount = BigInt(projectBox.assets[0].amount) - tokensToBuy; // Contract loses 10k APT\n\n      let value = BigInt(projectBox.value);\n      let assets = [\n        { tokenId: ctx.projectNftId, amount: newAPTAmount },\n        { tokenId: ctx.pftTokenId, amount: ctx.totalPFTokens }\n      ];\n\n      if (!ctx.isErgMode) {\n        assets.push({ tokenId: ctx.baseTokenId, amount: paymentAmount }); // In custom token mode, contract receives payment tokens\n      } else {\n        value += paymentAmount; // In ERG mode, contract receives ERG\n      }\n\n      // Build the updated contract box (receives payment, loses tokens)\n      const contractOutputBuilder = new OutputBuilder(\n        value,\n        ctx.beneErgoTree                                                  // Same contract address\n      )\n        .addTokens(assets)\n        .setAdditionalRegisters({\n          R4: projectBox.additionalRegisters.R4,                               // Deadline (unchanged)\n          R5: SLong(ctx.minimumTokensSold).toHex(),                          // Minimum (unchanged)\n          R6: SColl(SLong, [tokensToBuy, 0n, 1n]).toHex(),                   // Counters: [10k sold, 0 refunded, 0 exchanged]\n          R7: SLong(ctx.exchangeRate).toHex(),  // Price (unchanged)\n          R8: projectBox.additionalRegisters.R8,                             // Owner details (unchanged)\n          R9: projectBox.additionalRegisters.R9,                             // Metadata (unchanged)\n        });\n\n      // ACT: Build and execute the purchase transaction\n      const transaction = new TransactionBuilder(ctx.mockChain.height)\n        // INPUTS: Spend contract box + buyer's UTXOs (for payment)\n        .from([projectBox, ...ctx.buyer.utxos.toArray()])\n\n        // OUTPUTS:\n        .to([\n          contractOutputBuilder,  // Output 0: Updated contract (more ERG, fewer APT)\n          new OutputBuilder(RECOMMENDED_MIN_FEE_VALUE, ctx.buyer.address).addTokens([  // Output 1: Buyer receives tokens\n            { tokenId: ctx.projectNftId, amount: tokensToBuy },  // Buyer gets 10,000 APT\n          ]),\n        ])\n\n        .sendChangeTo(ctx.buyer.address)         // Remaining ERG goes back to buyer\n        .payFee(RECOMMENDED_MIN_FEE_VALUE)        // Transaction fee: 0.001 ERG\n        .build();\n\n      // Execute transaction on mock blockchain (validates contract logic)\n      const result = ctx.mockChain.execute(transaction, { signers: [ctx.buyer], throw: false });\n\n      expect(result).toBe(false);                          // Transaction invalid\n    });\n  });\n\n  describe(\"Scenario where no APT tokens remain unsold (Sold Out)\", () => {\n\n    let ctx: BeneTestContext;  // Test environment (blockchain, actors, config)\n    let projectBox: Box;       // The contract's UTXO holding tokens and funds\n\n    beforeEach(() => {\n      // STEP 1: Initialize test context\n      ctx = setupBeneTestContext(mode.token, mode.tokenName);\n\n      // --- SETUP FOR SOLD OUT STATE ---\n      const soldAmount = ctx.totalPFTokens; // All tokens (100k) are marked as sold\n      const accumulatedSalesValue = soldAmount * ctx.exchangeRate; // Calculate required funds from sales\n\n      // Initial assets: Only the 1n identifier APT remains, PFT is still present (for accounting)\n      const initialAssets = [\n        { tokenId: ctx.projectNftId, amount: 1n }, // APT: Only 1n (the NFT/ID) remains\n        { tokenId: ctx.pftTokenId, amount: ctx.totalPFTokens }, // PFT: 100,000 tokens (for accounting)\n      ];\n\n      let initialValue = RECOMMENDED_MIN_FEE_VALUE; // Start with minimum ERG\n\n      // Adjust assets/value based on payment mode (simulating accumulated funds)\n      if (!ctx.isErgMode) {\n        // In custom token mode, the contract holds the accumulated payment tokens\n        initialAssets.push({ tokenId: ctx.baseTokenId, amount: accumulatedSalesValue });\n      } else {\n        // In ERG mode, the contract's value is the minimum + accumulated ERG\n        initialValue += accumulatedSalesValue;\n      }\n      // --- END SETUP ---\n\n      // STEP 2: Create project box in 'Sold Out' state\n      ctx.beneContract.addUTxOs({\n        value: initialValue,\n        ergoTree: ctx.beneErgoTree.toHex(),\n        assets: initialAssets,\n        creationHeight: ctx.mockChain.height,\n        additionalRegisters: {\n          R4: createR4(ctx),\n          R5: SLong(ctx.minimumTokensSold).toHex(),\n          // KEY CHANGE: R6[0] (Sold Counter) equals total PFT, meaning no more tokens are available\n          R6: SColl(SLong, [soldAmount, 0n, 0n]).toHex(), // Counters: [100k sold, 0 refunded, 0 exchanged]\n          R7: SLong(ctx.exchangeRate).toHex(),\n          R8: ctx.constants.toHex(),\n          R9: SColl(SByte, stringToBytes(\"utf8\", \"{}\")).toHex(),\n        },\n      });\n\n      // STEP 3: Get reference to the created project box\n      projectBox = ctx.beneContract.utxos.toArray()[0];\n    });\n\n    it(\"should fail when attempting to buy tokens because onlyTemporaryUnsoldTokens is violated (Contract Sold Out)\", () => {\n      // ARRANGE: Attempt to buy 1 token\n      const tokensToBuy = 1n; // Buyer tries to buy 1 token\n      const paymentAmount = tokensToBuy * ctx.exchangeRate;\n\n      // New APT amount in the contract would be 1n (current) - 1n (bought) = 0n\n      const newAPTAmount = BigInt(projectBox.assets[0].amount) - tokensToBuy;\n\n      let value = BigInt(projectBox.value);\n      // Copy assets, excluding the base token if it's there (we handle payment next)\n      let assets = [\n        { tokenId: ctx.projectNftId, amount: newAPTAmount },\n        { tokenId: ctx.pftTokenId, amount: ctx.totalPFTokens }\n      ];\n\n      // Calculate how the payment affects the contract's value/assets\n      if (!ctx.isErgMode) {\n        // Find existing base token amount and add the new payment\n        const currentBaseTokenAsset = projectBox.assets.find(a => a.tokenId === ctx.baseTokenId);\n        const currentBaseTokens = currentBaseTokenAsset ? BigInt(currentBaseTokenAsset.amount) : 0n;\n        assets.push({ tokenId: ctx.baseTokenId, amount: currentBaseTokens + paymentAmount });\n      } else {\n        value += paymentAmount; // In ERG mode, contract receives ERG\n      }\n\n\n      // Build the updated contract box (receives payment, loses tokens)\n      const contractOutputBuilder = new OutputBuilder(\n        value,\n        ctx.beneErgoTree\n      )\n        .addTokens(assets)\n        .setAdditionalRegisters({\n          R4: projectBox.additionalRegisters.R4,\n          R5: projectBox.additionalRegisters.R5,\n          // Update R6[0] to reflect the attempted sale: R6[0] = 100000 + 1\n          R6: SColl(SLong, [ctx.totalPFTokens + tokensToBuy, 0n, 0n]).toHex(),\n          R7: projectBox.additionalRegisters.R7,\n          R8: projectBox.additionalRegisters.R8,\n          R9: projectBox.additionalRegisters.R9,\n        });\n\n      // ACT: Build and execute the purchase transaction\n      const transaction = new TransactionBuilder(ctx.mockChain.height)\n        // INPUTS: Spend contract box + buyer's UTXOs (for payment)\n        .from([projectBox, ...ctx.buyer.utxos.toArray()])\n\n        // OUTPUTS:\n        .to([\n          contractOutputBuilder,  // Output 0: Updated contract (more funds, fewer APT)\n          new OutputBuilder(RECOMMENDED_MIN_FEE_VALUE, ctx.buyer.address).addTokens([  // Output 1: Buyer receives tokens\n            { tokenId: ctx.projectNftId, amount: tokensToBuy },  // Buyer attempts to get 1 APT\n          ]),\n        ])\n\n        .sendChangeTo(ctx.buyer.address)\n        .payFee(RECOMMENDED_MIN_FEE_VALUE)\n        .build();\n\n      // Execute transaction on mock blockchain (validates contract logic)\n      const result = ctx.mockChain.execute(transaction, { signers: [ctx.buyer], throw: false });\n\n      // ASSERT: Transaction must fail. \n      // The contract logic checks: \n      // deltaTokenRemoved (1) <= temporaryFundingUnsoldTokens (0) => FALSE.\n      expect(result).toBe(false);\n    });\n  });\n\n});","path":null,"size_bytes":22846,"size_tokens":null},"src/lib/wallet/global.d.ts":{"content":"// Global type declarations for Ergo wallet connectors\ndeclare global {\n  interface Window {\n    ergoConnector?: {\n      nautilus?: {\n        connect(): Promise<boolean>;\n        isConnected(): Promise<boolean>;\n        disconnect(): Promise<void>;\n        getContext(): Promise<any>;\n      };\n      safew?: {\n        connect(): Promise<boolean>;\n        isConnected(): Promise<boolean>;\n        disconnect(): Promise<void>;\n        getContext(): Promise<any>;\n      };\n      [key: string]: any;\n    };\n    \n    ergo?: {\n      get_utxos(amount?: string, token_id?: string): Promise<any[]>;\n      get_balance(token_id?: string): Promise<string>;\n      get_used_addresses(): Promise<string[]>;\n      get_unused_addresses(): Promise<string[]>;\n      get_change_address(): Promise<string>;\n      sign_tx(tx: any): Promise<any>;\n      submit_tx(tx: any): Promise<string>;\n      get_current_height(): Promise<number>;\n      get_network_id(): Promise<number>;\n    };\n  }\n}\n\nexport {};\n","path":null,"size_bytes":978,"size_tokens":null},"tests/contracts/exchange.test.ts":{"content":"// ===== TEST FILE: Exchange APT â†’ PFT =====\n// Tests the token exchange where users convert APT back to PFT (1:1 ratio)\n// This is only allowed AFTER the minimum funding threshold is reached\n// Verifies exchange counter updates and token conservation\n\nimport { describe, it, expect, beforeEach } from \"vitest\";\nimport { Box, OutputBuilder, TransactionBuilder, RECOMMENDED_MIN_FEE_VALUE } from \"@fleet-sdk/core\";\nimport { SByte, SColl, SInt, SLong } from \"@fleet-sdk/serializer\";\nimport { stringToBytes } from \"@scure/base\";\nimport { setupBeneTestContext, ERG_BASE_TOKEN, ERG_BASE_TOKEN_NAME, type BeneTestContext, USD_BASE_TOKEN, USD_BASE_TOKEN_NAME, createR4 } from \"./bene_contract_helpers\";\n\n// EXECUTION FLOW:\n// 1. beforeEach() â†’ Creates blockchain + project box with MINIMUM REACHED (50k tokens sold)\n// 2. Give buyer 10k APT tokens to exchange\n// 3. Test builds transaction: Buyer returns APT â†’ Contract gives PFT (1:1)\n// 4. Contract validates minimum is reached and exchange ratio is correct\n\nconst baseModes = [\n  { name: \"USD Token Mode\", token: USD_BASE_TOKEN, tokenName: USD_BASE_TOKEN_NAME },\n  { name: \"ERG Mode\", token: ERG_BASE_TOKEN, tokenName: ERG_BASE_TOKEN_NAME },\n];\n\ndescribe.each(baseModes)(\"Bene Contract v1.2 - Exchange APT â†’ PFT (%s)\", (mode) => {\n  let ctx: BeneTestContext;  // Test environment\n\n  describe(\"Still any APT exchanged\", () => {\n\n    let projectBox: Box;       // Contract box\n    let soldTokens: bigint;\n\n    beforeEach(() => {\n      // STEP 1: Initialize test context with BASE_TOKEN (see bene_contract_helpers.ts to change)\n      ctx = setupBeneTestContext(mode.token, mode.tokenName);\n\n      // STEP 2: Create project box with MINIMUM FUNDING REACHED\n      // IMPORTANT: Exchange only works when sold >= minimumTokensSold\n      soldTokens = ctx.minimumTokensSold; // 50,000 tokens sold = minimum reached!\n      const collectedFunds = soldTokens * ctx.exchangeRate;\n\n      let value = RECOMMENDED_MIN_FEE_VALUE;\n      const assets = [\n        { tokenId: ctx.projectNftId, amount: 1n + ctx.totalPFTokens - soldTokens }, // APT: 1 + 100k - 50k = 50,001 remaining\n        { tokenId: ctx.pftTokenId, amount: ctx.totalPFTokens },                     // PFT: 100,000 still available to be exchanged\n      ];\n\n      if (!ctx.isErgMode) {\n        // USD Mode: Add funds as a token\n        assets.push({ tokenId: ctx.baseTokenId, amount: collectedFunds });  // 50K USD raised\n      }\n      else {\n        value += collectedFunds; // 1.1M + 50K nanoERG raised\n      }\n\n      ctx.beneContract.addUTxOs({\n        value: value,\n        ergoTree: ctx.beneErgoTree.toHex(),\n        assets: assets,\n        creationHeight: ctx.mockChain.height - 100,  // Created 100 blocks ago\n        additionalRegisters: {\n          R4: createR4(ctx),                               // Deadline\n          R5: SLong(ctx.minimumTokensSold).toHex(),                          // Minimum: 50k\n          R6: SColl(SLong, [soldTokens, 0n, 0n]).toHex(),                    // [50k sold, 0 refunded, 0 exchanged]\n          R7: SLong(ctx.exchangeRate).toHex(),  // [price, token_len]\n          R8: ctx.constants.toHex(),\n          R9: SColl(SByte, stringToBytes(\"utf8\", \"{}\")).toHex(),\n        },\n      });\n\n      // STEP 3: Give buyer APT tokens to exchange (simulating previous purchase)\n      const aptToExchange = 10_000n;\n      ctx.buyer.addUTxOs({\n        value: 10_000_000_000n,                                     // 10 ERG for transaction fees\n        ergoTree: ctx.buyer.address.ergoTree,                       // Buyer's address\n        assets: [{ tokenId: ctx.projectNftId, amount: aptToExchange }],  // Buyer has 10,000 APT to exchange\n        creationHeight: ctx.mockChain.height - 50,                  // Acquired 50 blocks ago\n        additionalRegisters: {},\n      });\n\n      // STEP 4: Get reference to project box\n      projectBox = ctx.beneContract.utxos.toArray()[0];\n    });\n\n    it(\"should allow exchanging APT tokens for PFT tokens\", () => {\n      // ARRANGE: Prepare exchange transaction\n      // Find buyer's box containing APT tokens\n      const buyerAPTBox = ctx.buyer.utxos\n        .toArray()\n        .find((box) => box.assets.some((asset) => asset.tokenId === ctx.projectNftId))!;\n      const aptToExchange = buyerAPTBox.assets[0].amount;  // 10,000 APT to exchange\n\n      const currentExchangeCounter = 0n;                           // Current exchange counter from R6[2]\n      const newExchangeCounter = currentExchangeCounter + aptToExchange;  // Increment to 10,000\n\n      // Calculate new token amounts after exchange\n      const newAPTAmount = BigInt(projectBox.assets[0].amount) + aptToExchange;  // Contract gains: 50,001 + 10k = 60,001 APT\n      const newPFTAmount = BigInt(projectBox.assets[1].amount) - aptToExchange;  // Contract loses: 100k - 10k = 90k PFT\n\n      const contractAssets = [\n        { tokenId: ctx.projectNftId, amount: newAPTAmount },  // 60,001 APT (gained 10k)\n        { tokenId: ctx.pftTokenId, amount: newPFTAmount },    // 90,000 PFT (lost 10k)\n      ];\n\n      if (!ctx.isErgMode) {\n        const currentBaseTokenAmount = projectBox.assets.find((asset) => asset.tokenId === ctx.baseTokenId)!.amount;\n        contractAssets.push({ tokenId: ctx.baseTokenId, amount: BigInt(currentBaseTokenAmount) });\n      }\n\n      // Build and execute exchange transaction\n      const transaction = new TransactionBuilder(ctx.mockChain.height)\n        .from([projectBox, buyerAPTBox])\n        .to([\n          // Output 0: Updated contract (gains APT, loses PFT)\n          new OutputBuilder(projectBox.value, ctx.beneErgoTree)  // ERG value unchanged\n            .addTokens(contractAssets)\n            .setAdditionalRegisters({\n              R4: projectBox.additionalRegisters.R4,\n              R5: SLong(ctx.minimumTokensSold).toHex(),\n              R6: SColl(SLong, [soldTokens, 0n, newExchangeCounter]).toHex(),  // [50k, 0, 10k] - exchange counter updated\n              R7: SLong(ctx.exchangeRate).toHex(),\n              R8: projectBox.additionalRegisters.R8,\n              R9: projectBox.additionalRegisters.R9,\n            }),\n          // Output 1: Buyer receives PFT tokens (1:1 exchange ratio)\n          new OutputBuilder(RECOMMENDED_MIN_FEE_VALUE, ctx.buyer.address).addTokens([\n            { tokenId: ctx.pftTokenId, amount: aptToExchange },  // Buyer gets 10,000 PFT\n          ]),\n        ])\n        .sendChangeTo(ctx.buyer.address)      // Change back to buyer\n        .payFee(RECOMMENDED_MIN_FEE_VALUE)     // 0.001 ERG fee\n        .build();\n\n      // Execute transaction (contract validates minimum reached + exchange ratio)\n      const result = ctx.mockChain.execute(transaction, { signers: [ctx.buyer] });\n\n      // ASSERT: Verify exchange succeeded\n      expect(result).toBe(true);                          // Transaction valid\n      expect(ctx.beneContract.utxos.length).toEqual(1);   // Contract still has 1 box\n\n      const updatedBox = ctx.beneContract.utxos.toArray()[0];\n      expect(updatedBox.assets[0].amount).toEqual(newAPTAmount);  // Contract has 60,001 APT\n      expect(updatedBox.assets[1].amount).toEqual(newPFTAmount);  // Contract has 90,000 PFT\n\n      // Verify buyer received PFT tokens\n      const buyerPFTBox = ctx.buyer.utxos\n        .toArray()\n        .find((box) => box.assets.some((asset) => asset.tokenId === ctx.pftTokenId));\n      expect(buyerPFTBox).toBeDefined();                           // Buyer has PFT box\n      expect(buyerPFTBox!.assets[0].amount).toEqual(aptToExchange);  // Buyer got 10,000 PFT\n    });\n\n    it(\"should fail when exchange ratio is incorrect\", () => {\n      // ARRANGE: Prepare exchange transaction\n      // Find buyer's box containing APT tokens\n      const buyerAPTBox = ctx.buyer.utxos\n        .toArray()\n        .find((box) => box.assets.some((asset) => asset.tokenId === ctx.projectNftId))!;\n      const aptToExchange = buyerAPTBox.assets[0].amount;  // 10,000 APT to exchange\n\n      const pftToExtract = aptToExchange * 2n; // Try to get 20,000 PFT (should be 1:1)\n\n\n      const currentExchangeCounter = 0n;                           // Current exchange counter from R6[2]\n      const newExchangeCounter = currentExchangeCounter + pftToExtract;  // Increment to 20,000\n\n      // Calculate new token amounts after exchange\n      const newAPTAmount = BigInt(projectBox.assets[0].amount) + aptToExchange;  // Contract gains: 50,001 + 10k = 60,001 APT\n      const newPFTAmount = BigInt(projectBox.assets[1].amount) - pftToExtract;  // Contract loses: 100k - 20k = 80k PFT\n\n      const contractAssets = [\n        { tokenId: ctx.projectNftId, amount: newAPTAmount },  // 60,001 APT (gained 10k)\n        { tokenId: ctx.pftTokenId, amount: newPFTAmount },    // 80,000 PFT (lost 20k)\n      ];\n\n      if (!ctx.isErgMode) {\n        const currentBaseTokenAmount = projectBox.assets.find((asset) => asset.tokenId === ctx.baseTokenId)!.amount;\n        contractAssets.push({ tokenId: ctx.baseTokenId, amount: BigInt(currentBaseTokenAmount) });\n      }\n\n      // Build and execute exchange transaction\n      const transaction = new TransactionBuilder(ctx.mockChain.height)\n        .from([projectBox, buyerAPTBox])\n        .to([\n          // Output 0: Updated contract (gains APT, loses PFT)\n          new OutputBuilder(projectBox.value, ctx.beneErgoTree)  // ERG value unchanged\n            .addTokens(contractAssets)\n            .setAdditionalRegisters({\n              R4: projectBox.additionalRegisters.R4,\n              R5: SLong(ctx.minimumTokensSold).toHex(),\n              R6: SColl(SLong, [soldTokens, 0n, newExchangeCounter]).toHex(),  // [50k, 0, 20k] - exchange counter updated\n              R7: SLong(ctx.exchangeRate).toHex(),\n              R8: projectBox.additionalRegisters.R8,\n              R9: projectBox.additionalRegisters.R9,\n            }),\n          // Output 1: Buyer receives PFT tokens (1:1 exchange ratio)\n          new OutputBuilder(RECOMMENDED_MIN_FEE_VALUE, ctx.buyer.address).addTokens([\n            { tokenId: ctx.pftTokenId, amount: pftToExtract },  // Buyer gets 20,000 PFT\n          ]),\n        ])\n        .sendChangeTo(ctx.buyer.address)      // Change back to buyer\n        .payFee(RECOMMENDED_MIN_FEE_VALUE)     // 0.001 ERG fee\n        .build();\n\n      // Execute transaction (contract validates minimum reached + exchange ratio)\n      const result = ctx.mockChain.execute(transaction, { signers: [ctx.buyer], throw: false });\n\n      expect(result).toBe(false);\n    });\n\n    it(\"should fail when tries to avoid increment exchange counter\", () => {\n      // ARRANGE: Prepare exchange transaction\n      // Find buyer's box containing APT tokens\n      const buyerAPTBox = ctx.buyer.utxos\n        .toArray()\n        .find((box) => box.assets.some((asset) => asset.tokenId === ctx.projectNftId))!;\n      const aptToExchange = buyerAPTBox.assets[0].amount;  // 10,000 APT to exchange\n\n\n      const currentExchangeCounter = 0n;                           // Current exchange counter from R6[2]\n      const newExchangeCounter = currentExchangeCounter + aptToExchange;  // Increment to 10,000\n\n      // Calculate new token amounts after exchange\n      const newAPTAmount = BigInt(projectBox.assets[0].amount) + aptToExchange;  // Contract gains: 50,001 + 10k = 60,001 APT\n      const newPFTAmount = BigInt(projectBox.assets[1].amount) - aptToExchange;  // Contract loses: 100k - 10k = 90k PFT\n\n      const contractAssets = [\n        { tokenId: ctx.projectNftId, amount: newAPTAmount },  // 60,001 APT (gained 10k)\n        { tokenId: ctx.pftTokenId, amount: newPFTAmount },    // 90,000 PFT (lost 10k)\n      ];\n\n      if (!ctx.isErgMode) {\n        const currentBaseTokenAmount = projectBox.assets.find((asset) => asset.tokenId === ctx.baseTokenId)!.amount;\n        contractAssets.push({ tokenId: ctx.baseTokenId, amount: BigInt(currentBaseTokenAmount) });\n      }\n\n      // Build and execute exchange transaction\n      const transaction = new TransactionBuilder(ctx.mockChain.height)\n        .from([projectBox, buyerAPTBox])\n        .to([\n          // Output 0: Updated contract (gains APT, loses PFT)\n          new OutputBuilder(projectBox.value, ctx.beneErgoTree)  // ERG value unchanged\n            .addTokens(contractAssets)\n            .setAdditionalRegisters({\n              R4: projectBox.additionalRegisters.R4,\n              R5: SLong(ctx.minimumTokensSold).toHex(),\n              R6: SColl(SLong, [soldTokens, 0n, 0n]).toHex(),  // [50k, 0, 0n] - any counter updated\n              R7: SLong(ctx.exchangeRate).toHex(),\n              R8: projectBox.additionalRegisters.R8,\n              R9: projectBox.additionalRegisters.R9,\n            }),\n          // Output 1: Buyer receives PFT tokens (1:1 exchange ratio)\n          new OutputBuilder(RECOMMENDED_MIN_FEE_VALUE, ctx.buyer.address).addTokens([\n            { tokenId: ctx.pftTokenId, amount: aptToExchange },  // Buyer gets 10,000 PFT\n          ]),\n        ])\n        .sendChangeTo(ctx.buyer.address)      // Change back to buyer\n        .payFee(RECOMMENDED_MIN_FEE_VALUE)     // 0.001 ERG fee\n        .build();\n\n      // Execute transaction (contract validates minimum reached + exchange ratio)\n      const result = ctx.mockChain.execute(transaction, { signers: [ctx.buyer], throw: false });\n\n      expect(result).toBe(false);\n    });\n\n    it(\"should fail when tries to modify refund counter\", () => {\n      // ARRANGE: Prepare exchange transaction\n      // Find buyer's box containing APT tokens\n      const buyerAPTBox = ctx.buyer.utxos\n        .toArray()\n        .find((box) => box.assets.some((asset) => asset.tokenId === ctx.projectNftId))!;\n      const aptToExchange = buyerAPTBox.assets[0].amount;  // 10,000 APT to exchange\n\n\n      const currentExchangeCounter = 0n;                           // Current exchange counter from R6[2]\n      const newExchangeCounter = currentExchangeCounter + aptToExchange;  // Increment to 10,000\n\n      // Calculate new token amounts after exchange\n      const newAPTAmount = BigInt(projectBox.assets[0].amount) + aptToExchange;  // Contract gains: 50,001 + 10k = 60,001 APT\n      const newPFTAmount = BigInt(projectBox.assets[1].amount) - aptToExchange;  // Contract loses: 100k - 10k = 90k PFT\n\n      const contractAssets = [\n        { tokenId: ctx.projectNftId, amount: newAPTAmount },  // 60,001 APT (gained 10k)\n        { tokenId: ctx.pftTokenId, amount: newPFTAmount },    // 90,000 PFT (lost 10k)\n      ];\n\n      if (!ctx.isErgMode) {\n        const currentBaseTokenAmount = projectBox.assets.find((asset) => asset.tokenId === ctx.baseTokenId)!.amount;\n        contractAssets.push({ tokenId: ctx.baseTokenId, amount: BigInt(currentBaseTokenAmount) });\n      }\n\n      // Build and execute exchange transaction\n      const transaction = new TransactionBuilder(ctx.mockChain.height)\n        .from([projectBox, buyerAPTBox])\n        .to([\n          // Output 0: Updated contract (gains APT, loses PFT)\n          new OutputBuilder(projectBox.value, ctx.beneErgoTree)  // ERG value unchanged\n            .addTokens(contractAssets)\n            .setAdditionalRegisters({\n              R4: projectBox.additionalRegisters.R4,\n              R5: SLong(ctx.minimumTokensSold).toHex(),\n              R6: SColl(SLong, [soldTokens, 1n, newExchangeCounter]).toHex(),  // [50k, 1, 10k] - exchange counter updated\n              R7: SLong(ctx.exchangeRate).toHex(),\n              R8: projectBox.additionalRegisters.R8,\n              R9: projectBox.additionalRegisters.R9,\n            }),\n          // Output 1: Buyer receives PFT tokens (1:1 exchange ratio)\n          new OutputBuilder(RECOMMENDED_MIN_FEE_VALUE, ctx.buyer.address).addTokens([\n            { tokenId: ctx.pftTokenId, amount: aptToExchange },  // Buyer gets 10,000 PFT\n          ]),\n        ])\n        .sendChangeTo(ctx.buyer.address)      // Change back to buyer\n        .payFee(RECOMMENDED_MIN_FEE_VALUE)     // 0.001 ERG fee\n        .build();\n\n      // Execute transaction (contract validates minimum reached + exchange ratio)\n      const result = ctx.mockChain.execute(transaction, { signers: [ctx.buyer], throw: false });\n\n      expect(result).toBe(false);\n    });\n  });\n\n  describe(\"Minimum not raised\", () => {\n\n    let projectBox: Box;       // Contract box\n    let soldTokens: bigint;\n\n    beforeEach(() => {\n      // STEP 1: Initialize test context with BASE_TOKEN (see bene_contract_helpers.ts to change)\n      ctx = setupBeneTestContext(mode.token, mode.tokenName);\n\n      // STEP 2: Create project box with MINIMUM FUNDING REACHED\n      // IMPORTANT: Exchange only works when sold >= minimumTokensSold\n      soldTokens = ctx.minimumTokensSold - 1n; // 49,000 tokens sold = minimum NOT reached!\n      const collectedFunds = soldTokens * ctx.exchangeRate;\n\n      let value = RECOMMENDED_MIN_FEE_VALUE;\n      const assets = [\n        { tokenId: ctx.projectNftId, amount: 1n + ctx.totalPFTokens - soldTokens }, // APT: 1 + 100k - 49k = 50,000 remaining\n        { tokenId: ctx.pftTokenId, amount: ctx.totalPFTokens },                     // PFT: 100,000 still available to be exchanged\n      ];\n\n      if (!ctx.isErgMode) {\n        // USD Mode: Add funds as a token\n        assets.push({ tokenId: ctx.baseTokenId, amount: collectedFunds });  // 49K USD raised\n      }\n      else {\n        value += collectedFunds; // 1.1M + 49K nanoERG raised\n      }\n\n      ctx.beneContract.addUTxOs({\n        value: value,\n        ergoTree: ctx.beneErgoTree.toHex(),\n        assets: assets,\n        creationHeight: ctx.mockChain.height - 100,  // Created 100 blocks ago\n        additionalRegisters: {\n          R4: createR4(ctx),                               // Deadline\n          R5: SLong(ctx.minimumTokensSold).toHex(),                          // Minimum: 50k\n          R6: SColl(SLong, [soldTokens, 0n, 0n]).toHex(),                    // [49k sold, 0 refunded, 0 exchanged]\n          R7: SLong(ctx.exchangeRate).toHex(),  // [price, token_len]\n          R8: ctx.constants.toHex(),\n          R9: SColl(SByte, stringToBytes(\"utf8\", \"{}\")).toHex(),\n        },\n      });\n\n      // STEP 3: Give buyer APT tokens to exchange (simulating previous purchase)\n      const aptToExchange = 10_000n;\n      ctx.buyer.addUTxOs({\n        value: 10_000_000_000n,                                     // 10 ERG for transaction fees\n        ergoTree: ctx.buyer.address.ergoTree,                       // Buyer's address\n        assets: [{ tokenId: ctx.projectNftId, amount: aptToExchange }],  // Buyer has 10,000 APT to exchange\n        creationHeight: ctx.mockChain.height - 50,                  // Acquired 50 blocks ago\n        additionalRegisters: {},\n      });\n\n      // STEP 4: Get reference to project box\n      projectBox = ctx.beneContract.utxos.toArray()[0];\n    });\n\n    it(\"should not allow exchanging APT tokens for PFT tokens\", () => {\n      // ARRANGE: Prepare exchange transaction\n      // Find buyer's box containing APT tokens\n      const buyerAPTBox = ctx.buyer.utxos\n        .toArray()\n        .find((box) => box.assets.some((asset) => asset.tokenId === ctx.projectNftId))!;\n      const aptToExchange = buyerAPTBox.assets[0].amount;  // 10,000 APT to exchange\n\n\n      const currentExchangeCounter = 0n;                           // Current exchange counter from R6[2]\n      const newExchangeCounter = currentExchangeCounter + aptToExchange;  // Increment to 10,000\n\n      // Calculate new token amounts after exchange\n      const newAPTAmount = BigInt(projectBox.assets[0].amount) + aptToExchange;  // Contract gains: 50,001 + 10k = 60,001 APT\n      const newPFTAmount = BigInt(projectBox.assets[1].amount) - aptToExchange;  // Contract loses: 100k - 10k = 90k PFT\n\n      const contractAssets = [\n        { tokenId: ctx.projectNftId, amount: newAPTAmount },  // 60,001 APT (gained 10k)\n        { tokenId: ctx.pftTokenId, amount: newPFTAmount },    // 90,000 PFT (lost 10k)\n      ];\n\n      if (!ctx.isErgMode) {\n        const currentBaseTokenAmount = projectBox.assets.find((asset) => asset.tokenId === ctx.baseTokenId)!.amount;\n        contractAssets.push({ tokenId: ctx.baseTokenId, amount: BigInt(currentBaseTokenAmount) });\n      }\n\n      // Build and execute exchange transaction\n      const transaction = new TransactionBuilder(ctx.mockChain.height)\n        .from([projectBox, buyerAPTBox])\n        .to([\n          // Output 0: Updated contract (gains APT, loses PFT)\n          new OutputBuilder(projectBox.value, ctx.beneErgoTree)  // ERG value unchanged\n            .addTokens(contractAssets)\n            .setAdditionalRegisters({\n              R4: projectBox.additionalRegisters.R4,\n              R5: SLong(ctx.minimumTokensSold).toHex(),\n              R6: SColl(SLong, [soldTokens, 0n, newExchangeCounter]).toHex(),  // [49k, 0, 10k] - exchange counter updated\n              R7: SLong(ctx.exchangeRate).toHex(),\n              R8: projectBox.additionalRegisters.R8,\n              R9: projectBox.additionalRegisters.R9,\n            }),\n          // Output 1: Buyer receives PFT tokens (1:1 exchange ratio)\n          new OutputBuilder(RECOMMENDED_MIN_FEE_VALUE, ctx.buyer.address).addTokens([\n            { tokenId: ctx.pftTokenId, amount: aptToExchange },  // Buyer gets 10,000 PFT\n          ]),\n        ])\n        .sendChangeTo(ctx.buyer.address)      // Change back to buyer\n        .payFee(RECOMMENDED_MIN_FEE_VALUE)     // 0.001 ERG fee\n        .build();\n\n      // Execute transaction (contract validates minimum reached + exchange ratio)\n      const result = ctx.mockChain.execute(transaction, { signers: [ctx.buyer], throw: false });\n\n      // ASSERT: Verify exchange succeeded\n      expect(result).toBe(false);\n    });\n  })\n\n  describe(\"Minimum was raised, but actually not\", () => {\n\n    let projectBox: Box;       // Contract box\n    let soldTokens: bigint;\n    let refundTokens: bigint;\n\n    beforeEach(() => {\n      // STEP 1: Initialize test context with BASE_TOKEN (see bene_contract_helpers.ts to change)\n      ctx = setupBeneTestContext(mode.token, mode.tokenName);\n\n      // STEP 2: Create project box with MINIMUM FUNDING REACHED\n      // IMPORTANT: Exchange only works when sold >= minimumTokensSold\n      soldTokens = ctx.minimumTokensSold; // 50,000 tokens sold = minimum reached!\n      refundTokens = 1n;\n      const netSoldTokens = soldTokens - refundTokens;\n\n      const collectedFunds = netSoldTokens * ctx.exchangeRate;\n\n      let value = RECOMMENDED_MIN_FEE_VALUE;\n      const assets = [\n        { tokenId: ctx.projectNftId, amount: 1n + ctx.totalPFTokens - netSoldTokens }, // APT: 1 + 100k - 49k\n        { tokenId: ctx.pftTokenId, amount: ctx.totalPFTokens },                     // PFT: 100,000 still available to be exchanged\n      ];\n\n      if (!ctx.isErgMode) {\n        // USD Mode: Add funds as a token\n        assets.push({ tokenId: ctx.baseTokenId, amount: collectedFunds });  // 50K USD raised\n      }\n      else {\n        value += collectedFunds; // 1.1M + 50K nanoERG raised\n      }\n\n      ctx.beneContract.addUTxOs({\n        value: value,\n        ergoTree: ctx.beneErgoTree.toHex(),\n        assets: assets,\n        creationHeight: ctx.mockChain.height - 100,  // Created 100 blocks ago\n        additionalRegisters: {\n          R4: createR4(ctx),                               // Deadline\n          R5: SLong(ctx.minimumTokensSold).toHex(),                          // Minimum: 50k\n          R6: SColl(SLong, [soldTokens, refundTokens, 0n]).toHex(),                    // [50k sold, 1 refunded, 0 exchanged]\n          R7: SLong(ctx.exchangeRate).toHex(),  // [price, token_len]\n          R8: ctx.constants.toHex(),\n          R9: SColl(SByte, stringToBytes(\"utf8\", \"{}\")).toHex(),\n        },\n      });\n\n      // STEP 3: Give buyer APT tokens to exchange (simulating previous purchase)\n      const aptToExchange = 10_000n;\n      ctx.buyer.addUTxOs({\n        value: 10_000_000_000n,                                     // 10 ERG for transaction fees\n        ergoTree: ctx.buyer.address.ergoTree,                       // Buyer's address\n        assets: [{ tokenId: ctx.projectNftId, amount: aptToExchange }],  // Buyer has 10,000 APT to exchange\n        creationHeight: ctx.mockChain.height - 50,                  // Acquired 50 blocks ago\n        additionalRegisters: {},\n      });\n\n      // STEP 4: Get reference to project box\n      projectBox = ctx.beneContract.utxos.toArray()[0];\n    });\n\n    it(\"should allow exchanging APT tokens for PFT tokens\", () => {\n      // ARRANGE: Prepare exchange transaction\n      // Find buyer's box containing APT tokens\n      const buyerAPTBox = ctx.buyer.utxos\n        .toArray()\n        .find((box) => box.assets.some((asset) => asset.tokenId === ctx.projectNftId))!;\n      const aptToExchange = buyerAPTBox.assets[0].amount;  // 10,000 APT to exchange\n\n      const currentExchangeCounter = 0n;                           // Current exchange counter from R6[2]\n      const newExchangeCounter = currentExchangeCounter + aptToExchange;  // Increment to 10,000\n\n      // Calculate new token amounts after exchange\n      const newAPTAmount = BigInt(projectBox.assets[0].amount) + aptToExchange;  // Contract gains: 50,001 + 10k = 60,001 APT\n      const newPFTAmount = BigInt(projectBox.assets[1].amount) - aptToExchange;  // Contract loses: 100k - 10k = 90k PFT\n\n      const contractAssets = [\n        { tokenId: ctx.projectNftId, amount: newAPTAmount },  // 60,001 APT (gained 10k)\n        { tokenId: ctx.pftTokenId, amount: newPFTAmount },    // 90,000 PFT (lost 10k)\n      ];\n\n      if (!ctx.isErgMode) {\n        const currentBaseTokenAmount = projectBox.assets.find((asset) => asset.tokenId === ctx.baseTokenId)!.amount;\n        contractAssets.push({ tokenId: ctx.baseTokenId, amount: BigInt(currentBaseTokenAmount) });\n      }\n\n      // Build and execute exchange transaction\n      const transaction = new TransactionBuilder(ctx.mockChain.height)\n        .from([projectBox, buyerAPTBox])\n        .to([\n          // Output 0: Updated contract (gains APT, loses PFT)\n          new OutputBuilder(projectBox.value, ctx.beneErgoTree)  // ERG value unchanged\n            .addTokens(contractAssets)\n            .setAdditionalRegisters({\n              R4: projectBox.additionalRegisters.R4,\n              R5: SLong(ctx.minimumTokensSold).toHex(),\n              R6: SColl(SLong, [soldTokens, refundTokens, newExchangeCounter]).toHex(),  // [50k, 1, 10k] - exchange counter updated\n              R7: SLong(ctx.exchangeRate).toHex(),\n              R8: projectBox.additionalRegisters.R8,\n              R9: projectBox.additionalRegisters.R9,\n            }),\n          // Output 1: Buyer receives PFT tokens (1:1 exchange ratio)\n          new OutputBuilder(RECOMMENDED_MIN_FEE_VALUE, ctx.buyer.address).addTokens([\n            { tokenId: ctx.pftTokenId, amount: aptToExchange },  // Buyer gets 10,000 PFT\n          ]),\n        ])\n        .sendChangeTo(ctx.buyer.address)      // Change back to buyer\n        .payFee(RECOMMENDED_MIN_FEE_VALUE)     // 0.001 ERG fee\n        .build();\n\n      // Execute transaction (contract validates minimum reached + exchange ratio)\n      const result = ctx.mockChain.execute(transaction, { signers: [ctx.buyer], throw: false });\n\n      expect(result).toBe(false);                          // Transaction failed\n    });\n  });\n\n  describe(\"Some APT exchanged\", () => {\n\n    let projectBox: Box;\n    let soldTokens: bigint;\n    let alreadyExchanged: bigint;\n\n    beforeEach(() => {\n      ctx = setupBeneTestContext(mode.token, mode.tokenName);\n\n      soldTokens = ctx.minimumTokensSold;\n      alreadyExchanged = 5_000n;\n      const collectedFunds = soldTokens * ctx.exchangeRate;\n\n      let value = RECOMMENDED_MIN_FEE_VALUE;\n      const assets = [\n        { tokenId: ctx.projectNftId, amount: 1n + ctx.totalPFTokens - soldTokens + alreadyExchanged },\n        { tokenId: ctx.pftTokenId, amount: ctx.totalPFTokens - alreadyExchanged },\n      ];\n\n      if (!ctx.isErgMode) {\n        assets.push({ tokenId: ctx.baseTokenId, amount: collectedFunds });\n      }\n      else {\n        value += collectedFunds;\n      }\n\n      ctx.beneContract.addUTxOs({\n        value: value,\n        ergoTree: ctx.beneErgoTree.toHex(),\n        assets: assets,\n        creationHeight: ctx.mockChain.height - 100,\n        additionalRegisters: {\n          R4: createR4(ctx),\n          R5: SLong(ctx.minimumTokensSold).toHex(),\n          R6: SColl(SLong, [soldTokens, 0n, alreadyExchanged]).toHex(),\n          R7: SLong(ctx.exchangeRate).toHex(),\n          R8: ctx.constants.toHex(),\n          R9: SColl(SByte, stringToBytes(\"utf8\", \"{}\")).toHex(),\n        },\n      });\n\n      const aptToExchange = 10_000n;\n      ctx.buyer.addUTxOs({\n        value: 10_000_000_000n,\n        ergoTree: ctx.buyer.address.ergoTree,\n        assets: [{ tokenId: ctx.projectNftId, amount: aptToExchange }],\n        creationHeight: ctx.mockChain.height - 50,\n        additionalRegisters: {},\n      });\n\n      projectBox = ctx.beneContract.utxos.toArray()[0];\n    });\n\n    it(\"should allow exchanging APT tokens for PFT tokens\", () => {\n      const buyerAPTBox = ctx.buyer.utxos\n        .toArray()\n        .find((box) => box.assets.some((asset) => asset.tokenId === ctx.projectNftId))!;\n      const aptToExchange = buyerAPTBox.assets[0].amount;\n\n      const currentExchangeCounter = alreadyExchanged;\n      const newExchangeCounter = currentExchangeCounter + aptToExchange;\n\n      const newAPTAmount = BigInt(projectBox.assets[0].amount) + aptToExchange;\n      const newPFTAmount = BigInt(projectBox.assets[1].amount) - aptToExchange;\n\n      const contractAssets = [\n        { tokenId: ctx.projectNftId, amount: newAPTAmount },\n        { tokenId: ctx.pftTokenId, amount: newPFTAmount },\n      ];\n\n      if (!ctx.isErgMode) {\n        const currentBaseTokenAmount = projectBox.assets.find((asset) => asset.tokenId === ctx.baseTokenId)!.amount;\n        contractAssets.push({ tokenId: ctx.baseTokenId, amount: BigInt(currentBaseTokenAmount) });\n      }\n\n      const transaction = new TransactionBuilder(ctx.mockChain.height)\n        .from([projectBox, buyerAPTBox])\n        .to([\n          new OutputBuilder(projectBox.value, ctx.beneErgoTree)\n            .addTokens(contractAssets)\n            .setAdditionalRegisters({\n              R4: projectBox.additionalRegisters.R4,\n              R5: SLong(ctx.minimumTokensSold).toHex(),\n              R6: SColl(SLong, [soldTokens, 0n, newExchangeCounter]).toHex(),\n              R7: SLong(ctx.exchangeRate).toHex(),\n              R8: projectBox.additionalRegisters.R8,\n              R9: projectBox.additionalRegisters.R9,\n            }),\n          new OutputBuilder(RECOMMENDED_MIN_FEE_VALUE, ctx.buyer.address).addTokens([\n            { tokenId: ctx.pftTokenId, amount: aptToExchange },\n          ]),\n        ])\n        .sendChangeTo(ctx.buyer.address)\n        .payFee(RECOMMENDED_MIN_FEE_VALUE)\n        .build();\n\n      const result = ctx.mockChain.execute(transaction, { signers: [ctx.buyer] });\n\n      expect(result).toBe(true);\n      expect(ctx.beneContract.utxos.length).toEqual(1);\n\n      const updatedBox = ctx.beneContract.utxos.toArray()[0];\n      expect(updatedBox.assets[0].amount).toEqual(newAPTAmount);\n      expect(updatedBox.assets[1].amount).toEqual(newPFTAmount);\n\n      const buyerPFTBox = ctx.buyer.utxos\n        .toArray()\n        .find((box) => box.assets.some((asset) => asset.tokenId === ctx.pftTokenId));\n      expect(buyerPFTBox).toBeDefined();\n      expect(buyerPFTBox!.assets[0].amount).toEqual(aptToExchange);\n    });\n\n    it(\"should fail when exchange ratio is incorrect\", () => {\n      const buyerAPTBox = ctx.buyer.utxos\n        .toArray()\n        .find((box) => box.assets.some((asset) => asset.tokenId === ctx.projectNftId))!;\n      const aptToExchange = buyerAPTBox.assets[0].amount;\n      const pftToExtract = aptToExchange * 2n;\n\n      const currentExchangeCounter = alreadyExchanged;\n      const newExchangeCounter = currentExchangeCounter + pftToExtract;\n\n      const newAPTAmount = BigInt(projectBox.assets[0].amount) + aptToExchange;\n      const newPFTAmount = BigInt(projectBox.assets[1].amount) - pftToExtract;\n\n      const contractAssets = [\n        { tokenId: ctx.projectNftId, amount: newAPTAmount },\n        { tokenId: ctx.pftTokenId, amount: newPFTAmount },\n      ];\n\n      if (!ctx.isErgMode) {\n        const currentBaseTokenAmount = projectBox.assets.find((asset) => asset.tokenId === ctx.baseTokenId)!.amount;\n        contractAssets.push({ tokenId: ctx.baseTokenId, amount: BigInt(currentBaseTokenAmount) });\n      }\n\n      const transaction = new TransactionBuilder(ctx.mockChain.height)\n        .from([projectBox, buyerAPTBox])\n        .to([\n          new OutputBuilder(projectBox.value, ctx.beneErgoTree)\n            .addTokens(contractAssets)\n            .setAdditionalRegisters({\n              R4: projectBox.additionalRegisters.R4,\n              R5: SLong(ctx.minimumTokensSold).toHex(),\n              R6: SColl(SLong, [soldTokens, 0n, newExchangeCounter]).toHex(),\n              R7: SLong(ctx.exchangeRate).toHex(),\n              R8: projectBox.additionalRegisters.R8,\n              R9: projectBox.additionalRegisters.R9,\n            }),\n          new OutputBuilder(RECOMMENDED_MIN_FEE_VALUE, ctx.buyer.address).addTokens([\n            { tokenId: ctx.pftTokenId, amount: pftToExtract },\n          ]),\n        ])\n        .sendChangeTo(ctx.buyer.address)\n        .payFee(RECOMMENDED_MIN_FEE_VALUE)\n        .build();\n\n      const result = ctx.mockChain.execute(transaction, { signers: [ctx.buyer], throw: false });\n\n      expect(result).toBe(false);\n    });\n\n    it(\"should fail when tries to avoid increment exchange counter\", () => {\n      const buyerAPTBox = ctx.buyer.utxos\n        .toArray()\n        .find((box) => box.assets.some((asset) => asset.tokenId === ctx.projectNftId))!;\n      const aptToExchange = buyerAPTBox.assets[0].amount;\n\n      const newExchangeCounter = alreadyExchanged;\n\n      const newAPTAmount = BigInt(projectBox.assets[0].amount) + aptToExchange;\n      const newPFTAmount = BigInt(projectBox.assets[1].amount) - aptToExchange;\n\n      const contractAssets = [\n        { tokenId: ctx.projectNftId, amount: newAPTAmount },\n        { tokenId: ctx.pftTokenId, amount: newPFTAmount },\n      ];\n\n      if (!ctx.isErgMode) {\n        const currentBaseTokenAmount = projectBox.assets.find((asset) => asset.tokenId === ctx.baseTokenId)!.amount;\n        contractAssets.push({ tokenId: ctx.baseTokenId, amount: BigInt(currentBaseTokenAmount) });\n      }\n\n      const transaction = new TransactionBuilder(ctx.mockChain.height)\n        .from([projectBox, buyerAPTBox])\n        .to([\n          new OutputBuilder(projectBox.value, ctx.beneErgoTree)\n            .addTokens(contractAssets)\n            .setAdditionalRegisters({\n              R4: projectBox.additionalRegisters.R4,\n              R5: SLong(ctx.minimumTokensSold).toHex(),\n              R6: SColl(SLong, [soldTokens, 0n, newExchangeCounter]).toHex(),\n              R7: SLong(ctx.exchangeRate).toHex(),\n              R8: projectBox.additionalRegisters.R8,\n              R9: projectBox.additionalRegisters.R9,\n            }),\n          new OutputBuilder(RECOMMENDED_MIN_FEE_VALUE, ctx.buyer.address).addTokens([\n            { tokenId: ctx.pftTokenId, amount: aptToExchange },\n          ]),\n        ])\n        .sendChangeTo(ctx.buyer.address)\n        .payFee(RECOMMENDED_MIN_FEE_VALUE)\n        .build();\n\n      const result = ctx.mockChain.execute(transaction, { signers: [ctx.buyer], throw: false });\n\n      expect(result).toBe(false);\n    });\n\n    it(\"should fail when tries to modify refund counter\", () => {\n      const buyerAPTBox = ctx.buyer.utxos\n        .toArray()\n        .find((box) => box.assets.some((asset) => asset.tokenId === ctx.projectNftId))!;\n      const aptToExchange = buyerAPTBox.assets[0].amount;\n\n      const currentExchangeCounter = alreadyExchanged;\n      const newExchangeCounter = currentExchangeCounter + aptToExchange;\n\n      const newAPTAmount = BigInt(projectBox.assets[0].amount) + aptToExchange;\n      const newPFTAmount = BigInt(projectBox.assets[1].amount) - aptToExchange;\n\n      const contractAssets = [\n        { tokenId: ctx.projectNftId, amount: newAPTAmount },\n        { tokenId: ctx.pftTokenId, amount: newPFTAmount },\n      ];\n\n      if (!ctx.isErgMode) {\n        const currentBaseTokenAmount = projectBox.assets.find((asset) => asset.tokenId === ctx.baseTokenId)!.amount;\n        contractAssets.push({ tokenId: ctx.baseTokenId, amount: BigInt(currentBaseTokenAmount) });\n      }\n\n      const transaction = new TransactionBuilder(ctx.mockChain.height)\n        .from([projectBox, buyerAPTBox])\n        .to([\n          new OutputBuilder(projectBox.value, ctx.beneErgoTree)\n            .addTokens(contractAssets)\n            .setAdditionalRegisters({\n              R4: projectBox.additionalRegisters.R4,\n              R5: SLong(ctx.minimumTokensSold).toHex(),\n              R6: SColl(SLong, [soldTokens, 1n, newExchangeCounter]).toHex(),\n              R7: SLong(ctx.exchangeRate).toHex(),\n              R8: projectBox.additionalRegisters.R8,\n              R9: projectBox.additionalRegisters.R9,\n            }),\n          new OutputBuilder(RECOMMENDED_MIN_FEE_VALUE, ctx.buyer.address).addTokens([\n            { tokenId: ctx.pftTokenId, amount: aptToExchange },\n          ]),\n        ])\n        .sendChangeTo(ctx.buyer.address)\n        .payFee(RECOMMENDED_MIN_FEE_VALUE)\n        .build();\n\n      const result = ctx.mockChain.execute(transaction, { signers: [ctx.buyer], throw: false });\n\n      expect(result).toBe(false);\n    });\n  });\n\n});\n","path":null,"size_bytes":37394,"size_tokens":null},"src/lib/common/load_by_id.ts":{"content":"import { type Project } from \"./project\";\nimport { project_detail } from \"./store\";\nimport { fetchProjects } from \"$lib/ergo/fetch\";\n\nexport async function loadProjectById(projectId: string) {\n    try {\n        const projects: Map<string, Project> = await fetchProjects(true);\n        const project = projects.get(projectId);\n        \n        if (!project) {\n            throw new Error(`Project with ID ${projectId} not found.`);\n        }\n        \n        project_detail.set(project);\n    } catch (error) {\n        console.error(`Failed to load project: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n}","path":null,"size_bytes":626,"size_tokens":null},"src/lib/components/ui/carousel/context.ts":{"content":"import type { EmblaCarouselSvelteType } from \"embla-carousel-svelte\";\nimport type emblaCarouselSvelte from \"embla-carousel-svelte\";\nimport { getContext, hasContext, setContext } from \"svelte\";\nimport type { HTMLAttributes } from \"svelte/elements\";\nimport type { Readable, Writable } from \"svelte/store\";\n\nexport type CarouselAPI =\n\tNonNullable<NonNullable<EmblaCarouselSvelteType[\"$$_attributes\"]>[\"on:emblaInit\"]> extends (\n\t\tevt: CustomEvent<infer CarouselAPI>\n\t) => void\n\t\t? CarouselAPI\n\t\t: never;\n\ntype EmblaCarouselConfig = NonNullable<Parameters<typeof emblaCarouselSvelte>[1]>;\n\nexport type CarouselOptions = EmblaCarouselConfig[\"options\"];\nexport type CarouselPlugins = EmblaCarouselConfig[\"plugins\"];\n\n////\n\nexport type CarouselProps = {\n\topts?: CarouselOptions;\n\tplugins?: CarouselPlugins;\n\tapi?: CarouselAPI;\n\torientation?: \"horizontal\" | \"vertical\";\n} & HTMLAttributes<HTMLDivElement>;\n\nconst EMBLA_CAROUSEL_CONTEXT = Symbol(\"EMBLA_CAROUSEL_CONTEXT\");\n\ntype EmblaContext = {\n\tapi: Writable<CarouselAPI | undefined>;\n\torientation: Writable<\"horizontal\" | \"vertical\">;\n\tscrollNext: () => void;\n\tscrollPrev: () => void;\n\tcanScrollNext: Readable<boolean>;\n\tcanScrollPrev: Readable<boolean>;\n\thandleKeyDown: (e: KeyboardEvent) => void;\n\toptions: Writable<CarouselOptions>;\n\tplugins: Writable<CarouselPlugins>;\n\tonInit: (e: CustomEvent<CarouselAPI>) => void;\n\tscrollTo: (index: number, jump?: boolean) => void;\n\tscrollSnaps: Readable<number[]>;\n\tselectedIndex: Readable<number>;\n};\n\nexport function setEmblaContext(config: EmblaContext): EmblaContext {\n\tsetContext(EMBLA_CAROUSEL_CONTEXT, config);\n\treturn config;\n}\n\nexport function getEmblaContext(name = \"This component\") {\n\tif (!hasContext(EMBLA_CAROUSEL_CONTEXT)) {\n\t\tthrow new Error(`${name} must be used within a <Carousel.Root> component`);\n\t}\n\treturn getContext<ReturnType<typeof setEmblaContext>>(EMBLA_CAROUSEL_CONTEXT);\n}\n","path":null,"size_bytes":1889,"size_tokens":null},"src/lib/components/ui/checkbox/index.ts":{"content":"import Root from \"./checkbox.svelte\";\nexport {\n\tRoot,\n\t//\n\tRoot as Checkbox,\n};\n","path":null,"size_bytes":80,"size_tokens":null},"src/lib/ergo/forum/envs.ts":{"content":"export const network_id: \"mainnet\" | \"testnet\" = \"mainnet\";\n\n\nexport const PROFILE_TYPE_NFT_ID = \"1820fd428a0b92d61ce3f86cd98240fdeeee8a392900f0b19a2e017d66f79926\";\nexport const DISCUSSION_TYPE_NFT_ID = \"273f60541e8869216ee6aed5552e522d9bea29a69d88e567d089dc834da227cf\";\nexport const COMMENT_TYPE_NFT_ID = \"6c1ec833dc4aff98458b60e278fc9a0161274671d6a0c36a7429216ca99c3267\";\nexport const SPAM_FLAG_NFT_ID = \"89505ed416ad43f2dc4b3c8d0eb949e6ba9993436ceb154a58645f1484e1437a\";\nexport const PROFILE_TOTAL_SUPPLY = 99999999;\nexport const SPAM_LIMIT = 0;","path":null,"size_bytes":548,"size_tokens":null},"src/lib/wallet/adapters/safew.ts":{"content":"import { BaseWalletAdapter } from './base';\nimport type { WalletBalance, WalletDownloadUrls } from '../types';\n\nexport class SafewWalletAdapter extends BaseWalletAdapter {\n  id = 'safew';\n  name = 'SAFEW';\n  icon = '/wallet-icons/safew.svg';\n  downloadUrls: WalletDownloadUrls = {\n    chrome: 'https://chromewebstore.google.com/detail/safew-simple-and-fast-erg/fmpbldieijjehhalgjblbpgjmijencll',\n    firefox: 'https://addons.mozilla.org/en-US/firefox/addon/safew/',\n    browserExtension: 'https://github.com/ThierryM1212/SAFEW/releases/latest'\n  };\n\n  async connect(): Promise<boolean> {\n    try {\n      if (!this.isInstalled()) {\n        throw new Error('SAFEW wallet is not installed');\n      }\n\n      const safew = window.ergoConnector?.safew;\n      if (!safew) {\n        throw new Error('SAFEW connector not available');\n      }\n\n      const connected = await safew.connect();\n      if (connected) {\n        this.emit('connect');\n        return true;\n      }\n      return false;\n    } catch (error) {\n      this.handleError(error, 'connect');\n      return false; // This will never be reached due to handleError throwing, but TypeScript needs it\n    }\n  }\n\n  async disconnect(): Promise<void> {\n    try {\n      const safew = window.ergoConnector?.safew;\n      if (safew) {\n        await safew.disconnect();\n        this.emit('disconnect');\n      }\n    } catch (error) {\n      console.error('SAFEW disconnect error:', error);\n      // Don't throw on disconnect errors, just log them\n    }\n  }\n\n  async isConnected(): Promise<boolean> {\n    try {\n      const safew = window.ergoConnector?.safew;\n      if (!safew) return false;\n      return await safew.isConnected();\n    } catch (error) {\n      console.error('SAFEW isConnected error:', error);\n      return false;\n    }\n  }\n\n  async getAddresses(): Promise<string[]> {\n    try {\n      if (!(await this.isConnected())) {\n        throw new Error('Wallet not connected');\n      }\n      return await window.ergo!.get_used_addresses();\n    } catch (error) {\n      this.handleError(error, 'getAddresses');\n      return []; // This will never be reached due to handleError throwing, but prevents hanging promises\n    }\n  }\n\n  async getChangeAddress(): Promise<string> {\n    try {\n      if (!(await this.isConnected())) {\n        throw new Error('Wallet not connected');\n      }\n      return await window.ergo!.get_change_address();\n    } catch (error) {\n      this.handleError(error, 'getChangeAddress');\n      return ''; // This will never be reached due to handleError throwing, but prevents hanging promises\n    }\n  }\n\n  async getBalance(address?: string): Promise<WalletBalance> {\n    try {\n      if (!(await this.isConnected())) {\n        throw new Error('Wallet not connected');\n      }\n\n      const addr = address || await this.getChangeAddress();\n      \n      const response = await fetch(`https://api.ergoplatform.com/api/v1/addresses/${addr}/balance/confirmed`);\n      if (!response.ok) {\n        throw new Error(`API request failed with status: ${response.status}`);\n      }\n\n      const data = await response.json();\n      \n      return {\n        nanoErgs: BigInt(data.nanoErgs),\n        tokens: data.tokens.map((token: any) => ({\n          tokenId: token.tokenId,\n          amount: BigInt(token.amount),\n          name: token.name,\n          decimals: token.decimals\n        }))\n      };\n    } catch (error) {\n      this.handleError(error, 'getBalance');\n      // This will never be reached due to handleError throwing, but prevents hanging promises\n      return { nanoErgs: BigInt(0), tokens: [] };\n    }\n  }\n\n  async signTransaction(unsignedTx: any): Promise<any> {\n    try {\n      if (!(await this.isConnected())) {\n        throw new Error('Wallet not connected');\n      }\n      return await window.ergo!.sign_tx(unsignedTx);\n    } catch (error) {\n      this.handleError(error, 'signTransaction');\n    }\n  }\n\n  async submitTransaction(signedTx: any): Promise<string> {\n    try {\n      if (!(await this.isConnected())) {\n        throw new Error('Wallet not connected');\n      }\n      return await window.ergo!.submit_tx(signedTx);\n    } catch (error) {\n      this.handleError(error, 'submitTransaction');\n    }\n  }\n\n  async getNetworkId(): Promise<string> {\n    try {\n      if (!(await this.isConnected())) {\n        throw new Error('Wallet not connected');\n      }\n      // Import network_id from environment configuration\n      const { network_id } = await import('../../ergo/envs');\n      return network_id === 'mainnet' ? 'mainnet' : 'testnet';\n    } catch (error) {\n      this.handleError(error, 'getNetworkId');\n    }\n  }\n\n  async getCurrentHeight(): Promise<number> {\n    try {\n      if (!(await this.isConnected())) {\n        throw new Error('Wallet not connected');\n      }\n      \n      // SafeW doesn't expose get_current_height() method\n      // Fetch from Ergo Explorer API instead\n      const response = await fetch('https://api.ergoplatform.com/api/v1/blocks?limit=1&offset=0');\n      if (!response.ok) {\n        throw new Error(`Failed to fetch current height: ${response.status}`);\n      }\n      \n      const data = await response.json();\n      if (data.items && data.items.length > 0) {\n        return data.items[0].height;\n      }\n      \n      throw new Error('Could not determine current blockchain height');\n    } catch (error) {\n      this.handleError(error, 'getCurrentHeight');\n    }\n  }\n\n  isInstalled(): boolean {\n    return typeof window !== 'undefined' && \n           typeof window.ergoConnector !== 'undefined' && \n           typeof window.ergoConnector.safew !== 'undefined';\n  }\n}\n","path":null,"size_bytes":5573,"size_tokens":null},"src/lib/components/ui/dialog/index.ts":{"content":"import { Dialog as DialogPrimitive } from \"bits-ui\";\n\nimport Title from \"./dialog-title.svelte\";\nimport Portal from \"./dialog-portal.svelte\";\nimport Footer from \"./dialog-footer.svelte\";\nimport Header from \"./dialog-header.svelte\";\nimport Overlay from \"./dialog-overlay.svelte\";\nimport Content from \"./dialog-content.svelte\";\nimport Description from \"./dialog-description.svelte\";\n\nconst Root = DialogPrimitive.Root;\nconst Trigger = DialogPrimitive.Trigger;\nconst Close = DialogPrimitive.Close;\n\nexport {\n\tRoot,\n\tTitle,\n\tPortal,\n\tFooter,\n\tHeader,\n\tTrigger,\n\tOverlay,\n\tContent,\n\tDescription,\n\tClose,\n\t//\n\tRoot as Dialog,\n\tTitle as DialogTitle,\n\tPortal as DialogPortal,\n\tFooter as DialogFooter,\n\tHeader as DialogHeader,\n\tTrigger as DialogTrigger,\n\tOverlay as DialogOverlay,\n\tContent as DialogContent,\n\tDescription as DialogDescription,\n\tClose as DialogClose,\n};\n","path":null,"size_bytes":860,"size_tokens":null},"src/lib/ergo/dev/distribute_funds.ts":{"content":"import {\n    OutputBuilder,\n    TransactionBuilder\n} from '@fleet-sdk/core';\nimport { get_dev_contract_address } from './dev_contract';\nimport { ErgoPlatform } from '../platform';\n\nexport async function distributeFunds(\n    box: any,\n    brunoAddress: string,\n    lgdAddress: string,\n    jmAddress: string,\n    orderAddress: string,\n    brunoShare: number,\n    lgdShare: number,\n    jmShare: number,\n    orderShare: number,\n    totalAmount: number,\n    tokenId?: string\n): Promise<string | null> {\n    try {\n        await (new ErgoPlatform).connect();\n\n        const minerFeeAmount = 1100000;\n        const isTokenDistribution = !!tokenId;\n        const SAFE_MIN_BOX_VALUE = 1000000; // Minimum ERG for token boxes\n\n        // For token distributions we already needed wallet UTXOs to cover ERG for outputs.\n        // The executor pays miner fee, so include wallet UTXOs when available for both ERG and token distributions.\n        let inputs = [box];\n        if (typeof window !== 'undefined' && (window as any).ergo) {\n            const walletUtxos = await (window as any).ergo!.get_utxos();\n            // prepend wallet utxos so that they can cover miner fee / additional ERG if needed\n            inputs = [box, ...walletUtxos];\n        } else {\n            // If token distribution and no wallet available, we cannot provide the extra ERG for outputs\n            if (isTokenDistribution) {\n                throw new Error(\"Token distribution requires a connected wallet to provide ERG for outputs and fees.\");\n            }\n        }\n\n        // IMPORTANT: Do NOT subtract miner fee from totalAmount.\n        // The miner fee will be paid by the executor (wallet) using the extra inputs we added above.\n\n        // Calculate individual shares from the full totalAmount (no fee subtraction)\n        const brunoAmount = Math.floor((brunoShare / 100) * totalAmount);\n        const lgdAmount = Math.floor((lgdShare / 100) * totalAmount);\n        const jmAmount = Math.floor((jmShare / 100) * totalAmount);\n        const orderAmount = Math.floor((orderShare / 100) * totalAmount);\n\n        const calculatedTotal = brunoAmount + lgdAmount + jmAmount + orderAmount;\n\n        if (totalAmount !== calculatedTotal) {\n            console.log(\"Invalid shares: The total amount does not match the sum of calculated shares.\")\n            console.log(\"Total amount: \" + totalAmount)\n            console.log(\"Calculated total: \" + calculatedTotal)\n            console.log(\"Bruno amount: \" + brunoAmount)\n            console.log(\"LGD amount: \" + lgdAmount)\n            console.log(\"JM amount: \" + jmAmount)\n            console.log(\"Order amount: \" + orderAmount)\n            throw new Error(\n                `Invalid shares: The total amount (${totalAmount}) does not match the sum of calculated shares (${calculatedTotal}). Details: Bruno (${brunoAmount}), LGD (${lgdAmount}), JM (${jmAmount}), Order (${orderAmount}).`\n            );\n        }\n\n        // Ensure valid distribution\n        if (orderAmount < 0) {\n            console.log(\"Invalid distribution: total shares exceed 100%\");\n            console.log(\"Total amount: \" + totalAmount)\n            console.log(\"Bruno: \" + brunoAmount);\n            console.log(\"LGD: \" + lgdAmount);\n            console.log(\"JM: \" + jmAmount);\n            console.log(\"Order: \" + orderAmount);\n            throw new Error(\"Invalid distribution: total shares exceed 100%\");\n        }\n\n        // Build outputs for each recipient\n        const outputs = [];\n\n        if (isTokenDistribution) {\n            // Token distribution - each output needs minimum ERG + tokens\n            outputs.push(\n                new OutputBuilder(BigInt(SAFE_MIN_BOX_VALUE), brunoAddress)\n                    .addTokens({ tokenId, amount: BigInt(brunoAmount) })\n            );\n            outputs.push(\n                new OutputBuilder(BigInt(SAFE_MIN_BOX_VALUE), lgdAddress)\n                    .addTokens({ tokenId, amount: BigInt(lgdAmount) })\n            );\n            outputs.push(\n                new OutputBuilder(BigInt(SAFE_MIN_BOX_VALUE), jmAddress)\n                    .addTokens({ tokenId, amount: BigInt(jmAmount) })\n            );\n            outputs.push(\n                new OutputBuilder(BigInt(SAFE_MIN_BOX_VALUE), orderAddress)\n                    .addTokens({ tokenId, amount: BigInt(orderAmount) })\n            );\n        } else {\n            // ERG distribution - outputs are the raw ERG amounts (miner fee NOT subtracted)\n            outputs.push(new OutputBuilder(BigInt(brunoAmount), brunoAddress));\n            outputs.push(new OutputBuilder(BigInt(lgdAmount), lgdAddress));\n            outputs.push(new OutputBuilder(BigInt(jmAmount), jmAddress));\n            outputs.push(new OutputBuilder(BigInt(orderAmount), orderAddress));\n        }\n\n        // Get wallet address for change. If wallet is present, send change back to wallet (executor pays fee).\n        // Otherwise fallback to dev contract address.\n        const changeAddress = (typeof window !== 'undefined' && (window as any).ergo)\n            ? await (window as any).ergo!.get_change_address()\n            : get_dev_contract_address();\n\n        // Build and sign the transaction\n        const unsignedTransaction = await new TransactionBuilder(await (window as any).ergo!.get_current_height())\n            .from(inputs)\n            .to(outputs)\n            .payFee(BigInt(minerFeeAmount))\n            .sendChangeTo(changeAddress)  // change goes to wallet if available (executor), otherwise dev contract\n            .build()\n            .toEIP12Object();\n\n        const signedTransaction = await (window as any).ergo!.sign_tx(unsignedTransaction);\n\n        // Submit the transaction\n        const transactionId = await (window as any).ergo!.submit_tx(signedTransaction);\n\n        console.log(\"Transaction ID:\", transactionId);\n        return transactionId;\n    } catch (error) {\n        console.error(\"Error distributing funds:\", error);\n        return null;\n    }\n}\n","path":null,"size_bytes":5969,"size_tokens":null},"src/lib/components/ui/progress/index.ts":{"content":"import Root from \"./progress.svelte\";\n\nexport {\n\tRoot,\n\t//\n\tRoot as Progress,\n};\n","path":null,"size_bytes":81,"size_tokens":null},"tests/contracts/contract_creation.test.ts":{"content":"// ===== TEST FILE: Project Creation =====\n// Tests the initial deployment of a Bene fundraising project\n// Verifies that the project box is created with correct tokens and registers\n\nimport { describe, it, expect, beforeEach } from \"vitest\";\nimport { RECOMMENDED_MIN_FEE_VALUE } from \"@fleet-sdk/core\";\nimport { SByte, SColl, SInt, SLong } from \"@fleet-sdk/serializer\";\nimport { stringToBytes } from \"@scure/base\";\nimport { setupBeneTestContext, ERG_BASE_TOKEN, ERG_BASE_TOKEN_NAME, type BeneTestContext, createR4 } from \"./bene_contract_helpers\";\n\n// EXECUTION FLOW:\n// 1. beforeEach() â†’ Creates fresh mock blockchain with setupBeneTestContext()\n// 2. Test creates initial project box with tokens and configuration\n// 3. Assertions verify the box was created correctly\n\ndescribe(\"Bene Contract v1.2 - Project Creation\", () => {\n  let ctx: BeneTestContext;  // Holds the test environment (blockchain, actors, config)\n\n  // SETUP: Runs before each test to create a fresh mock blockchain\n  beforeEach(() => {\n    // Initialize test context with BASE_TOKEN (see bene_contract_helpers.ts to change)\n    ctx = setupBeneTestContext(ERG_BASE_TOKEN, ERG_BASE_TOKEN_NAME);\n  });\n\n  describe(\"Project Creation\", () => {\n    it(\"should successfully create a Bene project box\", () => {\n      // ARRANGE: Prepare test data for contract creation\n\n      // Owner information stored in R8 register\n      const ownerDetails = JSON.stringify({\n        name: \"Project Owner\",\n        contact: \"owner@example.com\",\n      });\n\n      // Project information stored in R9 register\n      const projectMetadata = JSON.stringify({\n        title: \"Test Fundraising Project\",\n        description: \"A test project for Bene platform\",\n      });\n\n      // ACT: Create the initial project box (UTXO) on the blockchain\n      // This simulates the project owner deploying the fundraising campaign\n      ctx.beneContract.addUTxOs({\n        value: RECOMMENDED_MIN_FEE_VALUE,           // Minimum ERG value (1.1 million nanoERG)\n        ergoTree: ctx.beneErgoTree.toHex(),         // Contract address/script\n\n        // TOKEN ALLOCATION:\n        assets: [\n          { tokenId: ctx.projectNftId, amount: 1n },              // APT NFT (project identifier)\n          { tokenId: ctx.pftTokenId, amount: ctx.totalPFTokens }, // 100,000 PFT tokens to sell\n        ],\n\n        creationHeight: ctx.mockChain.height,       // Created at current block height\n\n        // CONTRACT REGISTERS (Storage slots R4-R9):\n        additionalRegisters: {\n          R4: createR4(ctx),                              // Deadline: block 800,200\n          R5: SLong(ctx.minimumTokensSold).toHex(),                         // Minimum to sell: 50,000 tokens\n          R6: SColl(SLong, [0n, 0n, 0n]).toHex(),                           // Counters: [sold, refunded, exchanged] = [0, 0, 0]\n          R7: SLong(ctx.exchangeRate).toHex(), // [price, token_id_length] = [1M, 0]\n          R8: SColl(SByte, stringToBytes(\"utf8\", ownerDetails)).toHex(),    // Owner details (JSON)\n          R9: SColl(SByte, stringToBytes(\"utf8\", projectMetadata)).toHex(), // Project metadata (JSON)\n        },\n      });\n\n      // Get the created box from contract's UTXOs\n      const projectBox = ctx.beneContract.utxos.toArray()[0];\n\n      // ASSERT: Verify the project box was created correctly\n      expect(projectBox).toBeDefined();                                    // Box exists\n      expect(projectBox.value).toEqual(RECOMMENDED_MIN_FEE_VALUE);         // Has minimum ERG\n      expect(projectBox.assets).toHaveLength(2);                           // Has exactly 2 tokens\n      expect(projectBox.assets[0].tokenId).toEqual(ctx.projectNftId);      // First token is APT NFT\n      expect(projectBox.assets[0].amount).toEqual(1n);                     // Has 1 NFT\n      expect(projectBox.assets[1].tokenId).toEqual(ctx.pftTokenId);        // Second token is PFT\n      expect(projectBox.assets[1].amount).toEqual(ctx.totalPFTokens);      // Has 100,000 PFT tokens\n    });\n  });\n});\n","path":null,"size_bytes":3997,"size_tokens":null},"src/lib/common/countdown.ts":{"content":"import { type Platform } from \"./platform\";\n\n\n\nexport async function block_to_time(target_block: number, platform: Platform): Promise<number>\n{\n    let current_block = await platform.get_current_height();\n    let diff_block = target_block - current_block;\n\n    let diff_time = diff_block * platform.time_per_block;\n    \n    return new Date().getTime() + diff_time;\n}\n\nexport async function block_to_date(target_block: number, platform: Platform): Promise<string>\n{\n    const blockTime = await block_to_time(target_block, platform);\n    const date = new Date(blockTime);\n    // Format date as YYYY-MM-DD HH:MM UTC\n    return `${date.getUTCFullYear()}-${(date.getUTCMonth() + 1).toString().padStart(2, '0')}-${date.getUTCDate().toString().padStart(2, '0')} ${date.getUTCHours().toString().padStart(2, '0')}:${date.getUTCMinutes().toString().padStart(2, '0')} UTC`;\n}\n\nexport async function time_to_block(target_time: number, platform: Platform): Promise<number>\n{\n    // Get the current block height\n    let current_block = await platform.get_current_height();\n    \n    // Get the current timestamp in milliseconds\n    let current_time = new Date().getTime();\n    \n    // Calculate the time difference in milliseconds\n    let diff_time = target_time - current_time;\n    \n    // Calculate the number of blocks that will pass until the target time\n    let diff_blocks = Math.ceil(diff_time / platform.time_per_block);\n    \n    // Calculate the target block number\n    return current_block + diff_blocks;\n}\n","path":null,"size_bytes":1502,"size_tokens":null},"src/lib/components/ui/menubar/index.ts":{"content":"import { Menubar as MenubarPrimitive } from \"bits-ui\";\n\nimport Root from \"./menubar.svelte\";\nimport CheckboxItem from \"./menubar-checkbox-item.svelte\";\nimport Content from \"./menubar-content.svelte\";\nimport Item from \"./menubar-item.svelte\";\nimport Label from \"./menubar-label.svelte\";\nimport RadioItem from \"./menubar-radio-item.svelte\";\nimport Separator from \"./menubar-separator.svelte\";\nimport Shortcut from \"./menubar-shortcut.svelte\";\nimport SubContent from \"./menubar-sub-content.svelte\";\nimport SubTrigger from \"./menubar-sub-trigger.svelte\";\nimport Trigger from \"./menubar-trigger.svelte\";\n\nconst Menu = MenubarPrimitive.Menu;\nconst Group = MenubarPrimitive.Group;\nconst Sub = MenubarPrimitive.Sub;\nconst RadioGroup = MenubarPrimitive.RadioGroup;\n\nexport {\n\tRoot,\n\tCheckboxItem,\n\tContent,\n\tItem,\n\tLabel,\n\tRadioItem,\n\tSeparator,\n\tShortcut,\n\tSubContent,\n\tSubTrigger,\n\tTrigger,\n\tMenu,\n\tGroup,\n\tSub,\n\tRadioGroup,\n\t//\n\tRoot as Menubar,\n\tCheckboxItem as MenubarCheckboxItem,\n\tContent as MenubarContent,\n\tItem as MenubarItem,\n\tLabel as MenubarLabel,\n\tRadioItem as MenubarRadioItem,\n\tSeparator as MenubarSeparator,\n\tShortcut as MenubarShortcut,\n\tSubContent as MenubarSubContent,\n\tSubTrigger as MenubarSubTrigger,\n\tTrigger as MenubarTrigger,\n\tMenu as MenubarMenu,\n\tGroup as MenubarGroup,\n\tSub as MenubarSub,\n\tRadioGroup as MenubarRadioGroup,\n};\n","path":null,"size_bytes":1345,"size_tokens":null},"src/lib/ergo/dev/dev_contract.ts":{"content":"import { compile } from \"@fleet-sdk/compiler\";\nimport { blake2b256, hex, sha256 } from \"@fleet-sdk/crypto\";\nimport { uint8ArrayToHex } from \"../utils\";\nimport { Network } from \"@fleet-sdk/core\";\nimport { network_id } from \"../envs\";\nimport { distributeFunds } from \"./distribute_funds\";\nimport { explorer_uri } from \"$lib/common/store\";\nimport { get } from \"svelte/store\";\n\nimport DEV_FEE_CONTRACT from '../../../../contracts/dev_fee_contract/dev_fee.es?raw';\n\nfunction wallets() {\n    let bruno;\n    let lgd;\n    let jm;\n    let order;\n\n    if (network_id == \"mainnet\") {\n        bruno = \"9fBF4dceTsqdhsYUNVZHjsv4jqoKVzVv3KywFCycbkEXEq5j6bp\";\n        lgd = \"9gkRrMRdSstibAsVzCtYumUGbXDPQZHkfuAaqmA49FNH3tN4XDg\";\n        jm = \"9ejNy2qoifmzfCiDtEiyugthuXMriNNPhNKzzwjPtHnrK3esvbD\";\n        order = \"9h9hjN2KC3jEyCa6KEYKBotPRESdo9oa29yyKcoSLWwtaX2VvhM\";\n    }\n    else {\n        bruno = \"3WzH5yEJongYHmBJnoMs3zeK3t3fouMi3pigKdEURWcD61pU6Eve\";\n        lgd = \"3WxiAefTPNZckPoXq4sUx2SSPYyqhXppee7P1AP1C1A8bQyFP79S\";\n        jm = \"3WzH5yEJongYHmBJnoMs3zeK3t3fouMi3pigKdEURWcD61pU6Eve\";\n        order = \"3WxiAefTPNZckPoXq4sUx2SSPYyqhXppee7P1AP1C1A8bQyFP79S\";\n    }\n\n    return {\n        \"bruno\": bruno,\n        \"lgd\": lgd,\n        \"jm\": jm,\n        \"order\": order\n    }\n}\n\nfunction generate_contract(): string {\n    let w = wallets()\n    let bruno = w['bruno']\n    let lgd = w['lgd']\n    let jm = w['jm']\n    let order = w['order']\n\n    return DEV_FEE_CONTRACT\n        .replace(/`\\+bruno\\+`/g, bruno)\n        .replace(/`\\+lgd\\+`/g, lgd)\n        .replace(/`\\+jm\\+`/g, jm)\n        .replace(/`\\+order\\+`/g, order);\n}\n\nexport function get_dev_contract_hash(): string {\n    return uint8ArrayToHex(\n        blake2b256(\n            compile(generate_contract(), { version: 1, network: network_id }).bytes  // Compile contract to ergo tree\n        )                                                         // Blake2b256 hash of contract bytes\n    );\n}\n\nexport function get_dev_contract_address(): string {\n    let network = (network_id == \"mainnet\") ? Network.Mainnet : Network.Testnet;\n    return compile(generate_contract(), { version: 1, network: network_id }).toAddress(network).toString()\n}\n\nexport function get_dev_fee(): number {\n    return 5;  // Should be 5, but needs to update dev_fee_contract first; for now, no dev fees.\n}\n\nfunction get_template_hash(): string {\n    let contract = generate_contract();\n    return hex.encode(sha256(compile(contract, { version: 1, network: network_id }).template))\n}\n\nexport async function download_dev() {\n    try {\n        let params = {\n            offset: 0,\n            limit: 500,\n        };\n        let moreDataAvailable = true;\n\n        while (moreDataAvailable) {\n            const url = get(explorer_uri) + '/api/v1/boxes/unspent/search';\n            const response = await fetch(url + '?' + new URLSearchParams({\n                offset: params.offset.toString(),\n                limit: params.limit.toString(),\n            }), {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    \"ergoTreeTemplateHash\": get_template_hash(),\n                    \"registers\": {},\n                    \"constants\": {},\n                    \"assets\": []\n                }),\n            });\n\n            if (response.ok) {\n                let json_data = await response.json();\n                return json_data.items.map(e => ({\n                    boxId: e.boxId,\n                    value: e.value,\n                    assets: e.assets,\n                    ergoTree: e.ergoTree,\n                    creationHeight: e.creationHeight,\n                    additionalRegisters: Object.entries(e.additionalRegisters).reduce((acc, [key, value]) => {\n                        acc[key] = value.serializedValue;\n                        return acc;\n                    }, {} as Record<string, any>),\n                    index: e.index,\n                    transactionId: e.transactionId\n                }));\n            } else {\n                console.log(response)\n            }\n        }\n    } catch (error) {\n        console.error('Error while making the POST request:', error);\n    }\n    return []\n}\n\nexport async function execute_dev(box) {\n    try {\n        console.log(`Executing action with Box ID: ${box.boxId} and Value: ${box.value}`);\n\n        let w = wallets()\n        let bruno = w['bruno']\n        let lgd = w['lgd']\n        let jm = w['jm']\n        let order = w['order']\n\n        // Check if this is a token distribution (R4 contains token ID)\n        let tokenId: string | undefined = undefined;\n        let totalAmount = box.value;\n\n        if (box.additionalRegisters && box.additionalRegisters.R4) {\n            const r4Value = box.additionalRegisters.R4;\n\n            if (r4Value.startsWith('0e')) {\n                // Parse Coll[Byte]: 0e[length][data]\n                const lengthByte = r4Value.substring(2, 4);\n                const lengthValue = parseInt(lengthByte, 16);\n                const extractedTokenId = r4Value.substring(4, 4 + (lengthValue * 2));\n\n                // Validate token ID is 32 bytes (64 hex chars)\n                if (extractedTokenId && extractedTokenId.length === 64) {\n                    tokenId = extractedTokenId;\n\n                    // Find the token amount in box assets\n                    if (box.assets) {\n                        for (const asset of box.assets) {\n                            if (asset.tokenId === tokenId) {\n                                totalAmount = Number(asset.amount);\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        distributeFunds(box, bruno, lgd, jm, order, 32, 32, 32, 4, totalAmount, tokenId);\n    } catch (e) {\n        console.error(\"Error executing action:\", e.message);\n    }\n}\n","path":null,"size_bytes":5945,"size_tokens":null},"src/lib/ergo/actions/withdraw.ts":{"content":"import {\n    OutputBuilder,\n    TransactionBuilder,\n    SLong,\n    SInt,\n    SAFE_MIN_BOX_VALUE\n} from '@fleet-sdk/core';\nimport { SString } from '../utils';\nimport { createR8Structure, type Project } from '../../common/project';\nimport { get_ergotree_hex } from '../contract';\nimport { getCurrentHeight, getChangeAddress, signTransaction, submitTransaction } from '../wallet-utils';\nimport { get_dev_contract_address } from '../dev/dev_contract';\nimport { SColl, SPair, SByte, SBool } from '@fleet-sdk/serializer';\n\n// Function to submit a project to the blockchain\nexport async function withdraw(\n    project: Project,\n    amount: number\n): Promise<string | null> {\n\n    // Check if this is a multi-token contract (v2) with a base token\n    const isMultiToken = project.version === \"v2\" && project.base_token_id && project.base_token_id !== \"\";\n    const isERGBase = !isMultiToken;\n\n    // Convert amount to smallest unit\n    if (isERGBase) {\n        // For ERG-based contracts, convert to nanoERG\n        amount = amount * Math.pow(10, 9);\n    } else {\n        // For token-based contracts, convert to smallest unit using token decimals\n        const baseTokenDecimals = project.base_token_details?.decimals || 0;\n        amount = amount * Math.pow(10, baseTokenDecimals);\n    }\n\n    console.log(\"wants withdraw \", amount, isERGBase ? \"(ERG)\" : \"(base token)\")\n\n    // Get the wallet address (will be the project address)\n    const walletPk = await getChangeAddress();\n\n    // Get the UTXOs from the current wallet to use as inputs\n    const inputs = [project.box, ...(await window.ergo!.get_utxos())];\n\n    // Building the project output\n    let outputs: OutputBuilder[] = [];\n\n    const devAddress = project.constants.dev_addr ?? get_dev_contract_address();\n    const devFeePercentage = project.constants.dev_fee;\n\n    // Get current base token amount if multi-token\n    let currentBaseTokenAmount = 0;\n    if (isMultiToken) {\n        for (const token of project.box.assets) {\n            if (token.tokenId === project.base_token_id) {\n                currentBaseTokenAmount = Number(token.amount);\n                break;\n            }\n        }\n    }\n\n    // Calculate extracted amount based on contract logic\n    const extractedBaseAmount = isERGBase ? amount : Math.min(amount, currentBaseTokenAmount);\n\n    // Validation based on contract requirements\n    if (isERGBase) {\n        // ERG withdrawal validation\n        if (extractedBaseAmount > project.value) {\n            alert(\"Not enough ERG to withdraw.\");\n            return null;\n        }\n    } else {\n        // Token withdrawal validation\n        if (extractedBaseAmount > currentBaseTokenAmount) {\n            alert(\"Not enough base tokens to withdraw.\");\n            return null;\n        }\n    }\n\n    // Calculate dev fee and project amounts according to contract logic\n    const minnerFeeAmount = 1100000; // Contract constant\n    let devFeeAmount = Math.floor(extractedBaseAmount * devFeePercentage / 100);\n\n    // Apply contract logic: if devFeeAmount < 1, set to 0\n    if (devFeeAmount < 1) {\n        devFeeAmount = 0;\n    }\n\n    const projectAmountBase = extractedBaseAmount - devFeeAmount;\n\n    // For ERG, subtract miner fee from project amount. For base tokens, no miner fee needed.\n    const projectAmount = isERGBase ? projectAmountBase - minnerFeeAmount : projectAmountBase;\n\n    // Validation according to contract requirements\n    if (isERGBase) {\n        if (projectAmount < SAFE_MIN_BOX_VALUE) {\n            alert(\"The withdrawal amount is too small after fees.\");\n            return null;\n        }\n    } else {\n        if (projectAmount <= 0) {\n            alert(\"The withdrawal amount is too small after fees.\");\n            return null;\n        }\n    }\n\n    // Determine if this is a full withdrawal according to contract logic\n    const allFundsWithdrawn = isERGBase ?\n        (extractedBaseAmount === project.value) :\n        (extractedBaseAmount === currentBaseTokenAmount);\n    const allTokensWithdrawn = project.current_pft_amount === 0; // No PFT tokens left\n    const isFullWithdrawal = allFundsWithdrawn && allTokensWithdrawn;\n\n    console.log(\"Withdrawal details:\", {\n        extractedBaseAmount,\n        devFeeAmount,\n        projectAmount,\n        allFundsWithdrawn,\n        allTokensWithdrawn,\n        isFullWithdrawal\n    });\n\n    if (!isFullWithdrawal) {\n        // Partial withdrawal - need to replicate contract (isSelfReplication = true)\n\n        // Calculate remaining amounts for the contract\n        const remainingErg = isERGBase ?\n            BigInt(project.value - extractedBaseAmount) :\n            BigInt(project.value);\n\n        const remainingBaseToken = isERGBase ?\n            BigInt(0) :\n            BigInt(currentBaseTokenAmount - extractedBaseAmount);\n\n        const contractOutput = new OutputBuilder(\n            remainingErg,\n            get_ergotree_hex(project.constants, project.version)\n        ).addTokens({\n            tokenId: project.project_id,\n            amount: BigInt(project.current_idt_amount) // APT remains constant\n        });\n\n        // Add PFT tokens if they exist (ProofFundingTokenRemainsConstant)\n        if (project.current_pft_amount > 0) {\n            contractOutput.addTokens({\n                tokenId: project.pft_token_id,\n                amount: BigInt(project.current_pft_amount)\n            });\n        }\n\n        // Handle remaining base tokens for multi-token contracts\n        if (isMultiToken && remainingBaseToken > 0) {\n            contractOutput.addTokens({\n                tokenId: project.base_token_id!,\n                amount: remainingBaseToken\n            });\n        }\n\n        // Set registers - all counters remain constant for withdrawal\n        contractOutput.setAdditionalRegisters({\n            R4: SPair(SBool(project.is_timestamp_limit), SLong(BigInt(project.block_limit))).toHex(),\n            R5: SLong(BigInt(project.minimum_amount)).toHex(),\n            R6: SColl(SLong, [BigInt(project.sold_counter), BigInt(project.refund_counter), BigInt(project.auxiliar_exchange_counter)]).toHex(),\n            R7: SLong(BigInt(project.exchange_rate)).toHex(),\n            R8: createR8Structure(project.constants).toHex(),\n            R9: SString(project.content.raw)\n        });\n        outputs.push(contractOutput);\n    }\n    // If isFullWithdrawal is true, no contract output is created (contract ends)\n\n    // Project output (OUTPUTS(1) in contract)\n    if (isERGBase) {\n        // For ERG-based, project receives ERG\n        outputs.push(\n            new OutputBuilder(\n                BigInt(projectAmount),\n                walletPk\n            )\n        );\n    } else {\n        // For multi-token, project receives base tokens\n        outputs.push(\n            new OutputBuilder(\n                SAFE_MIN_BOX_VALUE,  // Minimum ERG for the box\n                walletPk\n            ).addTokens({\n                tokenId: project.base_token_id!,\n                amount: BigInt(projectAmount)\n            })\n        );\n    }\n\n    // Dev fee output (OUTPUTS(2) in contract)\n    if (isERGBase) {\n        // For ERG-based, dev receives ERG. A dev fee of 0 would create an invalid output,\n        // but withdrawal amounts are expected to be large enough to always generate a fee.\n        if (devFeeAmount > 0) {\n            outputs.push(\n                new OutputBuilder(\n                    BigInt(devFeeAmount),\n                    devAddress\n                )\n            );\n        }\n    } else {\n        // For multi-token, the dev output box is always created to satisfy the contract.\n        // It receives base tokens only if a fee is generated.\n        const devOutput = new OutputBuilder(\n            SAFE_MIN_BOX_VALUE,  // Minimum ERG for the box\n            devAddress\n        );\n\n        if (devFeeAmount > 0) {\n            devOutput.addTokens({\n                tokenId: project.base_token_id!,\n                amount: BigInt(devFeeAmount)\n            });\n        }\n\n        // Set R4 register with token ID as Coll[Byte] so dev fee contract can identify token distributions\n        // Convert hex string to byte array\n        const tokenIdBytes = project.base_token_id!.match(/.{1,2}/g)!.map(byte => parseInt(byte, 16));\n        devOutput.setAdditionalRegisters({\n            R4: SColl(SByte, tokenIdBytes).toHex()\n        });\n\n        outputs.push(devOutput);\n    }\n\n    console.log(outputs)\n\n    // Building the unsigned transaction\n    const unsignedTransaction = await new TransactionBuilder(await getCurrentHeight())\n        .from(inputs)                          // Inputs coming from the user's UTXOs\n        .to(outputs)                           // Outputs (the new project box)\n        .sendChangeTo(walletPk)                // Send change back to the wallet\n        .payFee(BigInt(1100000))               // Pay the recommended minimum fee\n        .build()                               // Build the transaction\n        .toEIP12Object();                      // Convert the transaction to an EIP-12 compatible object\n\n    try {\n        // Sign the transaction\n        const signedTransaction = await signTransaction(unsignedTransaction);\n\n        // Send the transaction to the Ergo network\n        const transactionId = await submitTransaction(signedTransaction);\n\n        console.log(\"Transaction id -> \", transactionId);\n        return transactionId;\n    } catch (e) {\n        console.log(e)\n        return null;\n    }\n}","path":null,"size_bytes":9422,"size_tokens":null},"src/lib/components/ui/dropdown-menu/index.ts":{"content":"import { DropdownMenu as DropdownMenuPrimitive } from \"bits-ui\";\nimport Item from \"./dropdown-menu-item.svelte\";\nimport Label from \"./dropdown-menu-label.svelte\";\nimport Content from \"./dropdown-menu-content.svelte\";\nimport Shortcut from \"./dropdown-menu-shortcut.svelte\";\nimport RadioItem from \"./dropdown-menu-radio-item.svelte\";\nimport Separator from \"./dropdown-menu-separator.svelte\";\nimport RadioGroup from \"./dropdown-menu-radio-group.svelte\";\nimport SubContent from \"./dropdown-menu-sub-content.svelte\";\nimport SubTrigger from \"./dropdown-menu-sub-trigger.svelte\";\nimport CheckboxItem from \"./dropdown-menu-checkbox-item.svelte\";\n\nconst Sub = DropdownMenuPrimitive.Sub;\nconst Root = DropdownMenuPrimitive.Root;\nconst Trigger = DropdownMenuPrimitive.Trigger;\nconst Group = DropdownMenuPrimitive.Group;\n\nexport {\n\tSub,\n\tRoot,\n\tItem,\n\tLabel,\n\tGroup,\n\tTrigger,\n\tContent,\n\tShortcut,\n\tSeparator,\n\tRadioItem,\n\tSubContent,\n\tSubTrigger,\n\tRadioGroup,\n\tCheckboxItem,\n\t//\n\tRoot as DropdownMenu,\n\tSub as DropdownMenuSub,\n\tItem as DropdownMenuItem,\n\tLabel as DropdownMenuLabel,\n\tGroup as DropdownMenuGroup,\n\tContent as DropdownMenuContent,\n\tTrigger as DropdownMenuTrigger,\n\tShortcut as DropdownMenuShortcut,\n\tRadioItem as DropdownMenuRadioItem,\n\tSeparator as DropdownMenuSeparator,\n\tRadioGroup as DropdownMenuRadioGroup,\n\tSubContent as DropdownMenuSubContent,\n\tSubTrigger as DropdownMenuSubTrigger,\n\tCheckboxItem as DropdownMenuCheckboxItem,\n};\n","path":null,"size_bytes":1439,"size_tokens":null},"tailwind.config.ts":{"content":"import { fontFamily } from \"tailwindcss/defaultTheme\";\nimport type { Config } from \"tailwindcss\";\n\nconst config: Config = {\n\tdarkMode: [\"class\"],\n\tcontent: [\"./src/**/*.{html,js,svelte,ts}\"],\n\tsafelist: [\"dark\"],\n\ttheme: {\n\t\tcontainer: {\n\t\t\tcenter: true,\n\t\t\tpadding: \"2rem\",\n\t\t\tscreens: {\n\t\t\t\t\"2xl\": \"1400px\"\n\t\t\t}\n\t\t},\n\t\textend: {\n\t\t\tcolors: {\n\t\t\t\tborder: \"hsl(var(--border) / <alpha-value>)\",\n\t\t\t\tinput: \"hsl(var(--input) / <alpha-value>)\",\n\t\t\t\tring: \"hsl(var(--ring) / <alpha-value>)\",\n\t\t\t\tbackground: \"hsl(var(--background) / <alpha-value>)\",\n\t\t\t\tforeground: \"hsl(var(--foreground) / <alpha-value>)\",\n\t\t\t\tprimary: {\n\t\t\t\t\tDEFAULT: \"hsl(var(--primary) / <alpha-value>)\",\n\t\t\t\t\tforeground: \"hsl(var(--primary-foreground) / <alpha-value>)\"\n\t\t\t\t},\n\t\t\t\tsecondary: {\n\t\t\t\t\tDEFAULT: \"hsl(var(--secondary) / <alpha-value>)\",\n\t\t\t\t\tforeground: \"hsl(var(--secondary-foreground) / <alpha-value>)\"\n\t\t\t\t},\n\t\t\t\tdestructive: {\n\t\t\t\t\tDEFAULT: \"hsl(var(--destructive) / <alpha-value>)\",\n\t\t\t\t\tforeground: \"hsl(var(--destructive-foreground) / <alpha-value>)\"\n\t\t\t\t},\n\t\t\t\tmuted: {\n\t\t\t\t\tDEFAULT: \"hsl(var(--muted) / <alpha-value>)\",\n\t\t\t\t\tforeground: \"hsl(var(--muted-foreground) / <alpha-value>)\"\n\t\t\t\t},\n\t\t\t\taccent: {\n\t\t\t\t\tDEFAULT: \"hsl(var(--accent) / <alpha-value>)\",\n\t\t\t\t\tforeground: \"hsl(var(--accent-foreground) / <alpha-value>)\"\n\t\t\t\t},\n\t\t\t\tpopover: {\n\t\t\t\t\tDEFAULT: \"hsl(var(--popover) / <alpha-value>)\",\n\t\t\t\t\tforeground: \"hsl(var(--popover-foreground) / <alpha-value>)\"\n\t\t\t\t},\n\t\t\t\tcard: {\n\t\t\t\t\tDEFAULT: \"hsl(var(--card) / <alpha-value>)\",\n\t\t\t\t\tforeground: \"hsl(var(--card-foreground) / <alpha-value>)\"\n\t\t\t\t}\n\t\t\t},\n\t\t\tborderRadius: {\n\t\t\t\tlg: \"var(--radius)\",\n\t\t\t\tmd: \"calc(var(--radius) - 2px)\",\n\t\t\t\tsm: \"calc(var(--radius) - 4px)\"\n\t\t\t},\n\t\t\tfontFamily: {\n\t\t\t\tsans: [...fontFamily.sans]\n\t\t\t}\n\t\t}\n\t},\n};\n\nexport default config;\n","path":null,"size_bytes":1807,"size_tokens":null},"src/lib/components/ui/label/index.ts":{"content":"import Root from \"./label.svelte\";\n\nexport {\n\tRoot,\n\t//\n\tRoot as Label,\n};\n","path":null,"size_bytes":75,"size_tokens":null},"src/lib/ergo/forum/commentStore.ts":{"content":"import { writable, get } from 'svelte/store';\nimport { reputation_proof } from './store';\nimport { generate_reputation_proof } from './submit';\nimport { type RPBox } from './object';\nimport { type Comment } from './commentObject';\nimport { fetchComments } from './commentFetch';\nimport {\n    COMMENT_TYPE_NFT_ID,\n    DISCUSSION_TYPE_NFT_ID,\n    PROFILE_TOTAL_SUPPLY,\n    PROFILE_TYPE_NFT_ID,\n    SPAM_FLAG_NFT_ID\n} from './envs';\n\n\n\nasync function fetchThreadsAPI(projectId: string): Promise<Comment[]> {\n    console.log(\"API: fetchThreads\", { projectId });\n    return await fetchComments(projectId);\n}\n\nexport async function createProfileBox(): Promise<string> {\n    const profileTxId = await generate_reputation_proof(\n        PROFILE_TOTAL_SUPPLY,\n        PROFILE_TOTAL_SUPPLY,\n        PROFILE_TYPE_NFT_ID,\n        undefined,\n        true,\n        { name: \"Anon\" },\n        false, // The profile box should NOT be locked\n        undefined\n    );\n\n    if (!profileTxId) {\n        throw new Error(\"Fatal error: The profile creation transaction failed to send.\");\n    }\n\n    console.warn(\n        \"User profile not found. A new one has been created. Please wait ~2 minutes for the transaction to confirm and try again.\"\n    );\n\n    return profileTxId;\n}\n\n/**\n * Gets the main box (the one with the most tokens) from the 'reputation_proof' store.\n * If the store is empty, it attempts to create the initial profile proof.\n */\nasync function getOrCreateProfileBox(): Promise<RPBox|null> {\n    const proof = get(reputation_proof);\n    \n    console.log(\"getOrCreateProfileBox: Current reputation_proof store:\", proof);\n\n    // --- Case 1: The profile proof does NOT exist ---\n    if (!proof || !proof.current_boxes || proof.current_boxes.length === 0) {\n        console.log(\"No user reputation proof found. User needs to create a profile.\");\n        console.log(\"Proof state:\", { proof, hasBoxes: proof?.current_boxes?.length });\n        return null;\n\n    } else {\n        // --- Case 2: The profile proof DOES exist ---\n        const mainBox = proof.current_boxes[0];\n\n        if (mainBox.is_locked) {\n            throw new Error(\"Error: Your main profile box is locked (is_locked=true) and cannot be spent.\");\n        }\n        if (mainBox.token_amount < 1) {\n            throw new Error(\"Error: You do not have enough reputation tokens left in your main box to perform this action.\");\n        }\n\n        console.log(\n            \"Using existing profile box as input:\",\n            mainBox.box_id,\n            \"with profile token:\",\n            mainBox.token_id\n        );\n        return mainBox;\n    }\n\n}\n\nasync function postCommentAPI(projectId: string, text: string, sentiment: boolean): Promise<Comment> {\n    console.log(\"API: postComment\", { projectId, text });\n\n    const inputProofBox = await getOrCreateProfileBox();\n    \n    if (!inputProofBox) {\n        throw new Error(\"Profile not found. Please wait for profile creation to complete and try again.\");\n    }\n\n    const tx = await generate_reputation_proof(\n        1,\n        PROFILE_TOTAL_SUPPLY,\n        DISCUSSION_TYPE_NFT_ID,\n        projectId,\n        sentiment,\n        text,\n        true,\n        inputProofBox\n    );\n\n    if (!tx) throw new Error(\"Comment transaction failed.\");\n    console.log(\"Comment transaction sent, ID:\", tx);\n\n    const newComment: Comment = {\n        id: `sim_box_${Math.random().toString(36).substring(2, 10)}`,\n        discussion: projectId,\n        authorProfileTokenId: inputProofBox.token_id,\n        text: text,\n        timestamp: Date.now(),\n        replies: [],\n        isSpam: false,\n        tx: tx,\n        posting: true,\n        sentiment: sentiment\n    };\n    return newComment;\n}\n\nasync function replyToCommentAPI(\n    parentCommentId: string,\n    projectId: string,\n    text: string,\n    sentiment: boolean\n): Promise<Comment> {\n    console.log(\"API: replyToComment\", { parentCommentId, projectId, text });\n\n    const inputProofBox = await getOrCreateProfileBox();\n    \n    if (!inputProofBox) {\n        throw new Error(\"Profile not found. Please wait for profile creation to complete and try again.\");\n    }\n\n    const tx = await generate_reputation_proof(\n        1,\n        PROFILE_TOTAL_SUPPLY,\n        COMMENT_TYPE_NFT_ID,\n        parentCommentId,\n        sentiment,\n        text,\n        true,\n        inputProofBox\n    );\n\n    if (!tx) throw new Error(\"Reply transaction failed.\");\n    console.log(\"Reply transaction sent, ID:\", tx);\n\n    const newReply: Comment = {\n        id: `sim_box_${Math.random().toString(36).substring(2, 10)}`,\n        discussion: projectId,\n        authorProfileTokenId: inputProofBox.token_id,\n        text: text,\n        timestamp: Date.now(),\n        replies: [],\n        isSpam: false,\n        tx: tx,\n        posting: true,\n        sentiment: sentiment\n    };\n    return newReply;\n}\n\nasync function flagSpamAPI(targetCommentId: string): Promise<{ targetCommentId: string }> {\n    console.log(\"API: flagSpam\", { targetCommentId });\n\n    const inputProofBox = await getOrCreateProfileBox();\n    \n    if (!inputProofBox) {\n        throw new Error(\"Profile not found. Please wait for profile creation to complete and try again.\");\n    }\n\n    const tx = await generate_reputation_proof(\n        1,\n        PROFILE_TOTAL_SUPPLY,\n        SPAM_FLAG_NFT_ID,\n        targetCommentId,\n        true,\n        null,\n        true,\n        inputProofBox\n    );\n\n    if (!tx) throw new Error(\"Spam flag transaction failed.\");\n    console.log(\"Spam transaction sent, ID:\", tx);\n\n    return { targetCommentId };\n}\n\n// --- Svelte Store ---\n\nexport const threads = writable<Comment[]>([]);\nexport const isLoading = writable<boolean>(true);\nexport const error = writable<string | null>(null);\nexport const currentProjectId = writable<string>(\n    \"716f6e863f744b9ac22c97ec7b76ea5f5908bc5b2f67c61510bfc4751384ea7a\"\n);\n\nexport async function loadThreads() {\n    isLoading.set(true);\n    error.set(null);\n    let projectId = '';\n    currentProjectId.subscribe(id => (projectId = id))();\n\n    try {\n        const data = await fetchThreadsAPI(projectId);\n        data.sort((a, b) => a.timestamp - b.timestamp);\n        threads.set(data);\n    } catch (err: any) {\n        error.set(err.message || \"Error loading comments.\");\n    } finally {\n        isLoading.set(false);\n    }\n}\n\nexport async function postComment(text: string, sentiment: boolean) {\n    console.log(\"Posting comment:\", text);\n    let projectId = '';\n    currentProjectId.subscribe(id => (projectId = id))();\n\n    try {\n        const newComment = await postCommentAPI(projectId, text, sentiment);\n\n        threads.update(currentThreadList => {\n            return [newComment, ...currentThreadList];\n        });\n    } catch (err: any) {\n        console.error(\"Error posting comment:\", err);\n        error.set(err.message || \"Error posting comment.\");\n    }\n}\n\n/**\n * Adds a reply to a parent comment at any nesting level.\n */\nfunction addReplyToThread(\n    threadsList: Comment[],\n    parentId: string,\n    newReply: Comment\n): Comment[] {\n    return threadsList.map(comment => {\n        if (comment.id === parentId) {\n            return {\n                ...comment,\n                replies: [newReply, ...(comment.replies || [])]\n            };\n        }\n\n        if (comment.replies && comment.replies.length > 0) {\n            return {\n                ...comment,\n                replies: addReplyToThread(comment.replies, parentId, newReply)\n            };\n        }\n\n        return comment;\n    });\n}\n\n/**\n * Marks a comment as spam at any nesting level.\n */\nfunction flagCommentAsSpam(threadsList: Comment[], targetId: string): Comment[] {\n    return threadsList.map(comment => {\n        if (comment.id === targetId) {\n            return { ...comment, isSpam: true, text: \"[Comment marked as spam]\" };\n        }\n        if (comment.replies && comment.replies.length > 0) {\n            return { ...comment, replies: flagCommentAsSpam(comment.replies, targetId) };\n        }\n        return comment;\n    });\n}\n\n\nexport async function replyToComment(\n    parentCommentId: string,\n    text: string,\n    sentiment: boolean\n) {\n    console.log(\"Replying to comment:\", parentCommentId, text);\n    let projectId = '';\n    currentProjectId.subscribe(id => (projectId = id))();\n\n    try {\n        const newReply = await replyToCommentAPI(parentCommentId, projectId, text, sentiment);\n\n        threads.update(currentThreadList => {\n            return addReplyToThread(currentThreadList, parentCommentId, newReply);\n        });\n    } catch (err: any) {\n        console.error(\"Error replying:\", err);\n        error.set(err.message || \"Error replying.\");\n    }\n}\n\nexport async function flagSpam(targetCommentId: string) {\n    console.log(\"Flagging as spam:\", targetCommentId);\n\n    try {\n        const { targetCommentId: confirmedId } = await flagSpamAPI(targetCommentId);\n\n        if (confirmedId) {\n            threads.update(currentThreadList => {\n                return flagCommentAsSpam(currentThreadList, confirmedId);\n            });\n        }\n    } catch (err: any) {\n        console.error(\"Error flagging spam:\", err);\n        error.set(err.message || \"Error flagging spam.\");\n    }\n}\n","path":null,"size_bytes":9169,"size_tokens":null},"src/lib/wallet/adapters/base.ts":{"content":"import type { ErgoWalletAdapter, WalletBalance, WalletEvent, WalletDownloadUrls } from '../types';\n\nexport abstract class BaseWalletAdapter implements ErgoWalletAdapter {\n  abstract id: string;\n  abstract name: string;\n  abstract icon: string;\n  abstract downloadUrls?: WalletDownloadUrls;\n  \n  protected eventListeners: Map<WalletEvent, Set<(data: any) => void>> = new Map();\n  \n  constructor() {\n    // Initialize event listener map\n    const events: WalletEvent[] = ['connect', 'disconnect', 'addressChanged', 'networkChanged', 'balanceChanged'];\n    events.forEach(event => {\n      this.eventListeners.set(event, new Set());\n    });\n  }\n  \n  // Abstract methods that must be implemented by subclasses\n  abstract connect(): Promise<boolean>;\n  abstract disconnect(): Promise<void>;\n  abstract isConnected(): Promise<boolean>;\n  abstract getAddresses(): Promise<string[]>;\n  abstract getChangeAddress(): Promise<string>;\n  abstract getBalance(address?: string): Promise<WalletBalance>;\n  abstract signTransaction(unsignedTx: any): Promise<any>;\n  abstract submitTransaction(signedTx: any): Promise<string>;\n  abstract getNetworkId(): Promise<string>;\n  abstract getCurrentHeight(): Promise<number>;\n  abstract isInstalled(): boolean;\n  \n  // Event handling implementation\n  on(event: WalletEvent, callback: (data: any) => void): void {\n    const listeners = this.eventListeners.get(event);\n    if (listeners) {\n      listeners.add(callback);\n    }\n  }\n  \n  off(event: WalletEvent, callback: (data: any) => void): void {\n    const listeners = this.eventListeners.get(event);\n    if (listeners) {\n      listeners.delete(callback);\n    }\n  }\n  \n  protected emit(event: WalletEvent, data?: any): void {\n    const listeners = this.eventListeners.get(event);\n    if (listeners) {\n      listeners.forEach(callback => {\n        try {\n          callback(data);\n        } catch (error) {\n          console.error(`Error in wallet event listener for ${event}:`, error);\n        }\n      });\n    }\n  }\n  \n  // Helper method to convert nanoErgs to ERG\n  protected nanoErgsToErg(nanoErgs: number | string): number {\n    return Number(nanoErgs) / 1e9;\n  }\n  \n  // Helper method to convert ERG to nanoErgs\n  protected ergToNanoErgs(erg: number): bigint {\n    return BigInt(Math.floor(erg * 1e9));\n  }\n  \n  // Helper method to handle errors consistently\n  protected handleError(error: any, context: string): never {\n    console.error(`${this.name} wallet error in ${context}:`, error);\n    throw new Error(`${this.name}: ${error.message || error}`);\n  }\n}\n","path":null,"size_bytes":2539,"size_tokens":null},"svelte.config.js":{"content":"import adapter from '@sveltejs/adapter-static';\nimport { vitePreprocess } from '@sveltejs/kit/vite';\n\n/** @type {import('@sveltejs/kit').Config} */\nconst config = {\n\t// Consult https://kit.svelte.dev/docs/integrations#preprocessors\n\t// for more information about preprocessors\n\tpreprocess: vitePreprocess(),\n\n\tkit: {\n\t\t// adapter-auto only supports some environments, see https://kit.svelte.dev/docs/adapter-auto for a list.\n\t\t// If your environment is not supported or you settled on a specific environment, switch out the adapter.\n\t\t// See https://kit.svelte.dev/docs/adapters for more information about adapters.\n\t\tadapter: adapter(),\n\t\tpaths: {\n            base: '',\n        }\n\t}\n};\n\nexport default config;\n","path":null,"size_bytes":711,"size_tokens":null},"src/lib/ergo/token_utils.ts":{"content":"/**\n * Utility functions for multi-token support in the Benefaction Platform\n */\n\nimport { type Project } from '../common/project';\nimport { fetch_token_details } from './fetch';\n\n/**\n * Validates if the user has sufficient base tokens for a contribution\n * @param project The project to contribute to\n * @param tokenAmount The amount of PFT tokens to buy\n * @param userBoxes The user's available UTXOs\n * @returns Promise<boolean> indicating if user has sufficient base tokens\n */\nexport async function validateBaseTokenBalance(\n    project: Project,\n    tokenAmount: number,\n    userBoxes: any[]\n): Promise<{ valid: boolean; requiredAmount: number; availableAmount: number }> {\n    const isERGBase = !project.base_token_id || project.base_token_id === \"\";\n    const requiredBaseTokenAmount = tokenAmount * project.exchange_rate;\n\n    if (isERGBase) {\n        // For ERG, check total ERG value across all boxes\n        const totalERG = userBoxes.reduce((sum, box) => sum + box.value, 0);\n        return {\n            valid: totalERG >= requiredBaseTokenAmount,\n            requiredAmount: requiredBaseTokenAmount,\n            availableAmount: totalERG\n        };\n    } else {\n        // For tokens, check specific token balance\n        let availableTokenAmount = 0;\n        for (const box of userBoxes) {\n            for (const asset of box.assets || []) {\n                if (asset.tokenId === project.base_token_id) {\n                    availableTokenAmount += Number(asset.amount);\n                }\n            }\n        }\n        \n        return {\n            valid: availableTokenAmount >= requiredBaseTokenAmount,\n            requiredAmount: requiredBaseTokenAmount,\n            availableAmount: availableTokenAmount\n        };\n    }\n}\n\n/**\n * Gets the display name and symbol for a base token\n * @param baseTokenId The base token ID (empty string for ERG)\n * @returns Promise with token display information\n */\nexport async function getBaseTokenDisplayInfo(baseTokenId: string): Promise<{\n    name: string;\n    symbol: string;\n    decimals: number;\n}> {\n    if (!baseTokenId || baseTokenId === \"\") {\n        return {\n            name: \"Ergo\",\n            symbol: \"ERG\",\n            decimals: 9\n        };\n    }\n\n    try {\n        const tokenDetails = await fetch_token_details(baseTokenId);\n        return {\n            name: tokenDetails.name,\n            symbol: tokenDetails.name, // Assuming name is used as symbol\n            decimals: tokenDetails.decimals\n        };\n    } catch (error) {\n        console.warn(`Failed to fetch token details for ${baseTokenId}:`, error);\n        return {\n            name: `Token ${baseTokenId.slice(0, 8)}...`,\n            symbol: \"TOKEN\",\n            decimals: 0\n        };\n    }\n}\n\n/**\n * Formats a base token amount for display\n * @param amount The raw token amount\n * @param decimals The number of decimals for the token\n * @param symbol The token symbol\n * @returns Formatted string for display\n */\nexport function formatBaseTokenAmount(amount: number, decimals: number, symbol: string): string {\n    const displayAmount = amount / Math.pow(10, decimals);\n    return `${displayAmount.toLocaleString()} ${symbol}`;\n}\n\n/**\n * Calculates the exchange rate display text\n * @param project The project\n * @returns Promise with formatted exchange rate text\n */\nexport async function getExchangeRateDisplay(project: Project): Promise<string> {\n    const baseTokenInfo = await getBaseTokenDisplayInfo(project.base_token_id);\n    const baseTokenAmount = formatBaseTokenAmount(\n        project.exchange_rate,\n        baseTokenInfo.decimals,\n        baseTokenInfo.symbol\n    );\n    \n    return `1 PFT = ${baseTokenAmount}`;\n}","path":null,"size_bytes":3669,"size_tokens":null},"src/lib/ergo/actions/submit.ts":{"content":"\nimport {\n    OutputBuilder,\n    SAFE_MIN_BOX_VALUE,\n    RECOMMENDED_MIN_FEE_VALUE,\n    TransactionBuilder,\n    SLong,\n    type Box,\n    BOX_VALUE_PER_BYTE,\n    ErgoAddress\n} from '@fleet-sdk/core';\nimport { SBool, SColl, SInt, SPair } from '@fleet-sdk/serializer';\nimport { SString } from '../utils';\nimport { type contract_version, get_ergotree_hex, mint_contract_address } from '../contract';\nimport { createR8Structure, type ConstantContent } from '$lib/common/project';\nimport { get_dev_contract_address, get_dev_contract_hash, get_dev_fee } from '../dev/dev_contract';\nimport { fetch_token_details, wait_until_confirmation } from '../fetch';\nimport { getCurrentHeight, getChangeAddress, signTransaction, submitTransaction } from '../wallet-utils';\nimport {\n    validateProjectContent,\n    type ProjectContent,\n    estimateRegisterSizes,\n    estimateTotalBoxSize\n} from '../utils/box-size-calculator';\n\nasync function get_token_data(token_id: string): Promise<{ amount: number, decimals: number }> {\n    let token_fetch = await fetch_token_details(token_id);\n    let id_token_amount = token_fetch['emissionAmount'] ?? 0;\n    if (id_token_amount === 0) { alert(token_id + \" token emission amount is 0.\"); throw new Error(token_id + \" token emission amount is 0.\") }\n    id_token_amount += 1;\n    return { \"amount\": id_token_amount, \"decimals\": token_fetch['decimals'] }\n}\n\nfunction playBeep(frequency = 1000, duration = 3000) {\n    const AudioContextClass = window.AudioContext || (window as any).webkitAudioContext;\n    const audioCtx = new AudioContextClass();\n    const osc = audioCtx.createOscillator();\n    const gain = audioCtx.createGain();\n\n    osc.type = \"triangle\";\n    osc.frequency.setValueAtTime(660, audioCtx.currentTime);\n\n    osc.connect(gain);\n    gain.connect(audioCtx.destination);\n\n    const now = audioCtx.currentTime;\n\n    gain.gain.setValueAtTime(0, now);\n    gain.gain.linearRampToValueAtTime(0.25, now + 0.05);\n    gain.gain.setValueAtTime(0.25, now + 0.5);\n    gain.gain.linearRampToValueAtTime(0, now + 0.55);\n\n    osc.start(now);\n    osc.stop(now + 0.55);\n}\n\nasync function* mint_tx(title: string, constants: ConstantContent, version: contract_version, amount: number, decimals: number): AsyncGenerator<string, Box, void> {\n    // Get the wallet address (will be the project address)\n    const walletPk = await getChangeAddress();\n\n    // Get the UTXOs from the current wallet to use as inputs\n    const inputs = await window.ergo!.get_utxos();\n\n    let outputs: OutputBuilder[] = [\n        new OutputBuilder(\n            SAFE_MIN_BOX_VALUE, // Minimum value in ERG that a box can have\n            mint_contract_address(constants, version)\n        )\n            .mintToken({\n                amount: BigInt(amount),\n                name: title + \" APT\",    // A pro for use IDT (identity token) and TFT (temporal funding token) with the same token is that the TFT token that the user holds has the same id than the project.  This allows the user to verify the exact project in case than two projects has the same name.\n                decimals: decimals,\n                description: \"Temporal-funding Token for the \" + title + \" project.\"\n            })\n    ]\n\n    // Building the unsigned transaction\n    const unsignedTransaction = await new TransactionBuilder(await getCurrentHeight())\n        .from(inputs)                          // Inputs coming from the user's UTXOs\n        .to(outputs)                           // Outputs (the new project box)\n        .sendChangeTo(walletPk)                // Send change back to the wallet\n        .payFee(RECOMMENDED_MIN_FEE_VALUE)     // Pay the recommended minimum fee\n        .build()                               // Build the transaction\n        .toEIP12Object();                      // Convert the transaction to an EIP-12 compatible object\n\n    yield \"Please sign the mint transaction...\";\n\n    // Sign the transaction\n    const signedTransaction = await signTransaction(unsignedTransaction);\n\n    // Send the transaction to the Ergo network\n    const transactionId = await submitTransaction(signedTransaction);\n\n    console.log(\"Mint tx id: \" + transactionId);\n\n    yield \"Waiting for mint confirmation... (this may take a few minutes)\";\n\n    let box = await wait_until_confirmation(transactionId);\n    if (box == null) {\n        alert(\"Mint tx failed.\")\n        throw new Error(\"Mint tx failed.\")\n    }\n\n    return box\n}\n\n// Function to submit a project to the blockchain\nexport async function* submit_project(\n    version: contract_version,\n    token_id: string,\n    token_amount: number,\n    blockLimit: number,     // Block height until withdrawal/refund is allowed\n    is_timestamp_limit: boolean, // Whether the limit is based on timestamp or block height\n    exchangeRate: number,   // Exchange rate base_token/PFT\n    projectContent: string,    // Project content (JSON with title, description, image, link)\n    minimumSold: number,     // Minimum amount sold to allow withdrawal\n    title: string,\n    base_token_id: string = \"\",  // Base token ID for contributions (empty for ERG)\n    owner_ergotree: string = \"\"  // Optional: Owner ErgoTree (if different from wallet)\n): AsyncGenerator<string, string | null, void> {\n\n    // Parse and validate project content\n    let parsedContent: ProjectContent;\n    try {\n        parsedContent = JSON.parse(projectContent);\n    } catch (error) {\n        alert(\"Invalid project content format.\");\n        return null;\n    }\n\n    // Validate that the project content (title, description, image, link) fits within limits\n    const validation = validateProjectContent(parsedContent);\n    if (!validation.isValid) {\n        alert(validation.message);\n        return null;\n    }\n\n    // Get the wallet address (will be the project address)\n    const walletPk = await getChangeAddress();\n\n    let addressContent: ConstantContent = {\n        \"owner\": owner_ergotree ? owner_ergotree : ErgoAddress.fromBase58(walletPk).ergoTree,\n        \"dev_addr\": get_dev_contract_address(),\n        \"dev_hash\": get_dev_contract_hash(),\n        \"dev_fee\": get_dev_fee(),\n        \"pft_token_id\": token_id,\n        \"base_token_id\": base_token_id\n    };\n\n    // Get token emission amount.\n    let token_data = await get_token_data(token_id);\n    let id_token_amount = token_data[\"amount\"] + 1;\n\n    // Build the mint tx.\n    yield \"Preparing token mint transaction (1/2)...\";\n    const mintGen = mint_tx(title, addressContent, version, id_token_amount, token_data[\"decimals\"]);\n    let mintResult = await mintGen.next();\n    while (!mintResult.done) {\n        yield mintResult.value;\n        mintResult = await mintGen.next();\n    }\n    let mint_box = mintResult.value;\n\n    // Inform the UI that the mint was confirmed and we're preparing the second transaction\n    yield \"Mint confirmed. Preparing project creation transaction (2/2). You will be prompted to sign the next transaction.\";\n\n    let project_id = mint_box.assets[0].tokenId;\n\n    if (project_id === null) { alert(\"Token minting failed!\"); return null; }\n\n    // Get the UTXOs from the current wallet to use as inputs\n    const inputs = [mint_box, ...await window.ergo!.get_utxos()];\n\n    const r4Hex = SPair(SBool(is_timestamp_limit), SLong(BigInt(blockLimit))).toHex();\n    const r5Hex = SLong(BigInt(minimumSold)).toHex();\n    const r6Hex = SColl(SLong, [BigInt(0), BigInt(0), BigInt(0)]).toHex();\n    const r7Hex = SLong(BigInt(exchangeRate)).toHex();\n    const r8Hex = createR8Structure(addressContent).toHex();\n    const r9Hex = SString(projectContent);\n\n    // Calculate register sizes using utility functions\n    const registerSizes = estimateRegisterSizes(r4Hex, r5Hex, r6Hex, r7Hex, r8Hex, r9Hex);\n\n    const ergoTreeAddress = get_ergotree_hex(addressContent, version);\n\n    // Estimate total box size\n    const totalEstimatedSize = estimateTotalBoxSize(\n        ergoTreeAddress.length,\n        3, // number of tokens (project_id, pft_token_id, and possibly base_token_id)\n        registerSizes\n    );\n\n\n    let minRequiredValue = BOX_VALUE_PER_BYTE * BigInt(totalEstimatedSize);\n    if (minRequiredValue < SAFE_MIN_BOX_VALUE) {\n        minRequiredValue = SAFE_MIN_BOX_VALUE;\n    }\n\n    // Building the project output\n    let outputs: OutputBuilder[] = [new OutputBuilder(\n        minRequiredValue,                       // Minimum value in ERG that a box can have\n        ergoTreeAddress        // Address of the project contract\n    )\n        .addTokens([\n            {\n                tokenId: project_id,\n                amount: BigInt(id_token_amount)     // The mint contract force to spend all the id_token_amount\n            },\n            {\n                tokenId: token_id ?? \"\",\n                amount: token_amount.toString()\n            }\n        ])\n        .setAdditionalRegisters({\n            R4: r4Hex,\n            R5: r5Hex,\n            R6: r6Hex,\n            R7: r7Hex,\n            R8: r8Hex,\n            R9: r9Hex\n        })];\n\n    // Building the unsigned transaction\n    const unsignedTransaction = await new TransactionBuilder(await getCurrentHeight())\n        .from(inputs)                          // Inputs coming from the user's UTXOs\n        .to(outputs)                           // Outputs (the new project box)\n        .sendChangeTo(walletPk)                // Send change back to the wallet\n        .payFee(RECOMMENDED_MIN_FEE_VALUE)     // Pay the recommended minimum fee\n        .build()                               // Build the transaction\n        .toEIP12Object();                      // Convert the transaction to an EIP-12 compatible object\n\n    try {\n        playBeep();\n    } catch (error) {\n        console.error('Error executing play beep:', error);\n    }\n\n    yield \"Please sign the project transaction (2/2)...\";\n\n    // Sign the transaction\n    const signedTransaction = await signTransaction(unsignedTransaction);\n\n    // Send the transaction to the Ergo network\n    const transactionId = await submitTransaction(signedTransaction);\n\n    console.log(\"Transaction id -> \", transactionId);\n\n    // Let the UI know the project transaction was submitted and provide the tx id\n    yield `Project transaction submitted. Transaction ID: ${transactionId}`;\n\n    return transactionId;\n}\n","path":null,"size_bytes":10210,"size_tokens":null},"src/lib/components/ui/resizable/index.ts":{"content":"import { Pane } from \"paneforge\";\nimport Handle from \"./resizable-handle.svelte\";\nimport PaneGroup from \"./resizable-pane-group.svelte\";\n\nexport {\n\tPaneGroup,\n\tPane,\n\tHandle,\n\t//\n\tPaneGroup as ResizablePaneGroup,\n\tPane as ResizablePane,\n\tHandle as ResizableHandle,\n};\n","path":null,"size_bytes":268,"size_tokens":null},"src/lib/ergo/forum/commentFetch.ts":{"content":"import { ErgoAddress, Network } from '@fleet-sdk/core';\nimport { SByte, SColl } from '@fleet-sdk/serializer';\nimport { type Comment } from './commentObject';\nimport { hexToBytes, hexToUtf8, serializedToRendered } from './utils';\nimport { COMMENT_TYPE_NFT_ID, DISCUSSION_TYPE_NFT_ID, PROFILE_TYPE_NFT_ID, SPAM_FLAG_NFT_ID, SPAM_LIMIT } from './envs';\nimport { explorer_uri } from '$lib/common/store';\nimport { get } from 'svelte/store';\nimport { ergo_tree_hash } from './contract';\nimport { type TypeNFT, type ReputationProof, type RPBox } from './object';\nimport { reputation_proof } from './store';\nimport { marked } from 'marked';\nimport DOMPurify from \"dompurify\";\n\n// Global ergo wallet connector (injected by browser wallet extension)\ndeclare const ergo: any;\n\n// Minimal definition of the Explorer API response for a box\ninterface ApiBox {\n  boxId: string;\n  value: string | number;\n  ergoTree: string;\n  assets: { tokenId: string; amount: string | number; }[];\n  creationHeight: number;\n  blockId: string;\n  additionalRegisters: {\n    [key: string]: {\n      serializedValue: string;\n      renderedValue?: string;\n    };\n  };\n  index: number;\n  transactionId: string;\n}\n\n// Constants\nconst LIMIT_PER_PAGE = 100;\n\n// Interface for search body\ninterface SearchBody {\n  registers: { [key: string]: string };\n}\n\n/**\n * Gets the timestamp of a block given its block ID.\n * @param blockId The ID of the block.\n * @returns The block timestamp (in milliseconds).\n */\nexport async function getTimestampFromBlockId(blockId: string): Promise<number> {\n  const url = `${get(explorer_uri)}/api/v1/blocks/${blockId}`;\n\n  try {\n    const response = await fetch(url, { method: \"GET\" });\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}`);\n    }\n\n    const json = await response.json();\n    console.log(\"get Timestamp \", json);\n\n    const timestamp = json?.block?.header?.timestamp;\n    if (typeof timestamp !== \"number\") {\n      console.warn(`No timestamp found for block ${blockId}`);\n      return 0;\n    }\n\n    // Most APIs return timestamps in ms or s.\n    // If it's around 1e12, it's already in ms; if around 1e9, convert to ms.\n    return timestamp < 1e11 ? timestamp * 1000 : timestamp;\n\n  } catch (error) {\n    console.error(`Error fetching timestamp for block ${blockId}:`, error);\n    return 0;\n  }\n}\n\n/**\n * Searches the blockchain for all spam alerts targeting a comment.\n */\nexport async function fetchSpan(comment_id: string): Promise<number> {\n  let amount: number = 0;\n\n  const search_body = {\n    registers: {\n      \"R4\": serializedToRendered(SColl(SByte, hexToBytes(SPAM_FLAG_NFT_ID) ?? \"\").toHex()),\n      \"R5\": serializedToRendered(SColl(SByte, hexToBytes(comment_id) ?? \"\").toHex())\n    }\n  }\n\n  try {\n    let offset = 0, limit = 100, moreDataAvailable = true;\n\n    while (moreDataAvailable) {\n      const url = `${get(explorer_uri)}/api/v1/boxes/unspent/search?offset=${offset}&limit=${limit}`;\n\n      const final_body = {\n        \"ergoTreeTemplateHash\": ergo_tree_hash,\n        \"registers\": search_body.registers,\n        \"assets\": []\n      };\n\n      const response = await fetch(url, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(final_body)\n      });\n\n      if (!response.ok) {\n        console.error(`Error fetching spam reports: ${response.statusText}`);\n        moreDataAvailable = false;\n        continue;\n      }\n\n      const json_data = await response.json();\n      if (!json_data.items || json_data.items.length === 0) {\n        moreDataAvailable = false;\n        continue;\n      }\n\n      for (const box of json_data.items as ApiBox[]) {\n        if (!box.assets?.length) continue;\n        if (box.additionalRegisters.R6.renderedValue == \"false\" || !box.additionalRegisters.R9.renderedValue) continue;\n\n        try {\n          const rawValue = box.additionalRegisters.R9.renderedValue;\n          if (rawValue) hexToUtf8(rawValue);\n        } catch (e) {\n          console.warn(`Error decoding R9 for box ${box.boxId}`, e);\n        }\n\n        amount += 1;\n      }\n      offset += limit;\n    }\n\n    return amount;\n\n  } catch (error) {\n    console.error('Error while searching spam flags:', error);\n    return 0;\n  }\n}\n\n/**\n * Searches the blockchain for all top-level comments (threads)\n * for a given discussion (project).\n */\nexport async function fetchComments(discussion: string, reply: boolean = false): Promise<Comment[]> {\n  console.log(\"fetchComments\", { discussion }, reply)\n  let comments: Comment[] = [];\n\n  const search_body = {\n    registers: {\n      \"R4\": serializedToRendered(SColl(SByte, hexToBytes(reply ? COMMENT_TYPE_NFT_ID : DISCUSSION_TYPE_NFT_ID) ?? \"\").toHex()),\n      \"R5\": serializedToRendered(SColl(SByte, hexToBytes(discussion) ?? \"\").toHex())\n    }\n  }\n\n  try {\n    let offset = 0, limit = 100, moreDataAvailable = true;\n\n    while (moreDataAvailable) {\n      const url = `${get(explorer_uri)}/api/v1/boxes/unspent/search?offset=${offset}&limit=${limit}`;\n\n      const final_body = {\n        \"ergoTreeTemplateHash\": ergo_tree_hash,\n        \"registers\": search_body.registers,\n        \"assets\": []\n      };\n\n      const response = await fetch(url, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(final_body)\n      });\n\n      if (!response.ok) {\n        console.error(`Error fetching comments: ${response.statusText}`);\n        moreDataAvailable = false;\n        continue;\n      }\n\n      const json_data = await response.json();\n      if (!json_data.items || json_data.items.length === 0) {\n        moreDataAvailable = false;\n        continue;\n      }\n\n      console.log(\"Comments json data \", json_data.items)\n\n      for (const box of json_data.items as ApiBox[]) {\n        if (!box.assets?.length) continue;\n        if (box.additionalRegisters.R6.renderedValue == \"false\" || !box.additionalRegisters.R9.renderedValue) continue;\n\n        const authorProfileTokenId = box.assets[0].tokenId;\n\n        let textContent: string = \"[Unreadable content]\";\n        try {\n          const rawValue = box.additionalRegisters.R9.renderedValue;\n          if (rawValue) {\n            textContent = hexToUtf8(rawValue) ?? \"[Empty content]\";\n          }\n        } catch (e) {\n          console.warn(`Error decoding R9 for box ${box.boxId}`, e);\n        }\n\n        const number_of_spans = await fetchSpan(box.boxId);\n        const isSpam = number_of_spans > SPAM_LIMIT;\n\n        textContent = await marked(textContent);\n        textContent = DOMPurify.sanitize(textContent);\n\n        const comment: Comment = {\n          id: box.boxId,\n          discussion: discussion,\n          authorProfileTokenId: authorProfileTokenId,\n          text: textContent,\n          timestamp: await getTimestampFromBlockId(box.blockId),\n          isSpam: isSpam,\n          replies: await fetchComments(box.boxId, true),\n          tx: box.transactionId,\n          posting: false,\n          sentiment: box.additionalRegisters.R8?.renderedValue === 'true'\n        };\n\n        comments.push(comment);\n      }\n      offset += limit;\n    }\n\n    comments.sort((a, b) => b.timestamp - a.timestamp);\n\n    return comments;\n\n  } catch (error) {\n    console.error('Error while fetching comments:', error);\n    return [];\n  }\n}\n\n// Helper to get serialized R7\nasync function getSerializedR7(ergo: any): Promise<{ changeAddress: string; r7SerializedHex: string } | null> {\n  if (!ergo) {\n    console.error(\"getSerializedR7: 'ergo' object is not available.\");\n    return null;\n  }\n\n  try {\n    const changeAddress = await ergo.get_change_address();\n    if (!changeAddress) {\n      console.warn(\"getSerializedR7: Could not obtain change address.\");\n      return null;\n    }\n\n    const userAddress = ErgoAddress.fromBase58(changeAddress);\n    const propositionBytes = hexToBytes(userAddress.ergoTree);\n\n    console.log(\"Ergotree \", userAddress.ergoTree);\n\n    if (!propositionBytes) {\n      console.error(\"getSerializedR7: Could not obtain propositionBytes.\");\n      return null;\n    }\n\n    const r7SerializedHex = SColl(SByte, userAddress.ergoTree).toHex();\n    return { changeAddress, r7SerializedHex };\n  } catch (e) {\n    console.error(\"getSerializedR7: Error obtaining user address\", e);\n    return null;\n  }\n}\n\n// Fetch all user boxes with pagination\nasync function fetchProfileUserBoxes(r7SerializedHex: string): Promise<ApiBox[]> {\n  const allBoxes: ApiBox[] = [];\n  let offset = 0;\n  let moreDataAvailable = true;\n\n  const searchBody: SearchBody = {\n    registers: {\n      R7: serializedToRendered(r7SerializedHex),\n      R4: PROFILE_TYPE_NFT_ID\n    }\n  };\n\n  while (moreDataAvailable) {\n    const url = `${get(explorer_uri)}/api/v1/boxes/unspent/search?offset=${offset}&limit=${LIMIT_PER_PAGE}`;\n    const finalBody = {\n      ergoTreeTemplateHash: ergo_tree_hash,\n      registers: searchBody.registers,\n      assets: [],\n    };\n\n    try {\n      const response = await fetch(url, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(finalBody),\n      });\n\n      if (!response.ok) {\n        console.error(`fetchAllUserBoxes: Error fetching boxes: ${response.statusText}`);\n        moreDataAvailable = false;\n        continue;\n      }\n\n      const jsonData = await response.json();\n      if (!jsonData.items || jsonData.items.length === 0) {\n        moreDataAvailable = false;\n        continue;\n      }\n\n      const filteredBoxes = jsonData.items\n        .filter((box: ApiBox) =>\n          box.additionalRegisters.R5.renderedValue === box.assets[0].tokenId &&\n          box.additionalRegisters.R6.renderedValue === 'false'\n        )\n        .sort((a: ApiBox, b: ApiBox) => b.creationHeight - a.creationHeight);\n\n      allBoxes.push(...filteredBoxes as ApiBox[]);\n      offset += LIMIT_PER_PAGE;\n    } catch (e) {\n      console.error(\"fetchAllUserBoxes: Error during fetch\", e);\n      moreDataAvailable = false;\n    }\n  }\n\n  console.log(allBoxes.map(box => box.additionalRegisters.R5.renderedValue))\n  console.log(allBoxes.map(box => box.boxId))\n\n  return allBoxes;\n}\n\n// Fetch token emission amount\nasync function fetchTokenEmissionAmount(tokenId: string): Promise<number | null> {\n  try {\n    const response = await fetch(`${get(explorer_uri)}/api/v1/tokens/${tokenId}`);\n    if (!response.ok) {\n      console.error(`fetchTokenEmissionAmount: Error fetching token ${tokenId}: ${response.statusText}`);\n      return null;\n    }\n    const tokenData = await response.json();\n    return Number(tokenData.emissionAmount || 0);\n  } catch (e) {\n    console.error(`fetchTokenEmissionAmount: Error fetching token ${tokenId}`, e);\n    return null;\n  }\n}\n\n// Convert ApiBox to RPBox\nfunction convertToRPBox(box: ApiBox, profileTokenId: string): RPBox | null {\n  if (!box.assets?.length || box.assets[0].tokenId !== profileTokenId) {\n    console.warn(`convertToRPBox: Box ${box.boxId} has different token ID. Skipping.`);\n    return null;\n  }\n\n  if (!box.additionalRegisters.R4 || !box.additionalRegisters.R5 || !box.additionalRegisters.R6) {\n    console.warn(`convertToRPBox: Box ${box.boxId} lacks R4, R5, or R6. Skipping.`);\n    return null;\n  }\n\n  const typeNftId = box.additionalRegisters.R4.renderedValue ?? '';\n  const typeNft: TypeNFT = {\n    tokenId: typeNftId,\n    boxId: '',\n    typeName: typeNftId === PROFILE_TYPE_NFT_ID ? 'Profile' : 'Unknown Type',\n    description: '...',\n    schemaURI: '',\n    isRepProof: false,\n  };\n\n  let boxContent: string | object | null = null;\n  try {\n    const rawValue = box.additionalRegisters.R9?.renderedValue;\n    if (rawValue) {\n      const potentialString = hexToUtf8(rawValue);\n      if (potentialString) {\n        try {\n          boxContent = JSON.parse(potentialString);\n        } catch {\n          boxContent = potentialString;\n        }\n      }\n    }\n  } catch (e) {\n    console.error(`convertToRPBox: Error parsing R9 for box ${box.boxId}`, e);\n  }\n\n  const objectPointer = hexToUtf8(box.additionalRegisters.R5?.renderedValue ?? '') ?? '';\n\n  return {\n    box: {\n      boxId: box.boxId,\n      value: typeof box.value === 'string' ? box.value : box.value.toString(),\n      assets: box.assets.map(a => ({ tokenId: a.tokenId, amount: typeof a.amount === 'string' ? a.amount : a.amount.toString() })),\n      ergoTree: box.ergoTree,\n      creationHeight: box.creationHeight,\n      additionalRegisters: Object.entries(box.additionalRegisters).reduce(\n        (acc, [key, value]) => ({ ...acc, [key]: value.serializedValue }),\n        {} as { [key: string]: string }\n      ),\n      index: box.index,\n      transactionId: box.transactionId,\n    },\n    box_id: box.boxId,\n    type: typeNft,\n    token_id: profileTokenId,\n    token_amount: Number(box.assets[0].amount),\n    object_pointer: objectPointer,\n    is_locked: box.additionalRegisters.R6.renderedValue === 'true',\n    polarization: box.additionalRegisters.R8?.renderedValue === 'true',\n    content: boxContent,\n  };\n}\n\n/**\n * Fetches the full ReputationProof object for the connected user,\n * by searching all boxes where R7 matches their wallet address.\n * @param ergo The connected wallet object (e.g., dApp Connector)\n */\nexport async function fetchProfile(ergo: any): Promise<ReputationProof | null> {\n  try {\n    const r7Data = await getSerializedR7(ergo);\n    if (!r7Data) {\n      reputation_proof.set(null);\n      return null;\n    }\n    const { changeAddress, r7SerializedHex } = r7Data;\n    console.log(`Fetching profile for R7: ${r7SerializedHex}`);\n\n    const allUserBoxes = await fetchProfileUserBoxes(r7SerializedHex);\n    if (allUserBoxes.length === 0) {\n      console.log('No profile boxes found for this user.');\n      reputation_proof.set(null);\n      return null;\n    }\n\n    const first_box = allUserBoxes[0];\n\n    const profileTokenId = first_box.assets[0].tokenId;\n    const emissionAmount = await fetchTokenEmissionAmount(profileTokenId);\n    if (emissionAmount === null) {\n      reputation_proof.set(null);\n      console.warn(\"fetchTokenEmissionAmount returned null.\")\n      return null;\n    }\n\n    const proof: ReputationProof = {\n      token_id: profileTokenId,\n      type: { tokenId: '', boxId: '', typeName: 'N/A', description: '...', schemaURI: '', isRepProof: false },\n      data: {},\n      total_amount: emissionAmount,\n      owner_address: changeAddress,\n      owner_serialized: r7SerializedHex,\n      can_be_spend: true,\n      current_boxes: [],\n      number_of_boxes: 0,\n      network: 'ergo' as any,\n    };\n\n    const rpbox = convertToRPBox(first_box, profileTokenId);\n    if (!rpbox) {\n      reputation_proof.set(null);\n      console.warn(\"convertToRPBox returned null.\")\n      return null;\n    }\n\n    proof.current_boxes.push(rpbox);\n    proof.number_of_boxes += 1;\n\n    console.log(`Profile found: ${proof.token_id}, ${proof.number_of_boxes} boxes.`, proof);\n    reputation_proof.set(proof);\n\n    console.log(proof)\n    return proof;\n\n  } catch (error) {\n    console.error('Error fetching profile:', error);\n    reputation_proof.set(null);\n    return null;\n  }\n}\n","path":null,"size_bytes":15000,"size_tokens":null},"postcss.config.js":{"content":"export default {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {}\n  }\n};\n","path":null,"size_bytes":79,"size_tokens":null},"src/lib/common/store.ts":{"content":"import { writable } from 'svelte/store';\nimport type { Project } from './project';\nimport { DEFAULT_WEB_EXPLORER_URI_TX, DEFAULT_WEB_EXPLORER_URI_TKN, DEFAULT_WEB_EXPLORER_URI_ADDR } from \"$lib/ergo/envs\";\n\nexport const address = writable<string | null>(null);\nexport const network = writable<string | null>(null);\nexport const connected = writable<boolean>(false);\nexport const wallet_address = writable<string>(\"\");\nexport const balance = writable<number | null>(null);\nexport const temporal_token_amount = writable<number | null>(null);\nexport const project_token_amount = writable<string | null>(null);\nexport const project_detail = writable<Project | null>(null);\nexport const timer = writable<{ countdownInterval: number, target: number }>({ countdownInterval: 0, target: 0 })\nexport const projects = writable<{ data: Map<string, Project>, last_fetch: number }>({\n    data: new Map(),\n    last_fetch: 0\n})\nexport const user_tokens = writable<Map<string, number>>(new Map());\nexport const explorer_uri = writable<string | null>(\"https://api.ergoplatform.com\");\nexport const web_explorer_uri_tx = writable<string>(DEFAULT_WEB_EXPLORER_URI_TX);\nexport const web_explorer_uri_tkn = writable<string>(DEFAULT_WEB_EXPLORER_URI_TKN);\nexport const web_explorer_uri_addr = writable<string>(DEFAULT_WEB_EXPLORER_URI_ADDR);","path":null,"size_bytes":1317,"size_tokens":null},"src/lib/common/project.ts":{"content":"import { type contract_version } from \"$lib/ergo/contract\";\nimport { type Platform } from \"./platform\";\nimport { ErgoAddress, SByte, SColl, type Amount, type Box } from \"@fleet-sdk/core\";\n\nexport interface TokenEIP4 {\n    name: string,\n    description: string,\n    decimals: number,\n    emissionAmount: number | null\n}\n\nexport interface ProjectContent {\n    raw: string,\n    title: string,\n    description: string,\n    link: string | null,\n    image: string | null\n}\n\nexport interface ConstantContent {\n    raw?: string,\n    owner: string,\n    dev_addr?: string,\n    dev_hash: string,\n    dev_fee: number,\n    pft_token_id: string,\n    base_token_id?: string  // Base token ID for multi-token support (empty for ERG)\n}\n\nexport function createR8Structure(content: ConstantContent) {\n\n    function numberToHex(num: number): string {\n        let hex = BigInt(num).toString(16);\n        if (hex.length % 2 !== 0) hex = \"0\" + hex;\n        return hex;\n    }\n\n    function getErgoTree(input: string): string {\n        try {\n            return ErgoAddress.fromBase58(input).ergoTree;\n        } catch (e) {\n            return input;\n        }\n    }\n\n    const ownerErgoTree = getErgoTree(content.owner);\n    const baseTokenId = content.base_token_id || \"\";\n\n    const r8Data = SColl(SColl(SByte), [\n        ownerErgoTree,                  // Index 0\n        content.dev_hash,               // Index 1\n        numberToHex(content.dev_fee),   // Index 2\n        content.pft_token_id,           // Index 3\n        baseTokenId                     // Index 4\n    ]);\n\n    return r8Data;\n}\n\nexport interface Project {\n    version: contract_version,\n    platform: Platform,\n    box: Box<Amount>,\n    project_id: string,\n    current_idt_amount: number,\n    pft_token_id: string,\n    base_token_id: string,  // Base token ID for contributions (empty string for ERG)\n    base_token_details?: TokenEIP4,  // Details of the base token (null for ERG)\n    block_limit: number,\n    is_timestamp_limit: boolean,\n    minimum_amount: number,\n    maximum_amount: number,\n    value: number,  // Real exact value\n    current_value: number,  // Current value - contract reserves (ex: min box value on ergo)\n    total_pft_amount: number,\n    current_pft_amount: number,\n    unsold_pft_amount: number,\n    sold_counter: number,\n    refund_counter: number,\n    auxiliar_exchange_counter: number,\n    exchange_rate: number,  // Base token per PFT exchange rate\n    token_details: TokenEIP4,\n    content: ProjectContent,\n    constants: ConstantContent\n}\n\nexport async function is_ended(project: Project): Promise<boolean> {\n    if (project.is_timestamp_limit) {\n        // In timestamp mode, compare with current time\n        const currentTime = new Date().getTime();\n        return project.block_limit < currentTime;\n    } else {\n        // In block height mode, compare with current block height\n        let height = await project.platform.get_current_height();\n        return project.block_limit < height;\n    }\n}\n\nexport async function min_raised(project: Project): Promise<boolean> {\n    return (project.sold_counter - project.refund_counter) >= project.minimum_amount\n}\n\nexport async function max_raised(project: Project): Promise<boolean> {\n    return project.sold_counter == project.maximum_amount\n}\n\nexport function getProjectContent(id: string, value: string): ProjectContent {\n    try {\n        const parsed = JSON.parse(value);\n        return {\n            raw: value,\n            title: parsed.title || 'Id ' + id,\n            description: parsed.description || \"No description provided.\",\n            link: parsed.link || null,\n            image: parsed.image || \"https://camarasal.com/wp-content/uploads/2020/08/default-image-5-1.jpg\"\n        };\n    } catch (error) {\n        return {\n\n            raw: value,\n            title: 'Id ' + id,\n            description: \"No description provided.\",\n            link: null,\n            image: \"https://camarasal.com/wp-content/uploads/2020/08/default-image-5-1.jpg\"\n        };\n    }\n}\n\nexport function getConstantContent(value: string): ConstantContent | null {\n    try {\n        const parsed = JSON.parse(value);\n        return {\n            raw: value,\n            owner: parsed.owner,\n            dev_addr: parsed.dev_addr,\n            dev_hash: parsed.dev_hash,\n            dev_fee: parsed.dev_fee,\n            pft_token_id: parsed.pft_token_id || parsed.token_id || null,\n            base_token_id: parsed.base_token_id || \"\"  // Default to empty string for ERG\n        }\n    } catch (error) {\n        return null;\n    }\n}","path":null,"size_bytes":4550,"size_tokens":null},"src/lib/utils.ts":{"content":"import { type ClassValue, clsx } from \"clsx\";\nimport { twMerge } from \"tailwind-merge\";\nimport { cubicOut } from \"svelte/easing\";\nimport type { TransitionConfig } from \"svelte/transition\";\n\nexport function cn(...inputs: ClassValue[]) {\n\treturn twMerge(clsx(inputs));\n}\n\ntype FlyAndScaleParams = {\n\ty?: number;\n\tx?: number;\n\tstart?: number;\n\tduration?: number;\n};\n\nexport const flyAndScale = (\n\tnode: Element,\n\tparams: FlyAndScaleParams = { y: -8, x: 0, start: 0.95, duration: 150 }\n): TransitionConfig => {\n\tconst style = getComputedStyle(node);\n\tconst transform = style.transform === \"none\" ? \"\" : style.transform;\n\n\tconst scaleConversion = (\n\t\tvalueA: number,\n\t\tscaleA: [number, number],\n\t\tscaleB: [number, number]\n\t) => {\n\t\tconst [minA, maxA] = scaleA;\n\t\tconst [minB, maxB] = scaleB;\n\n\t\tconst percentage = (valueA - minA) / (maxA - minA);\n\t\tconst valueB = percentage * (maxB - minB) + minB;\n\n\t\treturn valueB;\n\t};\n\n\tconst styleToString = (\n\t\tstyle: Record<string, number | string | undefined>\n\t): string => {\n\t\treturn Object.keys(style).reduce((str, key) => {\n\t\t\tif (style[key] === undefined) return str;\n\t\t\treturn str + `${key}:${style[key]};`;\n\t\t}, \"\");\n\t};\n\n\treturn {\n\t\tduration: params.duration ?? 200,\n\t\tdelay: 0,\n\t\tcss: (t) => {\n\t\t\tconst y = scaleConversion(t, [0, 1], [params.y ?? 5, 0]);\n\t\t\tconst x = scaleConversion(t, [0, 1], [params.x ?? 0, 0]);\n\t\t\tconst scale = scaleConversion(t, [0, 1], [params.start ?? 0.95, 1]);\n\n\t\t\treturn styleToString({\n\t\t\t\ttransform: `${transform} translate3d(${x}px, ${y}px, 0) scale(${scale})`,\n\t\t\t\topacity: t\n\t\t\t});\n\t\t},\n\t\teasing: cubicOut\n\t};\n};","path":null,"size_bytes":1588,"size_tokens":null},"tests/contracts/counters.test.ts":{"content":"// ===== TEST FILE: Counters =====\n// This suite attempts to exploit the accounting logic of the contract\n// by creating invalid states between Physical Tokens and Register Counters.\n// Tries to create a malicious scenario for temporaryFundingTokenAmountOnContract function.\n\nimport { describe, it, expect, beforeEach } from \"vitest\";\nimport { Box, OutputBuilder, TransactionBuilder, RECOMMENDED_MIN_FEE_VALUE } from \"@fleet-sdk/core\";\nimport { SByte, SColl, SInt, SLong } from \"@fleet-sdk/serializer\";\nimport { stringToBytes } from \"@scure/base\";\nimport { setupBeneTestContext, ERG_BASE_TOKEN, ERG_BASE_TOKEN_NAME, type BeneTestContext, USD_BASE_TOKEN, USD_BASE_TOKEN_NAME, createR4 } from \"./bene_contract_helpers\";\n\nconst baseModes = [\n  { name: \"USD Token Mode\", token: USD_BASE_TOKEN, tokenName: USD_BASE_TOKEN_NAME },\n  { name: \"ERG Mode\", token: ERG_BASE_TOKEN, tokenName: ERG_BASE_TOKEN_NAME },\n];\n\ndescribe.each(baseModes)(\"Bene Contract v1.2 - Counter Hacker Scenarios (%s)\", (mode) => {\n  let ctx: BeneTestContext;\n  let projectBox: Box;\n\n  // Helper to inject legitimate funds to the buyer (so they can attempt the attack)\n  const giveTokensToBuyer = (tokens: { tokenId: string, amount: bigint }[]) => {\n    ctx.buyer.addUTxOs({\n      value: 10_000_000_000n, // 10 ERG for fees and change\n      ergoTree: ctx.buyer.address.ergoTree,\n      assets: tokens,\n      creationHeight: ctx.mockChain.height,\n      additionalRegisters: {},\n    });\n  };\n\n  beforeEach(() => {\n    ctx = setupBeneTestContext(mode.token, mode.tokenName);\n\n    // Setup: Initial Project Box (Standard state: 100k PFTs, 0 Sold)\n    const initialAssets = [\n      { tokenId: ctx.projectNftId, amount: 1n + ctx.totalPFTokens }, // APT\n      { tokenId: ctx.pftTokenId, amount: ctx.totalPFTokens },        // PFT\n    ];\n\n    ctx.beneContract.addUTxOs({\n      value: RECOMMENDED_MIN_FEE_VALUE,\n      ergoTree: ctx.beneErgoTree.toHex(),\n      assets: initialAssets,\n      creationHeight: ctx.mockChain.height,\n      additionalRegisters: {\n        R4: createR4(ctx),\n        R5: SLong(ctx.minimumTokensSold).toHex(),\n        R6: SColl(SLong, [0n, 0n, 0n]).toHex(),\n        R7: SLong(ctx.exchangeRate).toHex(),\n        R8: ctx.constants.toHex(),\n        R9: SColl(SByte, stringToBytes(\"utf8\", \"{}\")).toHex(),\n      },\n    });\n\n    projectBox = ctx.beneContract.utxos.toArray()[0];\n  });\n\n  /**\n   * HACK 1: The Trojan Injection\n   * Attacker buys tokens but tries to inject their own PFTs into the contract\n   * to inflate the \"physical\" inventory.\n   */\n  it(\"should REJECT a 'Trojan Injection' (Adding PFTs during a Buy action)\", () => {\n    const tokensToBuy = 100n;\n    const paymentAmount = tokensToBuy * ctx.exchangeRate;\n    const newAPTAmount = BigInt(projectBox.assets[0].amount) - tokensToBuy;\n\n    const injectedPFT = 500n;\n    // The contract should have (TotalPFT), the attacker tries to make it have (TotalPFT + 500)\n    const maliciousPFTAmount = ctx.totalPFTokens + injectedPFT;\n\n    // PREPARATION: Give the attacker the PFTs necessary for the injection\n    // (Fleet needs to see them in the inputs to build the tx)\n    giveTokensToBuyer([{ tokenId: ctx.pftTokenId, amount: injectedPFT }]);\n\n    let value = BigInt(projectBox.value);\n    let assets = [\n      { tokenId: ctx.projectNftId, amount: newAPTAmount },\n      { tokenId: ctx.pftTokenId, amount: maliciousPFTAmount } // maliciously increased\n    ];\n\n    if (!ctx.isErgMode) {\n      assets.push({ tokenId: ctx.baseTokenId, amount: paymentAmount });\n    } else {\n      value += paymentAmount;\n    }\n\n    const contractOutputBuilder = new OutputBuilder(value, ctx.beneErgoTree)\n      .addTokens(assets)\n      .setAdditionalRegisters({\n        ...projectBox.additionalRegisters,\n        R6: SColl(SLong, [tokensToBuy, 0n, 0n]).toHex(),\n      });\n\n    const transaction = new TransactionBuilder(ctx.mockChain.height)\n      .from([...ctx.beneContract.utxos.toArray(), ...ctx.buyer.utxos.toArray()])\n      .to([\n        contractOutputBuilder,\n        new OutputBuilder(RECOMMENDED_MIN_FEE_VALUE, ctx.buyer.address).addTokens([\n          { tokenId: ctx.projectNftId, amount: tokensToBuy },\n        ]),\n      ])\n      .sendChangeTo(ctx.buyer.address)\n      .payFee(RECOMMENDED_MIN_FEE_VALUE)\n      .build();\n\n    const result = ctx.mockChain.execute(transaction, { signers: [ctx.buyer], throw: false });\n    expect(result).toBe(false); // Fails due to ProofFundingTokenRemainsConstant\n  });\n\n  /**\n   * HACK 2: The Ghost Sale\n   * Attacker buys, removes APTs, but DOES NOT increment the Sold counter (R6[0]).\n   */\n  it(\"should REJECT a 'Ghost Sale' (Buying without incrementing Sold counter)\", () => {\n    const tokensToBuy = 100n;\n    const paymentAmount = tokensToBuy * ctx.exchangeRate;\n    const newAPTAmount = BigInt(projectBox.assets[0].amount) - tokensToBuy;\n\n    let value = BigInt(projectBox.value);\n    let assets = [\n      { tokenId: ctx.projectNftId, amount: newAPTAmount },\n      { tokenId: ctx.pftTokenId, amount: ctx.totalPFTokens }\n    ];\n\n    if (!ctx.isErgMode) {\n      assets.push({ tokenId: ctx.baseTokenId, amount: paymentAmount });\n    } else {\n      value += paymentAmount;\n    }\n\n    const contractOutputBuilder = new OutputBuilder(value, ctx.beneErgoTree)\n      .addTokens(assets)\n      .setAdditionalRegisters({\n        ...projectBox.additionalRegisters,\n        R6: SColl(SLong, [0n, 0n, 0n]).toHex(), // ATTACK: Sold counter remains 0\n      });\n\n    const transaction = new TransactionBuilder(ctx.mockChain.height)\n      .from([...ctx.beneContract.utxos.toArray(), ...ctx.buyer.utxos.toArray()])\n      .to([\n        contractOutputBuilder,\n        new OutputBuilder(RECOMMENDED_MIN_FEE_VALUE, ctx.buyer.address).addTokens([\n          { tokenId: ctx.projectNftId, amount: tokensToBuy },\n        ]),\n      ])\n      .sendChangeTo(ctx.buyer.address)\n      .payFee(RECOMMENDED_MIN_FEE_VALUE)\n      .build();\n\n    const result = ctx.mockChain.execute(transaction, { signers: [ctx.buyer], throw: false });\n    expect(result).toBe(false); // Fails due to incrementSoldCounterCorrectly\n  });\n\n  /**\n   * HACK 3: The Desync Exchange\n   * Attacker exchanges APT->PFT but exaggerates the 'Exchanged' counter\n   * to desynchronize the formula (PFT - Sold + Exchanged).\n   */\n  it(\"should REJECT a 'Desync Exchange' (Incrementing counter more than tokens)\", () => {\n    const aptAmountToExchange = 50n;\n\n    // PREPARATION: Give the attacker the APTs needed to exchange\n    giveTokensToBuyer([{ tokenId: ctx.projectNftId, amount: aptAmountToExchange }]);\n\n    // For this test, we assume the contract box is ready for exchange (simplified)\n    // Actually, isExchangeFundingTokens requires (MinimumReached). We simulate this by manipulating R5/R6 in the output if necessary,\n    // or simply assume that the current contract allows exchange if the conditions were met.\n    // NOTE: For exchange to be valid, 'MinimumReached' must be true.\n    // We modify the Setup for this specific test by recreating the box with MinimumReached\n    ctx.beneContract.utxos.clear();\n    ctx.beneContract.addUTxOs({\n      value: RECOMMENDED_MIN_FEE_VALUE,\n      ergoTree: ctx.beneErgoTree.toHex(),\n      assets: [\n        { tokenId: ctx.projectNftId, amount: 1n + ctx.totalPFTokens - 50000n }, // Simulate 50k already sold\n        { tokenId: ctx.pftTokenId, amount: ctx.totalPFTokens },\n      ],\n      creationHeight: ctx.mockChain.height,\n      additionalRegisters: {\n        R4: createR4(ctx),\n        R5: SLong(50000n).toHex(),           // Min Sold 50k\n        R6: SColl(SLong, [50000n, 0n, 0n]).toHex(), // Sold 50k (Minimum Reached)\n        R7: SLong(ctx.exchangeRate).toHex(),\n        R8: ctx.constants.toHex(),\n        R9: SColl(SByte, stringToBytes(\"utf8\", \"{}\")).toHex(),\n      },\n    });\n    projectBox = ctx.beneContract.utxos.toArray()[0];\n\n    const inputAPT = BigInt(projectBox.assets[0].amount);\n    const inputPFT = BigInt(projectBox.assets[1].amount);\n\n    const newAPTAmount = inputAPT + aptAmountToExchange;\n    const newPFTAmount = inputPFT - aptAmountToExchange;\n\n    const contractOutputBuilder = new OutputBuilder(BigInt(projectBox.value), ctx.beneErgoTree)\n      .addTokens([\n        { tokenId: ctx.projectNftId, amount: newAPTAmount },\n        { tokenId: ctx.pftTokenId, amount: newPFTAmount },\n        ...(ctx.isErgMode ? [] : [{ tokenId: ctx.baseTokenId, amount: 0n }])\n      ])\n      .setAdditionalRegisters({\n        ...projectBox.additionalRegisters,\n        // ATTACK: Counter increments by 100, but we only moved 50 tokens\n        R6: SColl(SLong, [50000n, 0n, 100n]).toHex(), // Exchanged goes 0 -> 100\n      });\n\n    const transaction = new TransactionBuilder(ctx.mockChain.height)\n      .from([...ctx.beneContract.utxos.toArray(), ...ctx.buyer.utxos.toArray()])\n      .to([\n        contractOutputBuilder,\n        new OutputBuilder(RECOMMENDED_MIN_FEE_VALUE, ctx.buyer.address).addTokens([\n          { tokenId: ctx.pftTokenId, amount: aptAmountToExchange }\n        ])\n      ])\n      .sendChangeTo(ctx.buyer.address)\n      .payFee(RECOMMENDED_MIN_FEE_VALUE)\n      .build();\n\n    const result = ctx.mockChain.execute(transaction, { signers: [ctx.buyer], throw: false });\n    expect(result).toBe(false); // Fails due to incrementExchangeCounterCorrectly\n  });\n\n  /**\n   * HACK 4: The Super Refund\n   * Attacker returns tokens but inflates the 'Refunded' counter (R6[1])\n   * to create \"phantom\" inventory.\n   */\n  it(\"should REJECT a 'Super Refund' (Incrementing Refund counter more than tokens returned)\", () => {\n    const tokensToRefund = 100n;\n    const refundValue = tokensToRefund * ctx.exchangeRate;\n\n    // PREPARATION 1: Attacker's funds\n    giveTokensToBuyer([{ tokenId: ctx.projectNftId, amount: tokensToRefund }]);\n\n    // PREPARATION 2: Contract State (Failed Campaign)\n    // Clear initial box and create a \"Failed Campaign\" with funds to be refunded\n    ctx.beneContract.utxos.clear();\n\n    const soldAmount = 10000n; // Less than the minimum (50k)\n    const collectedValue = soldAmount * ctx.exchangeRate;\n\n    const refundReadyAssets = [\n      { tokenId: ctx.projectNftId, amount: 1n + ctx.totalPFTokens - soldAmount },\n      { tokenId: ctx.pftTokenId, amount: ctx.totalPFTokens }\n    ];\n    let refundReadyValue = RECOMMENDED_MIN_FEE_VALUE;\n\n    if (!ctx.isErgMode) {\n      refundReadyAssets.push({ tokenId: ctx.baseTokenId, amount: collectedValue });\n    } else {\n      refundReadyValue += collectedValue;\n    }\n\n    ctx.beneContract.addUTxOs({\n      value: refundReadyValue,\n      ergoTree: ctx.beneErgoTree.toHex(),\n      assets: refundReadyAssets,\n      creationHeight: ctx.mockChain.height,\n      additionalRegisters: {\n        R4: createR4(ctx),\n        R5: SLong(ctx.minimumTokensSold).toHex(),\n        R6: SColl(SLong, [soldAmount, 0n, 0n]).toHex(), // Sold 10k (Min NOT Reached)\n        R7: SLong(ctx.exchangeRate).toHex(),\n        R8: ctx.constants.toHex(),\n        R9: SColl(SByte, stringToBytes(\"utf8\", \"{}\")).toHex(),\n      },\n    });\n    const refundReadyBox = ctx.beneContract.utxos.toArray()[0];\n\n    // PREPARATION 3: Advance time (Deadline passed)\n    ctx.mockChain.jumpTo(ctx.deadlineBlock + 1);\n\n    // ATTACK CONSTRUCTION\n    const newAPTAmount = BigInt(refundReadyBox.assets[0].amount) + tokensToRefund;\n\n    let newValue = BigInt(refundReadyBox.value);\n    let newAssets = [\n      { tokenId: ctx.projectNftId, amount: newAPTAmount },\n      { tokenId: ctx.pftTokenId, amount: ctx.totalPFTokens }\n    ];\n\n    if (!ctx.isErgMode) {\n      const currentBase = BigInt(refundReadyBox.assets.find(a => a.tokenId === ctx.baseTokenId)?.amount || 0n);\n      newAssets.push({ tokenId: ctx.baseTokenId, amount: currentBase - refundValue });\n    } else {\n      newValue -= refundValue;\n    }\n\n    const contractOutputBuilder = new OutputBuilder(newValue, ctx.beneErgoTree)\n      .addTokens(newAssets)\n      .setAdditionalRegisters({\n        ...refundReadyBox.additionalRegisters,\n        // ATTACK: Refund Counter (R6[1]) inflated to 1,000,000\n        // It should be: Sold - Refunded\n        // If Refunded is huge, (Sold - Refunded) becomes negative and the formula adds up.\n        R6: SColl(SLong, [soldAmount, 1_000_000n, 0n]).toHex(),\n      });\n\n    const transaction = new TransactionBuilder(ctx.mockChain.height)\n      .from([refundReadyBox, ...ctx.buyer.utxos.toArray()])\n      .to([\n        contractOutputBuilder,\n        new OutputBuilder(RECOMMENDED_MIN_FEE_VALUE, ctx.buyer.address).addTokens([\n          ...(ctx.isErgMode ? [] : [{ tokenId: ctx.baseTokenId, amount: refundValue }])\n        ])\n      ])\n      .sendChangeTo(ctx.buyer.address)\n      .payFee(RECOMMENDED_MIN_FEE_VALUE)\n      .build();\n\n    const result = ctx.mockChain.execute(transaction, { signers: [ctx.buyer], throw: false });\n    expect(result).toBe(false); // Fails due to incrementRefundCounterCorrectly\n  });\n\n});","path":null,"size_bytes":12791,"size_tokens":null},"src/lib/ergo/envs.ts":{"content":"export const network_id: \"mainnet\" | \"testnet\" = \"mainnet\";\nexport const DEFAULT_WEB_EXPLORER_URI_TX = (network_id == \"mainnet\") ? \"https://sigmaspace.io/en/transaction/\" : \"https://testnet.ergoplatform.com/transactions/\";\nexport const DEFAULT_WEB_EXPLORER_URI_ADDR = (network_id == \"mainnet\") ? \"https://sigmaspace.io/en/address/\" : \"https://testnet.ergoplatform.com/addresses/\";\nexport const DEFAULT_WEB_EXPLORER_URI_TKN = (network_id == \"mainnet\") ? \"https://sigmaspace.io/en/token/\" : \"https://testnet.ergoplatform.com/tokens/\";\n","path":null,"size_bytes":533,"size_tokens":null},"src/lib/components/ui/carousel/index.ts":{"content":"export { default as Root } from \"./carousel.svelte\";\nexport { default as Content } from \"./carousel-content.svelte\";\nexport { default as Item } from \"./carousel-item.svelte\";\nexport { default as Previous } from \"./carousel-previous.svelte\";\nexport { default as Next } from \"./carousel-next.svelte\";\n","path":null,"size_bytes":299,"size_tokens":null},"src/lib/ergo/actions/__submit_with_chain.ts":{"content":"import {\n    OutputBuilder,\n    SAFE_MIN_BOX_VALUE,\n    RECOMMENDED_MIN_FEE_VALUE,\n    TransactionBuilder,\n    SLong,\n    type Box\n} from '@fleet-sdk/core';\nimport { SInt, SPair } from '@fleet-sdk/serializer';\nimport { SString } from '../utils';\nimport { type contract_version, get_ergotree_hex, mint_contract_address } from '../contract';\nimport { getCurrentHeight, getChangeAddress, signTransaction, submitTransaction } from '../wallet-utils';\nimport { type ConstantContent } from '$lib/common/project';\nimport { get_dev_contract_address, get_dev_contract_hash, get_dev_fee } from '../dev/dev_contract';\nimport { fetch_token_details, wait_until_confirmation } from '../fetch';\n\nasync function get_token_data(token_id: string): Promise<{amount: number, decimals: number}> {\n    let token_fetch = await fetch_token_details(token_id);\n    let id_token_amount = token_fetch['emissionAmount'] ?? 0;\n    if (id_token_amount === 0) { alert(token_id+\" token emission amount is 0.\"); throw new Error(token_id+\" token emission amount is 0.\") }\n    id_token_amount += 1;\n    return {\"amount\": id_token_amount, \"decimals\": token_fetch['decimals']}\n}\n\n// Function to submit a project to the blockchain\nexport async function submit_project(\n    version: contract_version,\n    token_id: string, \n    token_amount: number,\n    blockLimit: number,     // Block height until withdrawal/refund is allowed\n    exchangeRate: number,   // Exchange rate ERG/Token\n    projectContent: string,    // Project content\n    minimumSold: number,     // Minimum amount sold to allow withdrawal\n    title: string\n): Promise<string|null> {\n\n    // Get the wallet address (will be the project address)\n    const walletPk = await getChangeAddress();\n\n    let addressContent: ConstantContent = {\n        \"owner\": walletPk,\n        \"dev_addr\": get_dev_contract_address(),\n        \"dev_hash\": get_dev_contract_hash(),\n        \"dev_fee\": get_dev_fee(),\n        \"pft_token_id\": token_id\n    };\n\n    // Get token emission amount.\n    let token_data = await get_token_data(token_id);\n    let id_token_amount = token_data[\"amount\"];\n    let id_token_decimals = token_data[\"decimals\"];\n\n    // Get the UTXOs from the current wallet to use as inputs\n    const inputs = await window.ergo!.get_utxos();\n\n    let mintOutput = new OutputBuilder(\n            SAFE_MIN_BOX_VALUE, // Minimum value in ERG that a box can have\n            mint_contract_address(addressContent, version)\n        )\n        .mintToken({ \n            amount: BigInt(id_token_amount),\n            name: title+\" APT\",    // A pro for use IDT (identity token) and TFT (temporal funding token) with the same token is that the TFT token that the user holds has the same id than the project.  This allows the user to verify the exact project in case than two projects has the same name.\n            decimals: id_token_decimals, \n            description: \"Temporal-funding Token for the \" + title + \" project. Please, exchange the PFT for the project token on Bene once the deadline has passed.\"\n        });\n\n    let contractOutput = new OutputBuilder(\n            SAFE_MIN_BOX_VALUE, // Minimum value in ERG that a box can have\n            get_ergotree_hex(addressContent, version)    // Address of the project contract\n        )\n        .addTokens({\n            tokenId: inputs[0].boxId,\n            amount: BigInt(id_token_amount)  // The mint contract force to spend all the id_token_amount\n        })\n        .addTokens({\n            tokenId: token_id ?? \"\",\n            amount: token_amount.toString()\n        })\n        .setAdditionalRegisters({\n           R4: SInt(blockLimit).toHex(),                              // Block limit for withdrawals/refunds\n           R5: SLong(BigInt(minimumSold)).toHex(),                    // Minimum sold\n           R6: SPair(SLong(BigInt(0)), SLong(BigInt(0))).toHex(),     // Pair [Tokens sold counter, Tokens refunded counter]\n           R7: SLong(BigInt(exchangeRate)).toHex(),                   // Exchange rate ERG/Token\n           R8: SString(JSON.stringify(addressContent)),               // Owner address, dev address and dev fee.\n           R9: SString(projectContent)                                // Project content\n        });\n\n    // Building the unsigned transaction\n    const unsignedTransaction = await new TransactionBuilder(await getCurrentHeight())\n        .from(inputs) \n        .to(mintOutput)  \n        .sendChangeTo(walletPk) \n        .payFee(RECOMMENDED_MIN_FEE_VALUE)  \n        .build()\n        .chain((builder) => \n            builder\n                .to(contractOutput)\n                .payFee(RECOMMENDED_MIN_FEE_VALUE)\n                .build()\n        )\n        .toEIP12Object();\n\n    // Sign the transaction\n    const signedTransaction = await signTransaction(unsignedTransaction);\n\n    // Send the transaction to the Ergo network\n    const transactionId = await submitTransaction(signedTransaction);\n\n    console.log(\"Transaction id -> \", transactionId);\n    return transactionId;\n}\n","path":null,"size_bytes":4979,"size_tokens":null},"src/lib/components/ui/alert/index.ts":{"content":"import { type VariantProps, tv } from \"tailwind-variants\";\n\nimport Root from \"./alert.svelte\";\nimport Description from \"./alert-description.svelte\";\nimport Title from \"./alert-title.svelte\";\n\nexport const alertVariants = tv({\n\tbase: \"[&>svg]:text-foreground relative w-full rounded-lg border p-4 [&:has(svg)]:pl-11 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4\",\n\n\tvariants: {\n\t\tvariant: {\n\t\t\tdefault: \"bg-background text-foreground\",\n\t\t\tdestructive:\n\t\t\t\t\"border-destructive/50 text-destructive text-destructive dark:border-destructive [&>svg]:text-destructive\",\n\t\t},\n\t},\n\tdefaultVariants: {\n\t\tvariant: \"default\",\n\t},\n});\n\nexport type Variant = VariantProps<typeof alertVariants>[\"variant\"];\nexport type HeadingLevel = \"h1\" | \"h2\" | \"h3\" | \"h4\" | \"h5\" | \"h6\";\n\nexport {\n\tRoot,\n\tDescription,\n\tTitle,\n\t//\n\tRoot as Alert,\n\tDescription as AlertDescription,\n\tTitle as AlertTitle,\n};\n","path":null,"size_bytes":909,"size_tokens":null},"src/lib/ergo/forum/utils.ts":{"content":"import { stringToBytes } from \"@scure/base\";\nimport {\n    ErgoAddress,\n    type Box,\n    type Amount\n} from '@fleet-sdk/core';\nimport { SByte, SColl, SConstant, SGroupElement } from '@fleet-sdk/serializer';\n\nexport function hexToUtf8(hexString: string): string | null {\n    try {\n        if (hexString.length % 2 !== 0) {\n            return null;\n        }\n    \n        const byteArray = new Uint8Array(hexString.match(/.{1,2}/g)!.map(byte => parseInt(byte, 16)));\n        const decoder = new TextDecoder('utf-8');\n        const utf8String = decoder.decode(byteArray);\n    \n        return utf8String;\n    } catch {\n        return null;\n    }\n  }\n\nexport function generate_pk_proposition(wallet_pk: string): string {\n    const pk = ErgoAddress.fromBase58(wallet_pk).getPublicKeys()[0];\n    const encodedProp = SGroupElement(pk);\n    return encodedProp.toHex();\n}\n\nexport function SString(value: string): string {\n    return SColl(SByte, hexToBytes(value) ?? \"\").toHex();\n}\n\nexport function uint8ArrayToHex(array: Uint8Array): string { \n    return [...new Uint8Array(array)]\n        .map(x => x.toString(16).padStart(2, '0'))\n        .join('');\n}\n\nexport function parseLongColl(renderedValue: any): bigint[] | null {\n    if (!Array.isArray(renderedValue)) {\n        return null;\n    }\n    try {\n        return renderedValue.map(item => {\n            if (typeof item === 'string' || typeof item === 'number' || typeof item === 'bigint') {\n                return BigInt(item);\n            }\n            throw new Error(`No se puede convertir el item '${item}' a BigInt.`);\n        });\n    } catch (e) {\n        console.error(\"parseLongColl: Error convirtiendo items a BigInt:\", renderedValue, e);\n        return null;\n    }\n}\n\nexport function hexToBytes(hexString: string | undefined | null): Uint8Array | null {\n    if (!hexString || typeof hexString !== 'string' || !/^[0-9a-fA-F]*$/.test(hexString)) {\n        return null;\n    }\n    if (hexString.length % 2 !== 0) {\n        return null; \n    }\n    try {\n        const byteArray = new Uint8Array(hexString.length / 2);\n        for (let i = 0; i < byteArray.length; i++) {\n            const byte = parseInt(hexString.substring(i * 2, i * 2 + 2), 16);\n            if (isNaN(byte)) {\n                throw new Error(\"Se encontrÃ³ un carÃ¡cter hexadecimal invÃ¡lido durante el parseInt.\");\n            }\n            byteArray[i] = byte;\n        }\n        return byteArray;\n    } catch (e) {\n        console.error(\"hexToBytes: Error convirtiendo hex a bytes:\", hexString, e);\n        return null;\n    }\n}\n\nexport function parseIntFromRendered(renderedValue: any): number | null {\n    if (renderedValue === null || renderedValue === undefined) return null;\n\n    if (typeof renderedValue === 'number') {\n        return Number.isFinite(renderedValue) ? renderedValue : null;\n    }\n    if (typeof renderedValue === 'string') {\n        const num = parseInt(renderedValue, 10);\n        return Number.isFinite(num) ? num : null;\n    }\n    return null;\n}\n\nexport function parseCollByteToHex(renderedValue: any): string | null {\n    if (renderedValue === null || renderedValue === undefined) return null;\n\n    if (Array.isArray(renderedValue) && renderedValue.every(item => typeof item === 'number' && item >= 0 && item <= 255)) {\n        try {\n            return uint8ArrayToHex(new Uint8Array(renderedValue));\n        } catch (e) {\n            console.error(\"parseCollByteToHex: Error convirtiendo array de bytes a hex:\", renderedValue, e);\n            return null;\n        }\n    }\n    if (typeof renderedValue === 'string') {\n        const cleanedHex = renderedValue.startsWith('0x') ? renderedValue.substring(2) : renderedValue;\n        if (/^[0-9a-fA-F]*$/.test(cleanedHex) && cleanedHex.length % 2 === 0) {\n            return cleanedHex;\n        }\n    }\n    return null;\n}\n\nexport function parseIntFromHex(renderedValue: any): number | null {\n    if (typeof renderedValue !== 'string' && typeof renderedValue !== 'number') return null;\n    try {\n        if (typeof renderedValue === 'number') return renderedValue;\n        const num = parseInt(renderedValue, 10);\n        return isNaN(num) ? null : num;\n    } catch (e) { return null; }\n}\n\nexport function utf8StringToCollByteHex(inputString: string): string {\n    const bytes = stringToBytes('utf8', inputString);\n    return SColl(SByte, bytes).toHex();\n}\n\nexport function bigintToLongByteArray(value: bigint): Uint8Array {\n    const MIN_LONG = -(2n ** 63n);\n    const MAX_LONG = (2n ** 63n) - 1n;\n\n    if (value < MIN_LONG || value > MAX_LONG) {\n        throw new Error(`Valor ${value} estÃ¡ fuera del rango para un Long de 64 bits con signo.`);\n    }\n\n    const buffer = new ArrayBuffer(8);\n    const view = new DataView(buffer);\n    view.setBigInt64(0, value, false);\n\n    return new Uint8Array(buffer);\n}\n\nexport function parseBox(e: Box<Amount>): Box<Amount> {\n    return {\n        boxId: e.boxId,\n        value: e.value,\n        assets: e.assets,\n        ergoTree: e.ergoTree,\n        creationHeight: e.creationHeight,\n        additionalRegisters: e.additionalRegisters,\n        index: e.index,\n        transactionId: e.transactionId\n    };\n}\n\n/**\n * A utility function to convert a serialized value to its \"rendered\" format (for debugging/display).\n * This is a simplification and may not cover all Ergo types.\n * @param serializedValue The full serialized hex string.\n * @returns A simplified hex string.\n */\nexport function serializedToRendered(serializedValue: string): string {\n    if (serializedValue.startsWith('0e')) {\n        return serializedValue.substring(4);\n    } else if (serializedValue.startsWith('04')) {\n        return serializedValue.substring(2);\n    }\n    return serializedValue;\n}\n\n/**\n * Converts a JavaScript string directly to its \"rendered\" hex format.\n * This is a convenience function that combines stringToSerialized and serializedToRendered.\n * @param value The string to convert.\n * @returns The simplified, rendered hex string.\n */\nexport function stringToRendered(value: string): string {\n    return serializedToRendered(SString(value));\n}\n\nexport function pkHexToBase58Address(pkHex?: string): string {\n    if (!pkHex) return \"N/A\";\n    try {\n        const pkBytes = hexToBytes(pkHex);\n        if (!pkBytes) return \"Invalid PK\";\n        return ErgoAddress.fromPublicKey(pkBytes).toString();\n    } catch { return \"Invalid PK\"; }\n}","path":null,"size_bytes":6362,"size_tokens":null},"src/lib/components/ui/form/index.ts":{"content":"import * as FormPrimitive from \"formsnap\";\nimport Description from \"./form-description.svelte\";\nimport Label from \"./form-label.svelte\";\nimport FieldErrors from \"./form-field-errors.svelte\";\nimport Field from \"./form-field.svelte\";\nimport Fieldset from \"./form-fieldset.svelte\";\nimport Legend from \"./form-legend.svelte\";\nimport ElementField from \"./form-element-field.svelte\";\nimport Button from \"./form-button.svelte\";\n\nconst Control = FormPrimitive.Control;\n\nexport {\n\tField,\n\tControl,\n\tLabel,\n\tButton,\n\tFieldErrors,\n\tDescription,\n\tFieldset,\n\tLegend,\n\tElementField,\n\t//\n\tField as FormField,\n\tControl as FormControl,\n\tDescription as FormDescription,\n\tLabel as FormLabel,\n\tFieldErrors as FormFieldErrors,\n\tFieldset as FormFieldset,\n\tLegend as FormLegend,\n\tElementField as FormElementField,\n\tButton as FormButton,\n};\n","path":null,"size_bytes":817,"size_tokens":null},"src/lib/components/ui/badge/index.ts":{"content":"import { type VariantProps, tv } from \"tailwind-variants\";\nexport { default as Badge } from \"./badge.svelte\";\n\nexport const badgeVariants = tv({\n\tbase: \"focus:ring-ring inline-flex select-none items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2\",\n\tvariants: {\n\t\tvariant: {\n\t\t\tdefault: \"bg-primary text-primary-foreground hover:bg-primary/80 border-transparent\",\n\t\t\tsecondary:\n\t\t\t\t\"bg-secondary text-secondary-foreground hover:bg-secondary/80 border-transparent\",\n\t\t\tdestructive:\n\t\t\t\t\"bg-destructive text-destructive-foreground hover:bg-destructive/80 border-transparent\",\n\t\t\toutline: \"text-foreground\",\n\t\t},\n\t},\n\tdefaultVariants: {\n\t\tvariant: \"default\",\n\t},\n});\n\nexport type Variant = VariantProps<typeof badgeVariants>[\"variant\"];\n","path":null,"size_bytes":819,"size_tokens":null},"src/lib/wallet/wallet-manager.ts":{"content":"import { writable, derived, get } from 'svelte/store';\nimport type { WalletState, WalletInfo, WalletConnector, ErgoWalletAdapter } from './types';\nimport { NautilusWalletAdapter } from './adapters/nautilus';\nimport { SafewWalletAdapter } from './adapters/safew';\n\n\n// Create wallet store\nconst createWalletStore = () => {\n  const { subscribe, set, update } = writable<WalletState>({\n    connectedWallet: null,\n    availableWallets: [],\n    isConnecting: false,\n    error: null,\n    modalOpen: false\n  });\n\n  return {\n    subscribe,\n    set,\n    update,\n    \n    // Actions\n    setConnectedWallet: (wallet: WalletInfo | null) => \n      update(state => ({ ...state, connectedWallet: wallet })),\n    \n    setConnecting: (isConnecting: boolean) => \n      update(state => ({ ...state, isConnecting })),\n    \n    setError: (error: string | null) => \n      update(state => ({ ...state, error })),\n    \n    setModalOpen: (modalOpen: boolean) => \n      update(state => ({ ...state, modalOpen })),\n    \n    setAvailableWallets: (wallets: WalletConnector[]) => \n      update(state => ({ ...state, availableWallets: wallets }))\n  };\n};\n\nexport const walletStore = createWalletStore();\n\n// Derived stores for easy access\nexport const walletConnected = derived(walletStore, $store => !!$store.connectedWallet);\nexport const walletAddress = derived(walletStore, $store => $store.connectedWallet?.address || '');\nexport const walletBalance = derived(walletStore, $store => $store.connectedWallet?.balance || { nanoErgs: 0n, tokens: [] });\nexport const walletError = derived(walletStore, $store => $store.error);\nexport const walletConnecting = derived(walletStore, $store => $store.isConnecting);\nexport const walletModalOpen = derived(walletStore, $store => $store.modalOpen);\nexport const availableWallets = derived(walletStore, $store => $store.availableWallets);\n\n// Wallet connectors configuration\nconst walletConnectors: WalletConnector[] = [\n  {\n    id: 'nautilus',\n    name: 'Nautilus Wallet',\n    shortName: 'Nautilus',\n    iconUrl: '/wallet-icons/nautilus.png',\n    iconBackground: '#1a73e8',\n    iconAccent: '#4285f4',\n    downloadUrls: {\n      chrome: 'https://chrome.google.com/webstore/detail/nautilus-wallet/gjlmehlldlphhljhpnlddaodbjjcchai',\n      firefox: 'https://addons.mozilla.org/en-US/firefox/addon/nautilus/',\n      browserExtension: 'https://github.com/capt-nemo429/nautilus-wallet'\n    },\n    createConnector: () => new NautilusWalletAdapter()\n  },\n  {\n    id: 'safew',\n    name: 'SAFEW',\n    shortName: 'SAFEW',\n    iconUrl: '/wallet-icons/safew.png',\n    iconBackground: '#ff6b35',\n    iconAccent: '#ff8c42',\n    downloadUrls: {\n      chrome: 'https://chrome.google.com/webstore/detail/safew/jkcclpkbediabkjkoeghfimdcjnggpan',\n      firefox: 'https://addons.mozilla.org/en-US/firefox/addon/safew/',\n      browserExtension: 'https://github.com/ThierryM1212/SAFEW'\n    },\n    createConnector: () => new SafewWalletAdapter()\n  }\n];\n\n// Wallet manager class\nexport class WalletManager {\n  private currentAdapter: ErgoWalletAdapter | null = null;\n  private balanceUpdateInterval: number | null = null;\n  private addressPollInterval: number | null = null;\n\n  constructor() {\n    this.initializeWallets();\n    this.setupAutoReconnect();\n  }\n\n  private initializeWallets() {\n    // Check which wallets are installed and update the store\n    const availableWallets = walletConnectors.map(connector => ({\n      ...connector,\n      installed: connector.createConnector().isInstalled()\n    }));\n    \n    walletStore.setAvailableWallets(availableWallets);\n  }\n\n  async connectWallet(walletId: string): Promise<boolean> {\n    try {\n      console.log(`WalletManager: Connecting to wallet ${walletId}...`);\n      walletStore.setConnecting(true);\n      walletStore.setError(null);\n      \n      // Ensure any previous adapter is disconnected first\n      if (this.currentAdapter) {\n        try {\n          await this.currentAdapter.disconnect();\n        } catch (error) {\n          console.warn('Error disconnecting previous adapter:', error);\n        }\n        this.currentAdapter = null;\n      }\n\n      const connector = walletConnectors.find(w => w.id === walletId);\n      if (!connector) {\n        throw new Error(`Wallet ${walletId} not found`);\n      }\n      console.log(`WalletManager: Found connector for ${connector.name}`);\n\n\n      const adapter = connector.createConnector();\n      console.log(`WalletManager: Created adapter for ${connector.name}`);\n      \n      if (!adapter.isInstalled()) {\n        console.log(`WalletManager: ${connector.name} is not installed`);\n        throw new Error(`${connector.name} is not installed`);\n      }\n      console.log(`WalletManager: Installation check passed for ${connector.name}`);\n\n      console.log(`WalletManager: Calling connect() on ${connector.name} adapter...`);\n      \n      // Add timeout to prevent hanging connections\n      const connectPromise = adapter.connect();\n      const timeoutPromise = new Promise<boolean>((_, reject) => {\n        setTimeout(() => reject(new Error('Connection timeout after 30 seconds')), 30000);\n      });\n      \n      const connected = await Promise.race([connectPromise, timeoutPromise]);\n      console.log(`WalletManager: Connect result for ${connector.name}:`, connected);\n      \n      if (!connected) {\n        throw new Error(`Failed to connect to ${connector.name}`);\n      }\n\n      // Get wallet info\n      console.log(`WalletManager: Getting wallet info for ${connector.name}...`);\n      const address = await adapter.getChangeAddress();\n      const addresses = await adapter.getAddresses();\n      \n      // Handle balance fetching with error handling\n      let balance;\n      try {\n        balance = await adapter.getBalance();\n        console.log(`WalletManager: Balance fetched successfully`);\n      } catch (error) {\n        console.warn(`WalletManager: Balance fetch failed, using default:`, error);\n        balance = { nanoErgs: BigInt(0), tokens: [] };\n      }\n      \n      const networkId = await adapter.getNetworkId();\n\n      const walletInfo: WalletInfo = {\n        adapter,\n        address,\n        addresses,\n        balance,\n        networkId,\n        isConnected: true\n      };\n\n      this.currentAdapter = adapter;\n      walletStore.setConnectedWallet(walletInfo);\n      \n      // Sync with old stores for backward compatibility\n      await this.syncWithOldStores(walletInfo);\n      \n      // Setup event listeners\n      this.setupWalletEventListeners(adapter);\n      \n      // Start balance updates\n      this.startBalanceUpdates();\n      \n      // Store connection for auto-reconnect\n      if (typeof localStorage !== 'undefined') {\n        localStorage.setItem('ergo_wallet_connection', walletId);\n        // Also store connection timestamp for debugging\n        localStorage.setItem('ergo_wallet_connection_time', new Date().toISOString());\n      }\n\n      walletStore.setModalOpen(false);\n      return true;\n\n    } catch (error) {\n      console.error('Wallet connection error:', error);\n      walletStore.setError(error instanceof Error ? error.message : 'Connection failed');\n      return false;\n    } finally {\n      walletStore.setConnecting(false);\n    }\n  }\n\n  private async syncWithOldStores(walletInfo: WalletInfo): Promise<void> {\n    try {\n      // Import the old stores to maintain compatibility\n      const { address, connected, balance, network, user_tokens } = await import('../common/store');\n      \n      // Update old stores with new wallet info\n      address.set(walletInfo.address);\n      connected.set(true);\n      balance.set(Number(walletInfo.balance.nanoErgs));\n      network.set(walletInfo.networkId === \"mainnet\" ? \"ergo-mainnet\" : \"ergo-testnet\");\n      \n      // Clear cached token data to ensure fresh data for this wallet\n      user_tokens.set(new Map());\n      \n      console.log('Synced new wallet system with old stores and cleared token cache');\n    } catch (error) {\n      console.error('Failed to sync with old stores:', error);\n    }\n  }\n\n  async disconnectWallet(): Promise<void> {\n    try {\n      // Import the old stores to maintain compatibility\n      const { address, connected, balance, network, user_tokens } = await import('../common/store');\n      \n      if (this.currentAdapter) {\n        try {\n          // Try to disconnect from wallet, but don't fail if it doesn't work\n          await this.currentAdapter.disconnect();\n        } catch (error) {\n          console.warn('Wallet disconnect method failed, continuing with cleanup:', error);\n        }\n        this.currentAdapter = null;\n      }\n\n      this.stopBalanceUpdates();\n      \n      // Update new wallet stores\n      walletStore.setConnectedWallet(null);\n      walletStore.setError(null);\n      \n      // Update old stores for backward compatibility\n      address.set(null);\n      connected.set(false);\n      balance.set(null);\n      network.set(null);\n      \n      // Clear cached token data to ensure fresh data on next connection\n      user_tokens.set(new Map());\n\n      // Clear stored connection\n      if (typeof localStorage !== 'undefined') {\n        localStorage.removeItem('ergo_wallet_connection');\n      }\n      \n      // Small delay to ensure proper cleanup before next connection\n      await new Promise(resolve => setTimeout(resolve, 100));\n      \n      console.log('Wallet disconnected successfully');\n\n    } catch (error) {\n      console.error('Wallet disconnection error:', error);\n      walletStore.setError(error instanceof Error ? error.message : 'Disconnection failed');\n    }\n  }\n\n  async refreshBalance(): Promise<void> {\n    const state = get(walletStore);\n    if (!state.connectedWallet || !this.currentAdapter) return;\n\n    try {\n      const balance = await this.currentAdapter.getBalance();\n      walletStore.update(state => ({\n        ...state,\n        connectedWallet: state.connectedWallet ? {\n          ...state.connectedWallet,\n          balance\n        } : null\n      }));\n    } catch (error) {\n      console.error('Balance refresh error:', error);\n    }\n  }\n\n  private async checkAddressChange(): Promise<void> {\n    const state = get(walletStore);\n    if (!state.connectedWallet || !this.currentAdapter) return;\n\n    try {\n      const newAddress = await this.currentAdapter.getChangeAddress();\n      if (newAddress && newAddress !== state.connectedWallet.address) {\n        let addresses: string[] = state.connectedWallet.addresses;\n        try {\n          addresses = await this.currentAdapter.getAddresses();\n        } catch (_err) {\n          // keep previous addresses if fetching fails\n        }\n        walletStore.update(s => ({\n          ...s,\n          connectedWallet: s.connectedWallet ? {\n            ...s.connectedWallet,\n            address: newAddress,\n            addresses\n          } : null\n        }));\n      }\n    } catch (_err) {\n      // ignore transient errors\n    }\n  }\n\n  private setupWalletEventListeners(adapter: ErgoWalletAdapter) {\n    adapter.on('disconnect', () => {\n      this.disconnectWallet();\n    });\n\n    adapter.on('addressChanged', async () => {\n      try {\n        const address = await adapter.getChangeAddress();\n        const addresses = await adapter.getAddresses();\n        walletStore.update(state => ({\n          ...state,\n          connectedWallet: state.connectedWallet ? {\n            ...state.connectedWallet,\n            address,\n            addresses\n          } : null\n        }));\n      } catch (error) {\n        console.error('Address change error:', error);\n      }\n    });\n\n    adapter.on('balanceChanged', () => {\n      this.refreshBalance();\n    });\n  }\n\n  private startBalanceUpdates() {\n    this.stopBalanceUpdates();\n    // Update balance every 60 seconds instead of 30 to reduce API calls\n    this.balanceUpdateInterval = setInterval(() => {\n      this.refreshBalance();\n    }, 60000);\n\n    // Poll for address changes less frequently (every 5 seconds instead of 3)\n    // to reduce performance impact\n    this.addressPollInterval = setInterval(() => {\n      void this.checkAddressChange();\n    }, 5000);\n  }\n\n  private stopBalanceUpdates() {\n    if (this.balanceUpdateInterval) {\n      clearInterval(this.balanceUpdateInterval);\n      this.balanceUpdateInterval = null;\n    }\n    if (this.addressPollInterval) {\n      clearInterval(this.addressPollInterval);\n      this.addressPollInterval = null;\n    }\n  }\n\n  private async setupAutoReconnect() {\n    if (typeof window === 'undefined') return;\n\n    // Wait for wallets to be available\n    await new Promise(resolve => setTimeout(resolve, 1000));\n\n    const storedWalletId = localStorage.getItem('ergo_wallet_connection');\n    if (storedWalletId) {\n      try {\n        // Attempt to reconnect to the stored wallet\n        await this.connectWallet(storedWalletId);\n      } catch (error) {\n        console.error('Auto-reconnect failed:', error);\n        localStorage.removeItem('ergo_wallet_connection');\n      }\n    }\n  }\n\n  openModal() {\n    walletStore.setModalOpen(true);\n  }\n\n  closeModal() {\n    walletStore.setModalOpen(false);\n  }\n\n  isConnected(): boolean {\n    return this.currentAdapter !== null;\n  }\n\n  getConnectedWallet(): ErgoWalletAdapter | null {\n    return this.currentAdapter;\n  }\n}\n\n// Create singleton instance\nexport const walletManager = new WalletManager();\n","path":null,"size_bytes":13247,"size_tokens":null},"src/lib/components/ui/select/index.ts":{"content":"import { Select as SelectPrimitive } from \"bits-ui\";\n\nimport Label from \"./select-label.svelte\";\nimport Item from \"./select-item.svelte\";\nimport Content from \"./select-content.svelte\";\nimport Trigger from \"./select-trigger.svelte\";\nimport Separator from \"./select-separator.svelte\";\n\nconst Root = SelectPrimitive.Root;\nconst Group = SelectPrimitive.Group;\nconst Input = SelectPrimitive.Input;\nconst Value = SelectPrimitive.Value;\n\nexport {\n\tRoot,\n\tGroup,\n\tInput,\n\tLabel,\n\tItem,\n\tValue,\n\tContent,\n\tTrigger,\n\tSeparator,\n\t//\n\tRoot as Select,\n\tGroup as SelectGroup,\n\tInput as SelectInput,\n\tLabel as SelectLabel,\n\tItem as SelectItem,\n\tValue as SelectValue,\n\tContent as SelectContent,\n\tTrigger as SelectTrigger,\n\tSeparator as SelectSeparator,\n};\n","path":null,"size_bytes":740,"size_tokens":null},"src/lib/wallet/types.ts":{"content":"// Core wallet types for Ergo RainbowKit-style implementation\nexport interface ErgoWalletAdapter {\n  // Wallet identification\n  id: string;\n  name: string;\n  icon: string;\n  downloadUrls?: WalletDownloadUrls;\n  \n  // Connection methods\n  connect(): Promise<boolean>;\n  disconnect(): Promise<void>;\n  isConnected(): Promise<boolean>;\n  \n  // Address management\n  getAddresses(): Promise<string[]>;\n  getChangeAddress(): Promise<string>;\n  \n  // Balance queries\n  getBalance(address?: string): Promise<WalletBalance>;\n  \n  // Transaction methods\n  signTransaction(unsignedTx: any): Promise<any>;\n  submitTransaction(signedTx: any): Promise<string>;\n  \n  // Network info\n  getNetworkId(): Promise<string>;\n  getCurrentHeight(): Promise<number>;\n  \n  // Event handling\n  on(event: WalletEvent, callback: (data: any) => void): void;\n  off(event: WalletEvent, callback: (data: any) => void): void;\n  \n  // Installation detection\n  isInstalled(): boolean;\n}\n\nexport interface WalletBalance {\n  nanoErgs: bigint;\n  tokens: WalletToken[];\n}\n\nexport interface WalletToken {\n  tokenId: string;\n  amount: bigint;\n  name?: string;\n  decimals?: number;\n}\n\nexport interface WalletDownloadUrls {\n  chrome?: string;\n  firefox?: string;\n  edge?: string;\n  safari?: string;\n  browserExtension?: string;\n  android?: string;\n  ios?: string;\n  mobile?: string;\n  desktop?: string;\n}\n\nexport type WalletEvent = \n  | 'connect' \n  | 'disconnect' \n  | 'addressChanged' \n  | 'networkChanged' \n  | 'balanceChanged';\n\nexport interface WalletInfo {\n  adapter: ErgoWalletAdapter;\n  address: string;\n  addresses: string[];\n  balance: WalletBalance;\n  networkId: string;\n  isConnected: boolean;\n}\n\nexport interface WalletModalConfig {\n  title?: string;\n  showRecentTransactions?: boolean;\n  showBalance?: boolean;\n  theme?: 'light' | 'dark' | 'auto';\n}\n\n// Wallet connector interface similar to RainbowKit\nexport interface WalletConnector {\n  id: string;\n  name: string;\n  shortName?: string;\n  iconUrl: string;\n  iconBackground: string;\n  iconAccent?: string;\n  installed?: boolean;\n  downloadUrls?: WalletDownloadUrls;\n  createConnector: () => ErgoWalletAdapter;\n}\n\n// Global wallet state\nexport interface WalletState {\n  connectedWallet: WalletInfo | null;\n  availableWallets: WalletConnector[];\n  isConnecting: boolean;\n  error: string | null;\n  modalOpen: boolean;\n}\n","path":null,"size_bytes":2339,"size_tokens":null},"src/lib/ergo/forum/submit.ts":{"content":"import {\n    OutputBuilder,\n    SAFE_MIN_BOX_VALUE,\n    RECOMMENDED_MIN_FEE_VALUE,\n    TransactionBuilder,\n    type Box,\n    type Amount,\n    ErgoAddress\n} from '@fleet-sdk/core';\nimport { SColl, SByte, SBool } from '@fleet-sdk/serializer';\nimport { type RPBox } from './object';\nimport { PROFILE_TYPE_NFT_ID } from './envs';\nimport { explorer_uri } from '$lib/common/store';\nimport { get } from 'svelte/store';\nimport { hexToBytes } from './utils';\nimport { ergo_tree_address } from './contract';\nimport { stringToBytes } from '@scure/base';\n\n// Global ergo wallet connector (injected by browser wallet extension)\ndeclare const ergo: any;\n\n/**\n * Generates or modifies a reputation proof by building and submitting a transaction.\n * @param token_amount The amount of the token for the new proof box.\n * @param total_supply The total supply of the reputation token set.\n * @param type_nft_id The token ID of the Type NFT that defines the standard for this proof.\n * @param object_pointer The object this proof is about (e.g., a URL, another token ID).\n * @param polarization `true` for a positive proof, `false` for a negative one.\n * @param content The JSON or string content for register R9.\n * @param is_locked `true` to make the resulting box immutable.\n * @param input_proof The existing RPBox to spend from (for splitting or modifying).\n * @returns A promise that resolves to the transaction ID string, or null on failure.\n */\nexport async function generate_reputation_proof(\n    token_amount: number,\n    total_supply: number,\n    type_nft_id: string,\n    object_pointer: string | undefined,\n    polarization: boolean,\n    content: object | string | null,\n    is_locked: boolean = false,\n    input_proof?: RPBox,\n): Promise<string | null> {\n\n\n    console.log(\"Generating reputation proof with parameters:\", {\n        token_amount,\n        total_supply,\n        type_nft_id,\n        object_pointer,\n        polarization,\n        content,\n        is_locked,\n        input_proof\n    });\n\n    const creatorAddressString = await ergo.get_change_address();\n    if (!creatorAddressString) {\n        throw new Error(\"Could not get the creator's address from the wallet.\");\n    }\n    const creatorP2PKAddress = ErgoAddress.fromBase58(creatorAddressString);\n\n    // Fetch the Type NFT box to be used in dataInputs. This is required by the contract.\n    const typeNftBoxResponse = await fetch(`${get(explorer_uri)}/api/v1/boxes/byTokenId/${type_nft_id}`);\n    if (!typeNftBoxResponse.ok) {\n        alert(\"Could not fetch the Type NFT box. Aborting transaction.\");\n        return null;\n    }\n    const typeNftBox = (await typeNftBoxResponse.json()).items[0];\n\n    console.log(\"type nft box \", typeNftBox)\n\n    // Inputs for the transaction\n    const utxos = await ergo.get_utxos();\n    const inputs: Box<Amount>[] = input_proof ? [input_proof.box, ...utxos] : utxos;\n    let dataInputs = [typeNftBox];\n\n    // If splitting from an existing proof box with a different type NFT, we need to include both type NFTs\n    if (input_proof && input_proof.type.tokenId !== type_nft_id) {\n        const inputTypeNftBoxResponse = await fetch(`${get(explorer_uri)}/api/v1/boxes/byTokenId/${input_proof.type.tokenId}`);\n        if (inputTypeNftBoxResponse.ok) {\n            const inputTypeNftBox = (await inputTypeNftBoxResponse.json()).items[0];\n            dataInputs.push(inputTypeNftBox);\n            console.log(\"Added input proof's type NFT box to data inputs:\", inputTypeNftBox.boxId);\n        }\n    }\n\n    const outputs: OutputBuilder[] = [];\n\n    // --- Create the main output for the new/modified proof ---\n    const new_proof_output = new OutputBuilder(\n        SAFE_MIN_BOX_VALUE,\n        ergo_tree_address\n    );\n\n    if (input_proof === undefined || input_proof === null) {\n        // Minting a new token if no input proof is provided\n        new_proof_output.mintToken({\n            amount: token_amount.toString(),\n            name: \"Reputation Proof Token\", // Optional: EIP-4 metadata\n        });\n\n        if (!object_pointer) object_pointer = inputs[0].boxId;  // Points to the self token being evaluated by default\n    }\n    else {\n        // Transferring existing tokens\n        new_proof_output.addTokens({\n            tokenId: input_proof.token_id,\n            amount: token_amount.toString()\n        });\n\n        // If splitting, create a change box to send the remaining tokens back to the same contract\n        if (input_proof.token_amount - token_amount > 0) {\n            outputs.push(\n                new OutputBuilder(SAFE_MIN_BOX_VALUE, ergo_tree_address)\n                    .addTokens({\n                        tokenId: input_proof.token_id,\n                        amount: (input_proof.token_amount - token_amount).toString()\n                    })\n                    // The change box must retain the original registers\n                    .setAdditionalRegisters(input_proof.box.additionalRegisters)\n            );\n        }\n\n        if (!object_pointer) object_pointer = input_proof.token_id\n    }\n\n    const propositionBytes = hexToBytes(creatorP2PKAddress.ergoTree);\n    if (!propositionBytes) {\n        throw new Error(`Could not get proposition bytes from address ${creatorAddressString}.`);\n    }\n\n    const raw_content = typeof (content) === \"object\" ? JSON.stringify(content) : content ?? \"\";\n\n    const new_registers = {\n        R4: SColl(SByte, hexToBytes(type_nft_id) ?? \"\").toHex(),\n        R5: SColl(SByte, hexToBytes(object_pointer) ?? \"\").toHex(),\n        R6: SBool(is_locked).toHex(),\n        R7: SColl(SByte, propositionBytes).toHex(),\n        R8: SBool(polarization).toHex(),\n        R9: SColl(SByte, stringToBytes(\"utf8\", raw_content)).toHex(),\n    };\n\n    console.log(\"New registers:\", new_registers)\n\n    new_proof_output.setAdditionalRegisters(new_registers);\n\n    outputs.push(new_proof_output);\n\n    // --- Build and submit the transaction ---\n    try {\n        const unsignedTransaction = await new TransactionBuilder(await ergo.get_current_height())\n            .from(inputs)\n            .to(outputs)\n            .sendChangeTo(creatorP2PKAddress)\n            .payFee(RECOMMENDED_MIN_FEE_VALUE)\n            .withDataFrom(dataInputs)\n            .build()\n            .toEIP12Object();\n\n        const signedTransaction = await ergo.sign_tx(unsignedTransaction);\n        const transactionId = await ergo.submit_tx(signedTransaction);\n\n\n\n        console.log(\"Transaction ID -> \", transactionId);\n        return transactionId;\n    } catch (e: any) {\n        console.error(\"Error building or submitting transaction:\", e);\n        alert(`Transaction failed: ${e?.message || e}`);\n        return null;\n    }\n}","path":null,"size_bytes":6644,"size_tokens":null},"src/lib/ergo/wallet-utils.ts":{"content":"// Utility functions to handle wallet operations with SAFEW compatibility\n\nimport { walletManager } from '../wallet/wallet-manager';\n\n/**\n * Get current blockchain height - SAFEW compatible\n * Uses wallet adapter if available, falls back to API\n */\nexport async function getCurrentHeight(): Promise<number> {\n    try {\n        // Check if wallet manager is available and connected\n        if (walletManager && walletManager.isConnected()) {\n            const adapter = walletManager.getConnectedWallet();\n            if (adapter && adapter.getCurrentHeight) {\n                return await adapter.getCurrentHeight();\n            }\n        }\n        \n        // Try direct window.ergo if available (for legacy compatibility with Nautilus)\n        if (typeof window !== 'undefined' && window.ergo && window.ergo.get_current_height) {\n            return await window.ergo.get_current_height();\n        }\n    } catch (error) {\n        console.warn('Failed to get height from wallet, falling back to API:', error);\n    }\n    \n    // Fallback to API\n    const response = await fetch('https://api.ergoplatform.com/api/v1/blocks?limit=1&offset=0');\n    if (!response.ok) {\n        throw new Error(`Failed to fetch current height: ${response.status}`);\n    }\n    \n    const data = await response.json();\n    if (data.items && data.items.length > 0) {\n        return data.items[0].height;\n    }\n    \n    throw new Error('Could not determine current blockchain height');\n}\n\n/**\n * Get wallet change address - SAFEW compatible\n */\nexport async function getChangeAddress(): Promise<string> {\n    if (walletManager && walletManager.isConnected()) {\n        const adapter = walletManager.getConnectedWallet();\n        if (adapter) {\n            return await adapter.getChangeAddress();\n        }\n    }\n    \n    // Fallback to direct ergo call\n    if (typeof window !== 'undefined' && window.ergo) {\n        return await window.ergo.get_change_address();\n    }\n    \n    throw new Error('No wallet connected');\n}\n\n/**\n * Sign transaction - SAFEW compatible  \n */\nexport async function signTransaction(unsignedTx: any): Promise<any> {\n    if (walletManager && walletManager.isConnected()) {\n        const adapter = walletManager.getConnectedWallet();\n        if (adapter) {\n            return await adapter.signTransaction(unsignedTx);\n        }\n    }\n    \n    // Fallback to direct ergo call\n    if (typeof window !== 'undefined' && window.ergo) {\n        return await window.ergo.sign_tx(unsignedTx);\n    }\n    \n    throw new Error('No wallet connected');\n}\n\n/**\n * Submit transaction - SAFEW compatible\n */\nexport async function submitTransaction(signedTx: any): Promise<string> {\n    if (walletManager && walletManager.isConnected()) {\n        const adapter = walletManager.getConnectedWallet();\n        if (adapter) {\n            return await adapter.submitTransaction(signedTx);\n        }\n    }\n    \n    // Fallback to direct ergo call\n    if (typeof window !== 'undefined' && window.ergo) {\n        return await window.ergo.submit_tx(signedTx);\n    }\n    \n    throw new Error('No wallet connected');\n}\n","path":null,"size_bytes":3091,"size_tokens":null},"src/lib/ergo/actions/rebalance.ts":{"content":"import {\n    OutputBuilder,\n    RECOMMENDED_MIN_FEE_VALUE,\n    TransactionBuilder,\n    SLong,\n    SInt,\n    SAFE_MIN_BOX_VALUE\n} from '@fleet-sdk/core';\n\nimport { SString } from '../utils';\nimport { createR8Structure, type Project } from '../../common/project';\nimport { get_ergotree_hex } from '../contract';\nimport { getCurrentHeight, getChangeAddress, signTransaction, submitTransaction } from '../wallet-utils';\nimport { SBool, SColl, SPair } from '@fleet-sdk/serializer';\n\nexport async function rebalance(\n    project: Project,\n    token_amount: number\n): Promise<string | null> {\n\n    try {\n        token_amount = Math.trunc(token_amount * Math.pow(10, project.token_details.decimals));\n\n        console.log(\"wants to add \", token_amount / Math.pow(10, project.token_details.decimals), \" tokens of type \", project.token_details.name);\n\n        // Get the wallet address (will be the project address)\n        const walletPk = await getChangeAddress();\n        // Get the UTXOs from the current wallet to use as inputs\n        const walletUtxos = await window.ergo!.get_utxos();\n        // For adding tokens, we need the project box first, then a wallet UTXO\n        // This ensures INPUTS.size > 1 and INPUTS(1) comes from project address\n        const inputs = [project.box, ...walletUtxos];\n\n        // Building the project output\n        let contract_output = new OutputBuilder(\n            BigInt(project.value),\n            get_ergotree_hex(project.constants, project.version)\n        )\n            .addTokens({\n                tokenId: project.project_id,\n                amount: BigInt(project.current_idt_amount)\n            });\n\n        console.log(\"PFT current amount \" + project.current_pft_amount / Math.pow(10, project.token_details.decimals))\n        let contract_token_amount = project.current_pft_amount + token_amount;\n        console.log(\"contract token amount \" + contract_token_amount / Math.pow(10, project.token_details.decimals))\n\n        if (contract_token_amount > 0) {\n            contract_output.addTokens({\n                tokenId: project.pft_token_id,\n                amount: (contract_token_amount).toString()\n            });\n        }\n\n        // Handle base tokens for v2 multitoken contracts\n        if (project.base_token_id && project.base_token_id !== \"\") {\n            // Find current base token amount in the project box\n            let currentBaseTokenAmount = 0;\n            for (const token of project.box.assets) {\n                if (token.tokenId === project.base_token_id) {\n                    currentBaseTokenAmount = Number(token.amount);\n                    break;\n                }\n            }\n\n            // Add base token to contract output (amount remains unchanged during token rebalancing)\n            if (currentBaseTokenAmount > 0) {\n                contract_output.addTokens({\n                    tokenId: project.base_token_id,\n                    amount: BigInt(currentBaseTokenAmount)\n                });\n            }\n        }\n\n        // Set additional registers based on contract version\n        contract_output.setAdditionalRegisters({\n            R4: SPair(SBool(project.is_timestamp_limit), SLong(BigInt(project.block_limit))).toHex(),\n            R5: SLong(BigInt(project.minimum_amount)).toHex(),\n            R6: SColl(SLong, [\n                BigInt(project.sold_counter),\n                BigInt(project.refund_counter),\n                BigInt(project.auxiliar_exchange_counter)\n            ]).toHex(),\n            R7: SLong(BigInt(project.exchange_rate)).toHex(),\n            R8: createR8Structure(project.constants).toHex(),\n            R9: SString(project.content.raw)\n        });\n\n\n        let outputs: OutputBuilder[] = [contract_output];\n\n        // Building withdraw to address output\n        if (token_amount < 0) {\n            outputs.push(\n                new OutputBuilder(\n                    SAFE_MIN_BOX_VALUE,\n                    walletPk\n                )\n                    .addTokens({\n                        tokenId: project.pft_token_id,\n                        amount: ((-1) * token_amount).toString()\n                    })\n            )\n        }\n\n        // Building the unsigned transaction\n        const unsignedTransaction = await new TransactionBuilder(await getCurrentHeight())\n            .from(inputs)                          // Inputs coming from the user's UTXOs\n            .to(outputs)                           // Outputs (the new project box)\n            .sendChangeTo(walletPk)                // Send change back to the wallet\n            .payFee(RECOMMENDED_MIN_FEE_VALUE)     // Pay the recommended minimum fee\n            .build()                               // Build the transaction\n            .toEIP12Object();                      // Convert the transaction to an EIP-12 compatible object\n\n        // Sign the transaction\n        const signedTransaction = await signTransaction(unsignedTransaction);\n\n        // Send the transaction to the Ergo network\n        const transactionId = await submitTransaction(signedTransaction);\n\n        console.log(\"Transaction id -> \", transactionId);\n        return transactionId;\n\n    } catch (error) {\n        console.error(\"Error in rebalance function:\", error);\n        // Log full prover error dump if available\n        if ((error as any).info) console.error(\"Prover error info:\\n\", (error as any).info);\n\n        // Check specific error conditions\n        if ((error as any).message && (error as any).message.includes(\"R7\")) {\n            console.error(\"R7 register format error - check exchange rate and base token ID length\");\n        }\n\n        if ((error as any).message && (error as any).message.includes(\"INPUTS\")) {\n            console.error(\"Input validation error - ensure wallet has UTXOs and project box is accessible\");\n        }\n\n        return null;\n    }\n}","path":null,"size_bytes":5842,"size_tokens":null},"vite.config.ts":{"content":"import { sveltekit } from '@sveltejs/kit/vite';\nimport { defineConfig } from 'vite';\nimport path from \"path\";\n\nexport default defineConfig({\n\tplugins: [sveltekit()],\n  \tresolve: {\n    \t\talias: {\n      \t\t\t$lib: path.resolve(\"./src/lib\"),\n    \t\t},\n  \t}\n});\n\nconst config = {\n\t// â€¦\n\tssr: {\n\t  noExternal: ['three']\n\t}\n  }\n","path":null,"size_bytes":321,"size_tokens":null},"src/lib/ergo/actions/buy_refund.ts":{"content":"import {\n    OutputBuilder,\n    RECOMMENDED_MIN_FEE_VALUE,\n    TransactionBuilder,\n    SLong,\n    SAFE_MIN_BOX_VALUE\n} from '@fleet-sdk/core';\n\nimport { SString } from '../utils';\nimport { createR8Structure, type Project } from '../../common/project';\nimport { get_ergotree_hex } from '../contract';\nimport { getCurrentHeight, getChangeAddress, signTransaction, submitTransaction } from '../wallet-utils';\nimport { SBool, SColl, SPair } from '@fleet-sdk/serializer';\n\n// Function to submit a project to the blockchain\nexport async function buy_refund(\n    project: Project,\n    token_amount: number\n): Promise<string | null> {\n\n    /*\n        Token amount positive means buy action.\n        Token amount negative means refund action.\n    */\n\n\n    // Convert to smallest unit without rounding away from zero (handles negatives correctly)\n    token_amount = Math.trunc(token_amount * Math.pow(10, project.token_details.decimals));\n\n    // Calculate base token amount based on project's base token\n    const isERGBase = !project.base_token_id || project.base_token_id === \"\";\n    let base_token_amount = Math.abs(token_amount) * project.exchange_rate;\n\n\n    // Get the wallet address (will be the user address)\n    const walletPk = await getChangeAddress();\n\n    // Get the UTXOs from the current wallet to use as inputs\n    let walletUtxos = await window.ergo!.get_utxos();\n\n    // For refunds, ensure we have the project tokens in inputs\n    if (token_amount < 0) {\n        // Check if user has the required project tokens\n        const requiredTokenAmount = Math.abs(token_amount);\n        let hasRequiredTokens = false;\n\n\n        for (const utxo of walletUtxos) {\n            if (utxo.assets && utxo.assets.length > 0) {\n                for (const asset of utxo.assets) {\n                    if (asset.tokenId === project.project_id) {\n                        if (Number(asset.amount) >= requiredTokenAmount) {\n                            hasRequiredTokens = true;\n                            break;\n                        }\n                    }\n                }\n            }\n            if (hasRequiredTokens) break;\n        }\n\n\n        if (!hasRequiredTokens) {\n            throw new Error(`Insufficient project tokens for refund. Required: ${requiredTokenAmount}`);\n        }\n    }\n\n    const inputs = [project.box, ...walletUtxos];\n\n    // Calculate ERG value for the contract\n    let contractErgValue = project.value;\n    if (isERGBase) {\n        if (token_amount > 0) {\n            // Buy: add ERG to contract\n            contractErgValue = project.value + base_token_amount;\n        } else {\n            // Refund: contract retains ERG (user gets ERG from separate output)\n            contractErgValue = project.value; // Keep original ERG in contract\n        }\n    }\n\n\n    // Building the project output\n\n    let output = new OutputBuilder(\n        BigInt(contractErgValue).toString(),\n        get_ergotree_hex(project.constants, project.version)\n    )\n        .addTokens({\n            tokenId: project.project_id,\n            amount: BigInt(project.current_idt_amount - token_amount).toString()  // Buy: extract tokens, Refund: add tokens\n        });\n\n    // Add PFT tokens if they exist\n    if (project.current_pft_amount > 0) {\n        output.addTokens({\n            tokenId: project.pft_token_id,\n            amount: BigInt(project.current_pft_amount).toString()  // PFT token maintains constant\n        });\n    }\n\n    // Handle base token changes for non-ERG base tokens\n    if (!isERGBase && project.base_token_id) {\n        // Find current base token amount in the project box\n        let currentBaseTokenAmount = 0;\n        for (const token of project.box.assets) {\n            if (token.tokenId === project.base_token_id) {\n                currentBaseTokenAmount = Number(token.amount);\n                break;\n            }\n        }\n\n\n        // Calculate new base token amount\n        let newBaseTokenAmount;\n        if (token_amount > 0) {\n            // Buy: add base tokens to contract\n            newBaseTokenAmount = currentBaseTokenAmount + base_token_amount;\n        } else {\n            // Refund: subtract base tokens from contract (they go to user)\n            newBaseTokenAmount = currentBaseTokenAmount - base_token_amount;\n        }\n\n\n        // Ensure we don't have negative base tokens in contract\n        if (newBaseTokenAmount < 0) {\n            throw new Error(`Insufficient base tokens in contract. Available: ${currentBaseTokenAmount}, Required: ${base_token_amount}`);\n        }\n\n        // Add base token with updated amount only if > 0 to avoid zero-amount token in output\n        if (newBaseTokenAmount > 0) {\n            output.addTokens({\n                tokenId: project.base_token_id,\n                amount: BigInt(newBaseTokenAmount).toString()\n            });\n        } else {\n        }\n    }\n\n    // Update counters\n    let sold_counter = BigInt(token_amount > 0 ? project.sold_counter + token_amount : project.sold_counter);\n    let refund_counter = BigInt(token_amount < 0 ? project.refund_counter + Math.abs(token_amount) : project.refund_counter);\n\n    output.setAdditionalRegisters({\n        R4: SPair(SBool(project.is_timestamp_limit), SLong(BigInt(project.block_limit))).toHex(),\n        R5: SLong(BigInt(project.minimum_amount)).toHex(),\n        R6: SColl(SLong, [sold_counter, refund_counter, BigInt(project.auxiliar_exchange_counter)]).toHex(),\n        R7: SLong(BigInt(project.exchange_rate)).toHex(),\n        R8: createR8Structure(project.constants).toHex(),\n        R9: SString(project.content.raw)\n    });\n\n    let outputs = [output];\n\n    // Create user outputs based on action type\n    if (token_amount > 0) {\n        // Buy: user gets project tokens\n        let userOutput = new OutputBuilder(SAFE_MIN_BOX_VALUE, walletPk)\n            .addTokens({\n                tokenId: project.project_id,\n                amount: token_amount.toString()\n            });\n        outputs.push(userOutput);\n    } else if (token_amount < 0) {\n        const refundTokenAmount = Math.abs(token_amount);\n\n        // For refunds, user needs to provide the project tokens as input\n        // The user output only contains what they receive back (base tokens)\n        if (isERGBase) {\n            // For ERG refunds, user gets ERG\n            let userOutput = new OutputBuilder(\n                (BigInt(base_token_amount) + SAFE_MIN_BOX_VALUE).toString(), // Add minimum box value\n                walletPk\n            );\n            outputs.push(userOutput);\n        } else if (project.base_token_id) {\n            // For token refunds, user gets base tokens\n            let userOutput = new OutputBuilder(SAFE_MIN_BOX_VALUE, walletPk)\n                .addTokens({\n                    tokenId: project.base_token_id,\n                    amount: base_token_amount.toString()\n                });\n            outputs.push(userOutput);\n        }\n    }\n\n    // Building the unsigned transaction using Fleet SDK's built-in change handling\n    const unsignedTransaction = await new TransactionBuilder(await getCurrentHeight())\n        .from(inputs)\n        .to(outputs)\n        .sendChangeTo(walletPk)  // Fleet SDK automatically handles ERG and token change\n        .payFee(RECOMMENDED_MIN_FEE_VALUE)\n        .build()\n        .toEIP12Object();\n\n\n    // Final sanity check: ensure all token amounts in outputs are > 0\n    try {\n        const invalidTokens: Array<{ outIndex: number, tokenId: string, amount: string }> = [];\n        (unsignedTransaction.outputs || []).forEach((o: any, idx: number) => {\n            (o.assets || []).forEach((t: any) => {\n                const amt = BigInt(typeof t.amount === 'string' ? t.amount : (t.amount?.toString() ?? '0'));\n                if (amt <= 0n) {\n                    invalidTokens.push({ outIndex: idx, tokenId: t.tokenId, amount: amt.toString() });\n                }\n            });\n        });\n        if (invalidTokens.length > 0) {\n            throw new Error(\"Transaction has non-positive token amounts in outputs\");\n        }\n    } catch (e) {\n        throw e;\n    }\n\n    try {\n        // Sign the transaction\n        const signedTransaction = await signTransaction(unsignedTransaction);\n\n        // Send the transaction to the Ergo network\n        const transactionId = await submitTransaction(signedTransaction);\n\n        console.log(\"Transaction id -> \", transactionId);\n        return transactionId;\n    } catch (e) {\n        console.log(\"Transaction error:\", e);\n        throw e; // Re-throw to help with debugging\n    }\n}","path":null,"size_bytes":8525,"size_tokens":null},"src/lib/ergo/contract.ts":{"content":"import { type ConstantContent } from \"$lib/common/project\";\nimport { compile } from \"@fleet-sdk/compiler\";\nimport { Network, ErgoAddress } from \"@fleet-sdk/core\";\nimport { sha256, hex, blake2b256 } from \"@fleet-sdk/crypto\";\nimport { uint8ArrayToHex } from \"./utils\";\nimport { network_id } from \"./envs\";\nimport { get_dev_contract_address, get_dev_contract_hash, get_dev_fee } from \"./dev/dev_contract\";\n\n// Keep old imports only for get_template_hash (needed by fetch.ts)\nimport CONTRACT_V1_0 from '../../../contracts/bene_contract/contract_v1_0.es?raw';\nimport CONTRACT_V1_1 from '../../../contracts/bene_contract/contract_v1_1.es?raw';\n\n// Current version contract\nimport CONTRACT_V2 from '../../../contracts/bene_contract/contract_v2.es?raw';\nimport MINT_CONTRACT from '../../../contracts/mint_contract/mint_idt.es?raw';\n\nexport type contract_version = \"v2\" | \"v1_1\" | \"v1_0\";\n\nfunction generate_contract_v1_0(owner_addr: string, dev_fee_contract_bytes_hash: string, dev_fee: number, token_id: string) {\n  return CONTRACT_V1_0\n    .replace(/`\\+owner_addr\\+`/g, owner_addr)\n    .replace(/`\\+dev_fee_contract_bytes_hash\\+`/g, dev_fee_contract_bytes_hash)\n    .replace(/`\\+dev_fee\\+`/g, dev_fee.toString())\n    .replace(/`\\+token_id\\+`/g, token_id);\n}\n\nfunction generate_contract_v1_1(owner_addr: string, dev_fee_contract_bytes_hash: string, dev_fee: number, token_id: string) {\n  return CONTRACT_V1_1\n    .replace(/`\\+owner_addr\\+`/g, owner_addr)\n    .replace(/`\\+dev_fee_contract_bytes_hash\\+`/g, dev_fee_contract_bytes_hash)\n    .replace(/`\\+dev_fee\\+`/g, dev_fee.toString())\n    .replace(/`\\+token_id\\+`/g, token_id);\n}\n\n/**\n * Generate v2 contract (current version)\n */\nfunction generate_contract_v2(): string {\n  return CONTRACT_V2;\n}\n\nfunction handle_contract_generator(version: contract_version) {\n  let f;\n  switch (version) {\n    case \"v1_0\":\n      f = generate_contract_v1_0;\n      break;\n    case \"v1_1\":\n      f = generate_contract_v1_1;\n      break;\n    case \"v2\":\n      f = generate_contract_v2;\n      break;\n    default:\n      throw new Error(\"Invalid contract version\");\n  }\n  return f\n}\n\n/**\n * Get ErgoTree hex for current version contracts only (v2)\n */\nexport function get_ergotree_hex(constants: ConstantContent, version: contract_version) {\n  const contract = generate_contract_v2();\n\n  const ergoTree = compile(contract, { version: 1, network: network_id });\n  return ergoTree.toHex();\n}\n\n/**\n * Get template hash for ANY version (including legacy v1_0, v1_1)\n * This is needed by fetch.ts to identify old projects\n */\nexport function get_template_hash(version: contract_version): string {\n  const random_constants = {\n    \"owner\": \"9fcwctfPQPkDfHgxBns5Uu3dwWpaoywhkpLEobLuztfQuV5mt3T\",  // RANDOM\n    \"dev_addr\": get_dev_contract_address(),   // RANDOM\n    \"dev_hash\": get_dev_contract_hash(),   // RANDOM\n    \"dev_fee\": get_dev_fee(),    //  RANDOM\n    \"pft_token_id\": \"a3f7c9e12bd45890ef12aa7c6d54b9317c0df4a28b6e5590d4f1b3e8c92d77af\",   // RANDOM\n    \"base_token_id\": \"2c5d596d617aaafe16f3f58b2c562d046eda658f0243dc1119614160d92a4717\" // RANDOM\n  }\n\n  let contract;\n  if (version === \"v2\") {\n    contract = CONTRACT_V2;\n  } else {\n    contract = handle_contract_generator(version)(random_constants.owner, random_constants.dev_hash ?? get_dev_contract_hash(), random_constants.dev_fee, random_constants.pft_token_id);\n  }\n\n  let ergoTree = compile(contract, { version: 1, network: network_id });\n  let templateBytes = ergoTree.template;\n  return uint8ArrayToHex(sha256(templateBytes));\n}\n\n/**\n * Get contract hash for v2 contracts only\n */\nfunction get_contract_hash(constants: ConstantContent, version: contract_version): string {\n  try {\n    const contractSource = generate_contract_v2();\n\n    const ergoTree = compile(contractSource, {\n      version: 1,\n      network: network_id\n    });\n\n    return uint8ArrayToHex(blake2b256(ergoTree.bytes));\n  } catch (error: any) {\n    console.error(\"Error compiling contract:\", error);\n    throw new Error(`Failed to compile contract: ${error?.message || error}`);\n  }\n}\n\n/**\n * Get mint contract address for v2 contracts only\n */\nexport function mint_contract_address(constants: ConstantContent, version: contract_version) {\n  const contract_bytes_hash = get_contract_hash(constants, version);\n  let contract = MINT_CONTRACT.replace(/`\\+contract_bytes_hash\\+`/g, contract_bytes_hash);\n\n  let ergoTree = compile(contract, { version: 1, network: network_id })\n\n  let network = (network_id == \"mainnet\") ? Network.Mainnet : Network.Testnet;\n  return ergoTree.toAddress(network).toString();\n}\n","path":null,"size_bytes":4559,"size_tokens":null}},"version":2}